diff -ru --new-file linux-3.x-orig/arch/x86/configs/xpenology_defconfig linux-3.x/arch/x86/configs/xpenology_defconfig
--- linux-3.x-orig/arch/x86/configs/xpenology_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/arch/x86/configs/xpenology_defconfig	2014-12-23 17:23:09.015087000 +0000
@@ -0,0 +1,369 @@
+CONFIG_SYNO_BROMOLOW=y
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZMA=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=m
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=20
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_LZMA=y
+CONFIG_SYSCTL_SYSCALL=y
+# CONFIG_PCSPKR_PLATFORM is not set
+CONFIG_EMBEDDED=y
+CONFIG_SLAB=y
+CONFIG_SYNO_ADT7490_FEATURES=y
+CONFIG_SYNO_DISPLAY_CPUINFO=y
+CONFIG_SYNO_DUAL_HEAD=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_NO_HZ=y
+CONFIG_SMP=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+# CONFIG_SCHED_OMIT_FRAME_POINTER is not set
+CONFIG_PROCESSOR_SELECT=y
+# CONFIG_CPU_SUP_CENTAUR is not set
+CONFIG_SCHED_SMT=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_MTRR_SANITIZER is not set
+# CONFIG_X86_PAT is not set
+CONFIG_EFI=y
+# CONFIG_SECCOMP is not set
+CONFIG_HZ_1000=y
+CONFIG_KEXEC=y
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_SUSPEND is not set
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION="/dev/md1"
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+CONFIG_ACPI_DOCK=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=m
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_INTEL_IDLE=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIE_ECRC=y
+CONFIG_PCI_MSI=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_IA32_EMULATION=y
+CONFIG_IA32_AOUT=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_BRIDGE=m
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_VLAN_8021Q=m
+CONFIG_ATALK=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_NET_9P=m
+CONFIG_NET_9P_VIRTIO=m
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=m
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=655360
+CONFIG_VIRTIO_BLK=m
+CONFIG_MISC_DEVICES=y
+CONFIG_ENCLOSURE_SERVICES=y
+CONFIG_RAID_ATTRS=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_ENCLOSURE=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_ISCSI_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_ISCSI_TCP=m
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_SCSI_VIRTIO=m
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_SIL24=y
+CONFIG_ATA_PIIX=m
+CONFIG_SATA_MV=y
+CONFIG_SATA_NV=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_VIA=m
+CONFIG_PATA_AMD=m
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_SNAPSHOT=m
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_TUN=m
+CONFIG_VIRTIO_NET=m
+CONFIG_PCNET32=m
+CONFIG_TIGON3=m
+CONFIG_BNX2X=m
+CONFIG_BE2NET=m
+CONFIG_E100=m
+CONFIG_E1000=m
+CONFIG_E1000E=m
+CONFIG_IGB=m
+CONFIG_IGBVF=m
+CONFIG_IXGB=m
+CONFIG_IXGBE=m
+CONFIG_IXGBEVF=m
+CONFIG_FORCEDETH=m
+# CONFIG_NET_PACKET_ENGINE is not set
+CONFIG_QLA3XXX=m
+CONFIG_QLCNIC=m
+CONFIG_QLGE=m
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+CONFIG_R8169=m
+CONFIG_SIS900=m
+CONFIG_SIS190=m
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_VELOCITY=m
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_ASYNC=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_USB_NET_QMI_WWAN_SYNO=m
+CONFIG_VMXNET3=m
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PNP is not set
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_I801=m
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_SENSORS_ADT7475=m
+CONFIG_SENSORS_CORETEMP=y
+CONFIG_SENSORS_IT87=y
+CONFIG_SSB=m
+CONFIG_AGP=m
+CONFIG_AGP_INTEL=m
+CONFIG_DRM=m
+CONFIG_DRM_I915=m
+CONFIG_FB=y
+CONFIG_FB_VESA=y
+# CONFIG_ADI9889 is not set
+# CONFIG_THS8200 is not set
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_SOUND=m
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_AC97_POWER_SAVE=y
+CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_INTEL8X0=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SOUND_PRIME=m
+CONFIG_HID=m
+CONFIG_USB_HIDDEV=y
+CONFIG_USB=m
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_ETRON_HCD=m
+CONFIG_USB_ETRON_HCD_DEBUGGING=y
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_SSB=y
+CONFIG_USB_UHCI_HCD=m
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM_SYNO=m
+CONFIG_USB_STORAGE=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_RTC_CLASS=y
+CONFIG_DMADEVICES=y
+CONFIG_INTEL_IOATDMA=m
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_VIRTIO_PCI=m
+CONFIG_VIRTIO_BALLOON=m
+CONFIG_VIRTIO_MMIO=m
+CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES=y
+CONFIG_STAGING=y
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_HOST=m
+CONFIG_USBIP_DEBUG=y
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=m
+CONFIG_EFI_VARS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SYNO_ACL=y
+CONFIG_BTRFS_FS=m
+CONFIG_QUOTA=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QFMT_V2=m
+CONFIG_FUSE_FS=m
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_PROC_KCORE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_ECRYPT_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_AUFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_USE_NEW_IDMAPPER=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V4=y
+CONFIG_CIFS=m
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_MAC_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_FTRACE is not set
+CONFIG_OPTIMIZE_INLINING=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_AES_NI_INTEL=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_X86_64_3WAY=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_XZ_DEC=y
+CONFIG_AVERAGE=y
diff -ru --new-file linux-3.x-orig/arch/x86/Kconfig linux-3.x/arch/x86/Kconfig
--- linux-3.x-orig/arch/x86/Kconfig	2014-12-11 11:27:33.000000000 +0000
+++ linux-3.x/arch/x86/Kconfig	2014-12-23 17:23:09.015087000 +0000
@@ -512,21 +512,21 @@
 	depends on HW_MUTEXES
 	prompt "MUTEX controller support for Intel CE2600 platform"
 	default MUTEX_FIFO
-	help
+	---help---
 	Allows the configuration of the MUTEX controller working mode in Intel CE platform
 
-	config MUTEX_FIFO
-		bool "FIFO scheduler"
+config MUTEX_FIFO
+	bool "FIFO scheduler"
 	help
 	 Mutex works in FIFO scheduler mode, which is the default behavior
 
-	config MUTEX_NULL
-		bool "Null scheduler"
+config MUTEX_NULL
+	bool "Null scheduler"
 	help
 	 Mutex works in Null scheduler mode
 
-	config MUTEX_POLLING
-		bool "Polling mode"
+config MUTEX_POLLING
+	bool "Polling mode"
 	help
 	 works in polling mode, interrupt is disabled
 
diff -ru --new-file linux-3.x-orig/arch/x86/kernel/setup.c linux-3.x/arch/x86/kernel/setup.c
--- linux-3.x-orig/arch/x86/kernel/setup.c	2014-12-11 11:32:48.000000000 +0000
+++ linux-3.x/arch/x86/kernel/setup.c	2014-12-23 17:23:09.015087000 +0000
@@ -199,6 +199,11 @@
 extern char gszRaidSwapUuid[48];
 #endif
 
+#ifdef XPENOLOGY
+extern int gSynoVid;
+extern int gSynoPid;
+#endif
+
 /*
  * end_pfn only includes RAM, while max_pfn_mapped includes all e820 entries.
  * The direct mapping extends to max_pfn_mapped, so that we can directly access
@@ -940,6 +945,24 @@
 __setup("swap_uuid=", early_swap_uuid);
 #endif
 
+#ifdef XPENOLOGY
+static int __init early_vid(char *p)
+{
+	gSynoVid = simple_strtol(p, NULL, 16);
+	printk("synoboot vid: %d\n", gSynoVid);
+	return 1;
+}
+__setup("vid=", early_vid);
+
+static int __init early_pid(char *p)
+{
+	gSynoPid = simple_strtol(p, NULL, 16);
+	printk("synoboot pid: %d\n", gSynoPid);
+	return 1;
+}
+__setup("pid=", early_pid);
+#endif
+
 /*
  * --------- Crashkernel reservation ------------------------------
  */
diff -ru --new-file linux-3.x-orig/arch/x86/mm/fault.c linux-3.x/arch/x86/mm/fault.c
--- linux-3.x-orig/arch/x86/mm/fault.c	2014-12-11 11:32:48.000000000 +0000
+++ linux-3.x/arch/x86/mm/fault.c	2014-12-23 17:23:09.015087000 +0000
@@ -688,6 +688,7 @@
 show_signal_msg(struct pt_regs *regs, unsigned long error_code,
 		unsigned long address, struct task_struct *tsk)
 {
+#ifndef XPENOLOGY
 	if (!unhandled_signal(tsk, SIGSEGV))
 		return;
 
@@ -702,6 +703,7 @@
 	print_vma_addr(KERN_CONT " in ", regs->ip);
 
 	printk(KERN_CONT "\n");
+#endif
 }
 
 static void
diff -ru --new-file linux-3.x-orig/Documentation/ABI/testing/debugfs-aufs linux-3.x/Documentation/ABI/testing/debugfs-aufs
--- linux-3.x-orig/Documentation/ABI/testing/debugfs-aufs	2014-12-11 11:27:33.000000000 +0000
+++ linux-3.x/Documentation/ABI/testing/debugfs-aufs	2014-12-23 17:23:09.011087000 +0000
@@ -6,6 +6,19 @@
 		per aufs mount, where <id> is a unique id generated
 		internally.
 
+What:		/debug/aufs/si_<id>/plink
+Date:		Apr 2013
+Contact:	J. R. Okajima <hooanon05@yahoo.co.jp>
+Description:
+		It has three lines and shows the information about the
+		pseudo-link. The first line is a single number
+		representing a number of buckets. The second line is a
+		number of pseudo-links per buckets (separated by a
+		blank). The last line is a single number representing a
+		total number of psedo-links.
+		When the aufs mount option 'noplink' is specified, it
+		will show "1\n0\n0\n".
+
 What:		/debug/aufs/si_<id>/xib
 Date:		March 2009
 Contact:	J. R. Okajima <hooanon05@yahoo.co.jp>
@@ -13,8 +26,7 @@
 		It shows the consumed blocks by xib (External Inode Number
 		Bitmap), its block size and file size.
 		When the aufs mount option 'noxino' is specified, it
-		will be empty. About XINO files, see
-		Documentation/filesystems/aufs/aufs.5 in detail.
+		will be empty. About XINO files, see the aufs manual.
 
 What:		/debug/aufs/si_<id>/xino0, xino1 ... xinoN
 Date:		March 2009
@@ -24,8 +36,7 @@
 		Translation Table), its link count, block size and file
 		size.
 		When the aufs mount option 'noxino' is specified, it
-		will be empty. About XINO files, see
-		Documentation/filesystems/aufs/aufs.5 in detail.
+		will be empty. About XINO files, see the aufs manual.
 
 What:		/debug/aufs/si_<id>/xigen
 Date:		March 2009
@@ -36,5 +47,4 @@
 		If CONFIG_AUFS_EXPORT is disabled, this entry will not
 		be created.
 		When the aufs mount option 'noxino' is specified, it
-		will be empty. About XINO files, see
-		Documentation/filesystems/aufs/aufs.5 in detail.
+		will be empty. About XINO files, see the aufs manual.
diff -ru --new-file linux-3.x-orig/Documentation/ABI/testing/sysfs-aufs linux-3.x/Documentation/ABI/testing/sysfs-aufs
--- linux-3.x-orig/Documentation/ABI/testing/sysfs-aufs	2014-12-11 11:27:33.000000000 +0000
+++ linux-3.x/Documentation/ABI/testing/sysfs-aufs	2014-12-23 17:23:09.011087000 +0000
@@ -13,6 +13,13 @@
 		It shows the abolute path of a member directory (which
 		is called branch) in aufs, and its permission.
 
+What:		/sys/fs/aufs/si_<id>/brid0, brid1 ... bridN
+Date:		July 2013
+Contact:	J. R. Okajima <hooanon05@yahoo.co.jp>
+Description:
+		It shows the id of a member directory (which is called
+		branch) in aufs.
+
 What:		/sys/fs/aufs/si_<id>/xi_path
 Date:		March 2009
 Contact:	J. R. Okajima <hooanon05@yahoo.co.jp>
@@ -21,5 +28,4 @@
 		Bitmap, Translation Table and Generation Table) file
 		even if it is the default path.
 		When the aufs mount option 'noxino' is specified, it
-		will be empty. About XINO files, see
-		Documentation/filesystems/aufs/aufs.5 in detail.
+		will be empty. About XINO files, see the aufs manual.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/01intro.txt linux-3.x/Documentation/filesystems/aufs/design/01intro.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/01intro.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/01intro.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,162 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Introduction
+----------------------------------------
+
+aufs [ei ju: ef es] | [a u f s]
+1. abbrev. for "advanced multi-layered unification filesystem".
+2. abbrev. for "another unionfs".
+3. abbrev. for "auf das" in German which means "on the" in English.
+   Ex. "Butter aufs Brot"(G) means "butter onto bread"(E).
+   But "Filesystem aufs Filesystem" is hard to understand.
+
+AUFS is a filesystem with features:
+- multi layered stackable unification filesystem, the member directory
+  is called as a branch.
+- branch permission and attribute, 'readonly', 'real-readonly',
+  'readwrite', 'whiteout-able', 'link-able whiteout' and their
+  combination.
+- internal "file copy-on-write".
+- logical deletion, whiteout.
+- dynamic branch manipulation, adding, deleting and changing permission.
+- allow bypassing aufs, user's direct branch access.
+- external inode number translation table and bitmap which maintains the
+  persistent aufs inode number.
+- seekable directory, including NFS readdir.
+- file mapping, mmap and sharing pages.
+- pseudo-link, hardlink over branches.
+- loopback mounted filesystem as a branch.
+- several policies to select one among multiple writable branches.
+- revert a single systemcall when an error occurs in aufs.
+- and more...
+
+
+Multi Layered Stackable Unification Filesystem
+----------------------------------------------------------------------
+Most people already knows what it is.
+It is a filesystem which unifies several directories and provides a
+merged single directory. When users access a file, the access will be
+passed/re-directed/converted (sorry, I am not sure which English word is
+correct) to the real file on the member filesystem. The member
+filesystem is called 'lower filesystem' or 'branch' and has a mode
+'readonly' and 'readwrite.' And the deletion for a file on the lower
+readonly branch is handled by creating 'whiteout' on the upper writable
+branch.
+
+On LKML, there have been discussions about UnionMount (Jan Blunck,
+Bharata B Rao and Valerie Aurora) and Unionfs (Erez Zadok). They took
+different approaches to implement the merged-view.
+The former tries putting it into VFS, and the latter implements as a
+separate filesystem.
+(If I misunderstand about these implementations, please let me know and
+I shall correct it. Because it is a long time ago when I read their
+source files last time).
+
+UnionMount's approach will be able to small, but may be hard to share
+branches between several UnionMount since the whiteout in it is
+implemented in the inode on branch filesystem and always
+shared. According to Bharata's post, readdir does not seems to be
+finished yet.
+There are several missing features known in this implementations such as
+- for users, the inode number may change silently. eg. copy-up.
+- link(2) may break by copy-up.
+- read(2) may get an obsoleted filedata (fstat(2) too).
+- fcntl(F_SETLK) may be broken by copy-up.
+- unnecessary copy-up may happen, for example mmap(MAP_PRIVATE) after
+  open(O_RDWR).
+
+Unionfs has a longer history. When I started implementing a stacking filesystem
+(Aug 2005), it already existed. It has virtual super_block, inode,
+dentry and file objects and they have an array pointing lower same kind
+objects. After contributing many patches for Unionfs, I re-started my
+project AUFS (Jun 2006).
+
+In AUFS, the structure of filesystem resembles to Unionfs, but I
+implemented my own ideas, approaches and enhancements and it became
+totally different one.
+
+Comparing DM snapshot and fs based implementation
+- the number of bytes to be copied between devices is much smaller.
+- the type of filesystem must be one and only.
+- the fs must be writable, no readonly fs, even for the lower original
+  device. so the compression fs will not be usable. but if we use
+  loopback mount, we may address this issue.
+  for instance,
+	mount /cdrom/squashfs.img /sq
+	losetup /sq/ext2.img
+	losetup /somewhere/cow
+	dmsetup "snapshot /dev/loop0 /dev/loop1 ..."
+- it will be difficult (or needs more operations) to extract the
+  difference between the original device and COW.
+- DM snapshot-merge may help a lot when users try merging. in the
+  fs-layer union, users will use rsync(1).
+
+
+Several characters/aspects of aufs
+----------------------------------------------------------------------
+
+Aufs has several characters or aspects.
+1. a filesystem, callee of VFS helper
+2. sub-VFS, caller of VFS helper for branches
+3. a virtual filesystem which maintains persistent inode number
+4. reader/writer of files on branches such like an application
+
+1. Callee of VFS Helper
+As an ordinary linux filesystem, aufs is a callee of VFS. For instance,
+unlink(2) from an application reaches sys_unlink() kernel function and
+then vfs_unlink() is called. vfs_unlink() is one of VFS helper and it
+calls filesystem specific unlink operation. Actually aufs implements the
+unlink operation but it behaves like a redirector.
+
+2. Caller of VFS Helper for Branches
+aufs_unlink() passes the unlink request to the branch filesystem as if
+it were called from VFS. So the called unlink operation of the branch
+filesystem acts as usual. As a caller of VFS helper, aufs should handle
+every necessary pre/post operation for the branch filesystem.
+- acquire the lock for the parent dir on a branch
+- lookup in a branch
+- revalidate dentry on a branch
+- mnt_want_write() for a branch
+- vfs_unlink() for a branch
+- mnt_drop_write() for a branch
+- release the lock on a branch
+
+3. Persistent Inode Number
+One of the most important issue for a filesystem is to maintain inode
+numbers. This is particularly important to support exporting a
+filesystem via NFS. Aufs is a virtual filesystem which doesn't have a
+backend block device for its own. But some storage is necessary to
+maintain inode number. It may be a large space and may not suit to keep
+in memory. Aufs rents some space from its first writable branch
+filesystem (by default) and creates file(s) on it. These files are
+created by aufs internally and removed soon (currently) keeping opened.
+Note: Because these files are removed, they are totally gone after
+      unmounting aufs. It means the inode numbers are not persistent
+      across unmount or reboot. I have a plan to make them really
+      persistent which will be important for aufs on NFS server.
+
+4. Read/Write Files Internally (copy-on-write)
+Because a branch can be readonly, when you write a file on it, aufs will
+"copy-up" it to the upper writable branch internally. And then write the
+originally requested thing to the file. Generally kernel doesn't
+open/read/write file actively. In aufs, even a single write may cause a
+internal "file copy". This behaviour is very similar to cp(1) command.
+
+Some people may think it is better to pass such work to user space
+helper, instead of doing in kernel space. Actually I am still thinking
+about it. But currently I have implemented it in kernel space.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/02struct.txt linux-3.x/Documentation/filesystems/aufs/design/02struct.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/02struct.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/02struct.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,226 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Basic Aufs Internal Structure
+
+Superblock/Inode/Dentry/File Objects
+----------------------------------------------------------------------
+As like an ordinary filesystem, aufs has its own
+superblock/inode/dentry/file objects. All these objects have a
+dynamically allocated array and store the same kind of pointers to the
+lower filesystem, branch.
+For example, when you build a union with one readwrite branch and one
+readonly, mounted /au, /rw and /ro respectively.
+- /au = /rw + /ro
+- /ro/fileA exists but /rw/fileA
+
+Aufs lookup operation finds /ro/fileA and gets dentry for that. These
+pointers are stored in a aufs dentry. The array in aufs dentry will be,
+- [0] = NULL
+- [1] = /ro/fileA
+
+This style of an array is essentially same to the aufs
+superblock/inode/dentry/file objects.
+
+Because aufs supports manipulating branches, ie. add/delete/change
+dynamically, these objects has its own generation. When branches are
+changed, the generation in aufs superblock is incremented. And a
+generation in other object are compared when it is accessed.
+When a generation in other objects are obsoleted, aufs refreshes the
+internal array.
+
+
+Superblock
+----------------------------------------------------------------------
+Additionally aufs superblock has some data for policies to select one
+among multiple writable branches, XIB files, pseudo-links and kobject.
+See below in detail.
+About the policies which supports copy-down a directory, see policy.txt
+too.
+
+
+Branch and XINO(External Inode Number Translation Table)
+----------------------------------------------------------------------
+Every branch has its own xino (external inode number translation table)
+file. The xino file is created and unlinked by aufs internally. When two
+members of a union exist on the same filesystem, they share the single
+xino file.
+The struct of a xino file is simple, just a sequence of aufs inode
+numbers which is indexed by the lower inode number.
+In the above sample, assume the inode number of /ro/fileA is i111 and
+aufs assigns the inode number i999 for fileA. Then aufs writes 999 as
+4(8) bytes at 111 * 4(8) bytes offset in the xino file.
+
+When the inode numbers are not contiguous, the xino file will be sparse
+which has a hole in it and doesn't consume as much disk space as it
+might appear. If your branch filesystem consumes disk space for such
+holes, then you should specify 'xino=' option at mounting aufs.
+
+Also a writable branch has three kinds of "whiteout bases". All these
+are existed when the branch is joined to aufs and the names are
+whiteout-ed doubly, so that users will never see their names in aufs
+hierarchy.
+1. a regular file which will be linked to all whiteouts.
+2. a directory to store a pseudo-link.
+3. a directory to store an "orphan-ed" file temporary.
+
+1. Whiteout Base
+   When you remove a file on a readonly branch, aufs handles it as a
+   logical deletion and creates a whiteout on the upper writable branch
+   as a hardlink of this file in order not to consume inode on the
+   writable branch.
+2. Pseudo-link Dir
+   See below, Pseudo-link.
+3. Step-Parent Dir
+   When "fileC" exists on the lower readonly branch only and it is
+   opened and removed with its parent dir, and then user writes
+   something into it, then aufs copies-up fileC to this
+   directory. Because there is no other dir to store fileC. After
+   creating a file under this dir, the file is unlinked.
+
+Because aufs supports manipulating branches, ie. add/delete/change
+dynamically, a branch has its own id. When the branch order changes, aufs
+finds the new index by searching the branch id.
+
+
+Pseudo-link
+----------------------------------------------------------------------
+Assume "fileA" exists on the lower readonly branch only and it is
+hardlinked to "fileB" on the branch. When you write something to fileA,
+aufs copies-up it to the upper writable branch. Additionally aufs
+creates a hardlink under the Pseudo-link Directory of the writable
+branch. The inode of a pseudo-link is kept in aufs super_block as a
+simple list. If fileB is read after unlinking fileA, aufs returns
+filedata from the pseudo-link instead of the lower readonly
+branch. Because the pseudo-link is based upon the inode, to keep the
+inode number by xino (see above) is important.
+
+All the hardlinks under the Pseudo-link Directory of the writable branch
+should be restored in a proper location later. Aufs provides a utility
+to do this. The userspace helpers executed at remounting and unmounting
+aufs by default.
+During this utility is running, it puts aufs into the pseudo-link
+maintenance mode. In this mode, only the process which began the
+maintenance mode (and its child processes) is allowed to operate in
+aufs. Some other processes which are not related to the pseudo-link will
+be allowed to run too, but the rest have to return an error or wait
+until the maintenance mode ends. If a process already acquires an inode
+mutex (in VFS), it has to return an error.
+
+
+XIB(external inode number bitmap)
+----------------------------------------------------------------------
+Addition to the xino file per a branch, aufs has an external inode number
+bitmap in a superblock object. It is also a file such like a xino file.
+It is a simple bitmap to mark whether the aufs inode number is in-use or
+not.
+To reduce the file I/O, aufs prepares a single memory page to cache xib.
+
+Aufs implements a feature to truncate/refresh both of xino and xib to
+reduce the number of consumed disk blocks for these files.
+
+
+Virtual or Vertical Dir, and Readdir in Userspace
+----------------------------------------------------------------------
+In order to support multiple layers (branches), aufs readdir operation
+constructs a virtual dir block on memory. For readdir, aufs calls
+vfs_readdir() internally for each dir on branches, merges their entries
+with eliminating the whiteout-ed ones, and sets it to file (dir)
+object. So the file object has its entry list until it is closed. The
+entry list will be updated when the file position is zero and becomes
+old. This decision is made in aufs automatically.
+
+The dynamically allocated memory block for the name of entries has a
+unit of 512 bytes (by default) and stores the names contiguously (no
+padding). Another block for each entry is handled by kmem_cache too.
+During building dir blocks, aufs creates hash list and judging whether
+the entry is whiteouted by its upper branch or already listed.
+The merged result is cached in the corresponding inode object and
+maintained by a customizable life-time option.
+
+Some people may call it can be a security hole or invite DoS attack
+since the opened and once readdir-ed dir (file object) holds its entry
+list and becomes a pressure for system memory. But I'd say it is similar
+to files under /proc or /sys. The virtual files in them also holds a
+memory page (generally) while they are opened. When an idea to reduce
+memory for them is introduced, it will be applied to aufs too.
+For those who really hate this situation, I've developed readdir(3)
+library which operates this merging in userspace. You just need to set
+LD_PRELOAD environment variable, and aufs will not consume no memory in
+kernel space for readdir(3).
+
+
+Workqueue
+----------------------------------------------------------------------
+Aufs sometimes requires privilege access to a branch. For instance,
+in copy-up/down operation. When a user process is going to make changes
+to a file which exists in the lower readonly branch only, and the mode
+of one of ancestor directories may not be writable by a user
+process. Here aufs copy-up the file with its ancestors and they may
+require privilege to set its owner/group/mode/etc.
+This is a typical case of a application character of aufs (see
+Introduction).
+
+Aufs uses workqueue synchronously for this case. It creates its own
+workqueue. The workqueue is a kernel thread and has privilege. Aufs
+passes the request to call mkdir or write (for example), and wait for
+its completion. This approach solves a problem of a signal handler
+simply.
+If aufs didn't adopt the workqueue and changed the privilege of the
+process, and if the mkdir/write call arises SIGXFSZ or other signal,
+then the user process might gain a privilege or the generated core file
+was owned by a superuser.
+
+Also aufs uses the system global workqueue ("events" kernel thread) too
+for asynchronous tasks, such like handling inotify/fsnotify, re-creating a
+whiteout base and etc. This is unrelated to a privilege.
+Most of aufs operation tries acquiring a rw_semaphore for aufs
+superblock at the beginning, at the same time waits for the completion
+of all queued asynchronous tasks.
+
+
+Whiteout
+----------------------------------------------------------------------
+The whiteout in aufs is very similar to Unionfs's. That is represented
+by its filename. UnionMount takes an approach of a file mode, but I am
+afraid several utilities (find(1) or something) will have to support it.
+
+Basically the whiteout represents "logical deletion" which stops aufs to
+lookup further, but also it represents "dir is opaque" which also stop
+lookup.
+
+In aufs, rmdir(2) and rename(2) for dir uses whiteout alternatively.
+In order to make several functions in a single systemcall to be
+revertible, aufs adopts an approach to rename a directory to a temporary
+unique whiteouted name.
+For example, in rename(2) dir where the target dir already existed, aufs
+renames the target dir to a temporary unique whiteouted name before the
+actual rename on a branch and then handles other actions (make it opaque,
+update the attributes, etc). If an error happens in these actions, aufs
+simply renames the whiteouted name back and returns an error. If all are
+succeeded, aufs registers a function to remove the whiteouted unique
+temporary name completely and asynchronously to the system global
+workqueue.
+
+
+Copy-up
+----------------------------------------------------------------------
+It is a well-known feature or concept.
+When user modifies a file on a readonly branch, aufs operate "copy-up"
+internally and makes change to the new file on the upper writable branch.
+When the trigger systemcall does not update the timestamps of the parent
+dir, aufs reverts it after copy-up.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/03lookup.txt linux-3.x/Documentation/filesystems/aufs/design/03lookup.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/03lookup.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/03lookup.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,106 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Lookup in a Branch
+----------------------------------------------------------------------
+Since aufs has a character of sub-VFS (see Introduction), it operates
+lookup for branches as VFS does. It may be a heavy work. Generally
+speaking struct nameidata is a bigger structure and includes many
+information. But almost all lookup operation in aufs is the simplest
+case, ie. lookup only an entry directly connected to its parent. Digging
+down the directory hierarchy is unnecessary.
+
+VFS has a function lookup_one_len() for that use, but it is not usable
+for a branch filesystem which requires struct nameidata. So aufs
+implements a simple lookup wrapper function. When a branch filesystem
+allows NULL as nameidata, it calls lookup_one_len(). Otherwise it builds
+a simplest nameidata and calls lookup_hash().
+Here aufs applies "a principle in NFSD", ie. if the filesystem supports
+NFS-export, then it has to support NULL as a nameidata parameter for
+->create(), ->lookup() and ->d_revalidate(). So the lookup wrapper in
+aufs tests if ->s_export_op in the branch is NULL or not.
+
+When a branch is a remote filesystem, aufs basically trusts its
+->d_revalidate(), also aufs forces the hardest revalidate tests for
+them.
+For d_revalidate, aufs implements three levels of revalidate tests. See
+"Revalidate Dentry and UDBA" in detail.
+
+
+Loopback Mount
+----------------------------------------------------------------------
+Basically aufs supports any type of filesystem and block device for a
+branch (actually there are some exceptions). But it is prohibited to add
+a loopback mounted one whose backend file exists in a filesystem which is
+already added to aufs. The reason is to protect aufs from a recursive
+lookup. If it was allowed, the aufs lookup operation might re-enter a
+lookup for the loopback mounted branch in the same context, and will
+cause a deadlock.
+
+
+Revalidate Dentry and UDBA (User's Direct Branch Access)
+----------------------------------------------------------------------
+Generally VFS helpers re-validate a dentry as a part of lookup.
+0. digging down the directory hierarchy.
+1. lock the parent dir by its i_mutex.
+2. lookup the final (child) entry.
+3. revalidate it.
+4. call the actual operation (create, unlink, etc.)
+5. unlock the parent dir
+
+If the filesystem implements its ->d_revalidate() (step 3), then it is
+called. Actually aufs implements it and checks the dentry on a branch is
+still valid.
+But it is not enough. Because aufs has to release the lock for the
+parent dir on a branch at the end of ->lookup() (step 2) and
+->d_revalidate() (step 3) while the i_mutex of the aufs dir is still
+held by VFS.
+If the file on a branch is changed directly, eg. bypassing aufs, after
+aufs released the lock, then the subsequent operation may cause
+something unpleasant result.
+
+This situation is a result of VFS architecture, ->lookup() and
+->d_revalidate() is separated. But I never say it is wrong. It is a good
+design from VFS's point of view. It is just not suitable for sub-VFS
+character in aufs.
+
+Aufs supports such case by three level of revalidation which is
+selectable by user.
+1. Simple Revalidate
+   Addition to the native flow in VFS's, confirm the child-parent
+   relationship on the branch just after locking the parent dir on the
+   branch in the "actual operation" (step 4). When this validation
+   fails, aufs returns EBUSY. ->d_revalidate() (step 3) in aufs still
+   checks the validation of the dentry on branches.
+2. Monitor Changes Internally by Inotify/Fsnotify
+   Addition to above, in the "actual operation" (step 4) aufs re-lookup
+   the dentry on the branch, and returns EBUSY if it finds different
+   dentry.
+   Additionally, aufs sets the inotify/fsnotify watch for every dir on branches
+   during it is in cache. When the event is notified, aufs registers a
+   function to kernel 'events' thread by schedule_work(). And the
+   function sets some special status to the cached aufs dentry and inode
+   private data. If they are not cached, then aufs has nothing to
+   do. When the same file is accessed through aufs (step 0-3) later,
+   aufs will detect the status and refresh all necessary data.
+   In this mode, aufs has to ignore the event which is fired by aufs
+   itself.
+3. No Extra Validation
+   This is the simplest test and doesn't add any additional revalidation
+   test, and skip therevalidatin in step 4. It is useful and improves
+   aufs performance when system surely hide the aufs branches from user,
+   by over-mounting something (or another method).
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/04branch.txt linux-3.x/Documentation/filesystems/aufs/design/04branch.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/04branch.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/04branch.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,76 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Branch Manipulation
+
+Since aufs supports dynamic branch manipulation, ie. add/remove a branch
+and changing its permission/attribute, there are a lot of works to do.
+
+
+Add a Branch
+----------------------------------------------------------------------
+o Confirm the adding dir exists outside of aufs, including loopback
+  mount.
+- and other various attributes...
+o Initialize the xino file and whiteout bases if necessary.
+  See struct.txt.
+
+o Check the owner/group/mode of the directory
+  When the owner/group/mode of the adding directory differs from the
+  existing branch, aufs issues a warning because it may impose a
+  security risk.
+  For example, when a upper writable branch has a world writable empty
+  top directory, a malicious user can create any files on the writable
+  branch directly, like copy-up and modify manually. If something like
+  /etc/{passwd,shadow} exists on the lower readonly branch but the upper
+  writable branch, and the writable branch is world-writable, then a
+  malicious guy may create /etc/passwd on the writable branch directly
+  and the infected file will be valid in aufs.
+  I am afraid it can be a security issue, but nothing to do except
+  producing a warning.
+
+
+Delete a Branch
+----------------------------------------------------------------------
+o Confirm the deleting branch is not busy
+  To be general, there is one merit to adopt "remount" interface to
+  manipulate branches. It is to discard caches. At deleting a branch,
+  aufs checks the still cached (and connected) dentries and inodes. If
+  there are any, then they are all in-use. An inode without its
+  corresponding dentry can be alive alone (for example, inotify/fsnotify case).
+
+  For the cached one, aufs checks whether the same named entry exists on
+  other branches.
+  If the cached one is a directory, because aufs provides a merged view
+  to users, as long as one dir is left on any branch aufs can show the
+  dir to users. In this case, the branch can be removed from aufs.
+  Otherwise aufs rejects deleting the branch.
+
+  If any file on the deleting branch is opened by aufs, then aufs
+  rejects deleting.
+
+
+Modify the Permission of a Branch
+----------------------------------------------------------------------
+o Re-initialize or remove the xino file and whiteout bases if necessary.
+  See struct.txt.
+
+o rw --> ro: Confirm the modifying branch is not busy
+  Aufs rejects the request if any of these conditions are true.
+  - a file on the branch is mmap-ed.
+  - a regular file on the branch is opened for write and there is no
+    same named entry on the upper branch.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/05wbr_policy.txt linux-3.x/Documentation/filesystems/aufs/design/05wbr_policy.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/05wbr_policy.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/05wbr_policy.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,65 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Policies to Select One among Multiple Writable Branches
+----------------------------------------------------------------------
+When the number of writable branch is more than one, aufs has to decide
+the target branch for file creation or copy-up. By default, the highest
+writable branch which has the parent (or ancestor) dir of the target
+file is chosen (top-down-parent policy).
+By user's request, aufs implements some other policies to select the
+writable branch, for file creation two policies, round-robin and
+most-free-space policies. For copy-up three policies, top-down-parent,
+bottom-up-parent and bottom-up policies.
+
+As expected, the round-robin policy selects the branch in circular. When
+you have two writable branches and creates 10 new files, 5 files will be
+created for each branch. mkdir(2) systemcall is an exception. When you
+create 10 new directories, all will be created on the same branch.
+And the most-free-space policy selects the one which has most free
+space among the writable branches. The amount of free space will be
+checked by aufs internally, and users can specify its time interval.
+
+The policies for copy-up is more simple,
+top-down-parent is equivalent to the same named on in create policy,
+bottom-up-parent selects the writable branch where the parent dir
+exists and the nearest upper one from the copyup-source,
+bottom-up selects the nearest upper writable branch from the
+copyup-source, regardless the existence of the parent dir.
+
+There are some rules or exceptions to apply these policies.
+- If there is a readonly branch above the policy-selected branch and
+  the parent dir is marked as opaque (a variation of whiteout), or the
+  target (creating) file is whiteout-ed on the upper readonly branch,
+  then the result of the policy is ignored and the target file will be
+  created on the nearest upper writable branch than the readonly branch.
+- If there is a writable branch above the policy-selected branch and
+  the parent dir is marked as opaque or the target file is whiteouted
+  on the branch, then the result of the policy is ignored and the target
+  file will be created on the highest one among the upper writable
+  branches who has diropq or whiteout. In case of whiteout, aufs removes
+  it as usual.
+- link(2) and rename(2) systemcalls are exceptions in every policy.
+  They try selecting the branch where the source exists as possible
+  since copyup a large file will take long time. If it can't be,
+  ie. the branch where the source exists is readonly, then they will
+  follow the copyup policy.
+- There is an exception for rename(2) when the target exists.
+  If the rename target exists, aufs compares the index of the branches
+  where the source and the target exists and selects the higher
+  one. If the selected branch is readonly, then aufs follows the
+  copyup policy.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/06mmap.txt linux-3.x/Documentation/filesystems/aufs/design/06mmap.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/06mmap.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/06mmap.txt	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,47 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+mmap(2) -- File Memory Mapping
+----------------------------------------------------------------------
+In aufs, the file-mapped pages are handled by a branch fs directly, no
+interaction with aufs. It means aufs_mmap() calls the branch fs's
+->mmap().
+This approach is simple and good, but there is one problem.
+Under /proc, several entries show the mmap-ped files by its path (with
+device and inode number), and the printed path will be the path on the
+branch fs's instead of virtual aufs's.
+This is not a problem in most cases, but some utilities lsof(1) (and its
+user) may expect the path on aufs.
+
+To address this issue, aufs adds a new member called vm_prfile in struct
+vm_area_struct (and struct vm_region). The original vm_file points to
+the file on the branch fs in order to handle everything correctly as
+usual. The new vm_prfile points to a virtual file in aufs, and the
+show-functions in procfs refers to vm_prfile if it is set.
+Also we need to maintain several other places where touching vm_file
+such like
+- fork()/clone() copies vma and the reference count of vm_file is
+  incremented.
+- merging vma maintains the ref count too.
+
+This is not a good approach. It just faking the printed path. But it
+leaves all behaviour around f_mapping unchanged. This is surely an
+advantage.
+Actually aufs had adopted another complicated approach which calls
+generic_file_mmap() and handles struct vm_operations_struct. In this
+approach, aufs met a hard problem and I could not solve it without
+switching the approach.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/07export.txt linux-3.x/Documentation/filesystems/aufs/design/07export.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/07export.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/07export.txt	2014-12-23 17:23:09.015087000 +0000
@@ -0,0 +1,59 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Export Aufs via NFS
+----------------------------------------------------------------------
+Here is an approach.
+- like xino/xib, add a new file 'xigen' which stores aufs inode
+  generation.
+- iget_locked(): initialize aufs inode generation for a new inode, and
+  store it in xigen file.
+- destroy_inode(): increment aufs inode generation and store it in xigen
+  file. it is necessary even if it is not unlinked, because any data of
+  inode may be changed by UDBA.
+- encode_fh(): for a root dir, simply return FILEID_ROOT. otherwise
+  build file handle by
+  + branch id (4 bytes)
+  + superblock generation (4 bytes)
+  + inode number (4 or 8 bytes)
+  + parent dir inode number (4 or 8 bytes)
+  + inode generation (4 bytes))
+  + return value of exportfs_encode_fh() for the parent on a branch (4
+    bytes)
+  + file handle for a branch (by exportfs_encode_fh())
+- fh_to_dentry():
+  + find the index of a branch from its id in handle, and check it is
+    still exist in aufs.
+  + 1st level: get the inode number from handle and search it in cache.
+  + 2nd level: if not found, get the parent inode number from handle and
+    search it in cache. and then open the parent dir, find the matching
+    inode number by vfs_readdir() and get its name, and call
+    lookup_one_len() for the target dentry.
+  + 3rd level: if the parent dir is not cached, call
+    exportfs_decode_fh() for a branch and get the parent on a branch,
+    build a pathname of it, convert it a pathname in aufs, call
+    path_lookup(). now aufs gets a parent dir dentry, then handle it as
+    the 2nd level.
+  + to open the dir, aufs needs struct vfsmount. aufs keeps vfsmount
+    for every branch, but not itself. to get this, (currently) aufs
+    searches in current->nsproxy->mnt_ns list. it may not be a good
+    idea, but I didn't get other approach.
+  + test the generation of the gotten inode.
+- every inode operation: they may get EBUSY due to UDBA. in this case,
+  convert it into ESTALE for NFSD.
+- readdir(): call lockdep_on/off() because filldir in NFSD calls
+  lookup_one_len(), vfs_getattr(), encode_fh() and others.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/08shwh.txt linux-3.x/Documentation/filesystems/aufs/design/08shwh.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/08shwh.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/08shwh.txt	2014-12-23 17:23:09.015087000 +0000
@@ -0,0 +1,53 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Show Whiteout Mode (shwh)
+----------------------------------------------------------------------
+Generally aufs hides the name of whiteouts. But in some cases, to show
+them is very useful for users. For instance, creating a new middle layer
+(branch) by merging existing layers.
+
+(borrowing aufs1 HOW-TO from a user, Michael Towers)
+When you have three branches,
+- Bottom: 'system', squashfs (underlying base system), read-only
+- Middle: 'mods', squashfs, read-only
+- Top: 'overlay', ram (tmpfs), read-write
+
+The top layer is loaded at boot time and saved at shutdown, to preserve
+the changes made to the system during the session.
+When larger changes have been made, or smaller changes have accumulated,
+the size of the saved top layer data grows. At this point, it would be
+nice to be able to merge the two overlay branches ('mods' and 'overlay')
+and rewrite the 'mods' squashfs, clearing the top layer and thus
+restoring save and load speed.
+
+This merging is simplified by the use of another aufs mount, of just the
+two overlay branches using the 'shwh' option.
+# mount -t aufs -o ro,shwh,br:/livesys/overlay=ro+wh:/livesys/mods=rr+wh \
+	aufs /livesys/merge_union
+
+A merged view of these two branches is then available at
+/livesys/merge_union, and the new feature is that the whiteouts are
+visible!
+Note that in 'shwh' mode the aufs mount must be 'ro', which will disable
+writing to all branches. Also the default mode for all branches is 'ro'.
+It is now possible to save the combined contents of the two overlay
+branches to a new squashfs, e.g.:
+# mksquashfs /livesys/merge_union /path/to/newmods.squash
+
+This new squashfs archive can be stored on the boot device and the
+initramfs will use it to replace the old one at the next boot.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/10dynop.txt linux-3.x/Documentation/filesystems/aufs/design/10dynop.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/10dynop.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/10dynop.txt	2014-12-23 17:23:09.015087000 +0000
@@ -0,0 +1,47 @@
+
+# Copyright (C) 2010-2013 Junjiro R. Okajima
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Dynamically customizable FS operations
+----------------------------------------------------------------------
+Generally FS operations (struct inode_operations, struct
+address_space_operations, struct file_operations, etc.) are defined as
+"static const", but it never means that FS have only one set of
+operation. Some FS have multiple sets of them. For instance, ext2 has
+three sets, one for XIP, for NOBH, and for normal.
+Since aufs overrides and redirects these operations, sometimes aufs has
+to change its behaviour according to the branch FS type. More imporantly
+VFS acts differently if a function (member in the struct) is set or
+not. It means aufs should have several sets of operations and select one
+among them according to the branch FS definition.
+
+In order to solve this problem and not to affect the behavour of VFS,
+aufs defines these operations dynamically. For instance, aufs defines
+aio_read function for struct file_operations, but it may not be set to
+the file_operations. When the branch FS doesn't have it, aufs doesn't
+set it to its file_operations while the function definition itself is
+still alive. So the behaviour of io_submit(2) will not change, and it
+will return an error when aio_read is not defined.
+
+The lifetime of these dynamically generated operation object is
+maintained by aufs branch object. When the branch is removed from aufs,
+the reference counter of the object is decremented. When it reaches
+zero, the dynamically generated operation object will be freed.
+
+This approach is designed to support AIO (io_submit), Direcit I/O and
+XIP mainly.
+Currently this approach is applied to file_operations and
+vm_operations_struct for regular files only.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/design/99plan.txt linux-3.x/Documentation/filesystems/aufs/design/99plan.txt
--- linux-3.x-orig/Documentation/filesystems/aufs/design/99plan.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/design/99plan.txt	2014-12-23 17:23:09.015087000 +0000
@@ -0,0 +1,96 @@
+
+# Copyright (C) 2005-2013 Junjiro R. Okajima
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Plan
+
+Restoring some features which was implemented in aufs1.
+They were dropped in aufs2 in order to make source files simpler and
+easier to be reviewed.
+
+
+Test Only the Highest One for the Directory Permission (dirperm1 option)
+----------------------------------------------------------------------
+Let's try case study.
+- aufs has two branches, upper readwrite and lower readonly.
+  /au = /rw + /ro
+- "dirA" exists under /ro, but /rw. and its mode is 0700.
+- user invoked "chmod a+rx /au/dirA"
+- then "dirA" becomes world readable?
+
+In this case, /ro/dirA is still 0700 since it exists in readonly branch,
+or it may be a natively readonly filesystem. If aufs respects the lower
+branch, it should not respond readdir request from other users. But user
+allowed it by chmod. Should really aufs rejects showing the entries
+under /ro/dirA?
+
+To be honest, I don't have a best solution for this case. So I
+implemented 'dirperm1' and 'nodirperm1' option in aufs1, and leave it to
+users.
+When dirperm1 is specified, aufs checks only the highest one for the
+directory permission, and shows the entries. Otherwise, as usual, checks
+every dir existing on all branches and rejects the request.
+
+As a side effect, dirperm1 option improves the performance of aufs
+because the number of permission check is reduced.
+
+
+Being Another Aufs's Readonly Branch (robr)
+----------------------------------------------------------------------
+Aufs1 allows aufs to be another aufs's readonly branch.
+This feature was developed by a user's request. But it may not be used
+currecnly.
+
+
+Copy-up on Open (coo=)
+----------------------------------------------------------------------
+By default the internal copy-up is executed when it is really necessary.
+It is not done when a file is opened for writing, but when write(2) is
+done. Users who have many (over 100) branches want to know and analyse
+when and what file is copied-up. To insert a new upper branch which
+contains such files only may improve the performance of aufs.
+
+Aufs1 implemented "coo=none | leaf | all" option.
+
+
+Refresh the Opened File (refrof)
+----------------------------------------------------------------------
+This option is implemented in aufs1 but incomplete.
+
+When user reads from a file, he expects to get its latest filedata
+generally. If the file is removed and a new same named file is created,
+the content he gets is unchanged, ie. the unlinked filedata.
+
+Let's try case study again.
+- aufs has two branches.
+  /au = /rw + /ro
+- "fileA" exists under /ro, but /rw.
+- user opened "/au/fileA".
+- he or someone else inserts a branch (/new) between /rw and /ro.
+  /au = /rw + /new + /ro
+- the new branch has "fileA".
+- user reads from the opened "fileA"
+- which filedata should aufs return, from /ro or /new?
+
+Some people says it has to be "from /ro" and it is a semantics of Unix.
+The others say it should be "from /new" because the file is not removed
+and it is equivalent to the case of someone else modifies the file.
+
+Here again I don't have a best and final answer. I got an idea to
+implement 'refrof' and 'norefrof' option. When 'refrof' (REFResh the
+Opened File) is specified (by default), aufs returns the filedata from
+/new.
+Otherwise from /new.
diff -ru --new-file linux-3.x-orig/Documentation/filesystems/aufs/README linux-3.x/Documentation/filesystems/aufs/README
--- linux-3.x-orig/Documentation/filesystems/aufs/README	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/Documentation/filesystems/aufs/README	2014-12-23 17:23:09.011087000 +0000
@@ -0,0 +1,338 @@
+
+Aufs3 -- advanced multi layered unification filesystem version 3.x
+http://aufs.sf.net
+Junjiro R. Okajima
+
+
+0. Introduction
+----------------------------------------
+In the early days, aufs was entirely re-designed and re-implemented
+Unionfs Version 1.x series. After many original ideas, approaches,
+improvements and implementations, it becomes totally different from
+Unionfs while keeping the basic features.
+Recently, Unionfs Version 2.x series begin taking some of the same
+approaches to aufs1's.
+Unionfs is being developed by Professor Erez Zadok at Stony Brook
+University and his team.
+
+Aufs3 supports linux-3.0 and later.
+If you want older kernel version support, try aufs2-2.6.git or
+aufs2-standalone.git repository, aufs1 from CVS on SourceForge.
+
+Note: it becomes clear that "Aufs was rejected. Let's give it up."
+According to Christoph Hellwig, linux rejects all union-type filesystems
+but UnionMount.
+<http://marc.info/?l=linux-kernel&m=123938533724484&w=2>
+
+
+1. Features
+----------------------------------------
+- unite several directories into a single virtual filesystem. The member
+  directory is called as a branch.
+- you can specify the permission flags to the branch, which are 'readonly',
+  'readwrite' and 'whiteout-able.'
+- by upper writable branch, internal copyup and whiteout, files/dirs on
+  readonly branch are modifiable logically.
+- dynamic branch manipulation, add, del.
+- etc...
+
+Also there are many enhancements in aufs1, such as:
+- readdir(3) in userspace.
+- keep inode number by external inode number table
+- keep the timestamps of file/dir in internal copyup operation
+- seekable directory, supporting NFS readdir.
+- whiteout is hardlinked in order to reduce the consumption of inodes
+  on branch
+- do not copyup, nor create a whiteout when it is unnecessary
+- revert a single systemcall when an error occurs in aufs
+- remount interface instead of ioctl
+- maintain /etc/mtab by an external command, /sbin/mount.aufs.
+- loopback mounted filesystem as a branch
+- kernel thread for removing the dir who has a plenty of whiteouts
+- support copyup sparse file (a file which has a 'hole' in it)
+- default permission flags for branches
+- selectable permission flags for ro branch, whether whiteout can
+  exist or not
+- export via NFS.
+- support <sysfs>/fs/aufs and <debugfs>/aufs.
+- support multiple writable branches, some policies to select one
+  among multiple writable branches.
+- a new semantics for link(2) and rename(2) to support multiple
+  writable branches.
+- no glibc changes are required.
+- pseudo hardlink (hardlink over branches)
+- allow a direct access manually to a file on branch, e.g. bypassing aufs.
+  including NFS or remote filesystem branch.
+- userspace wrapper for pathconf(3)/fpathconf(3) with _PC_LINK_MAX.
+- and more...
+
+Currently these features are dropped temporary from aufs3.
+See design/08plan.txt in detail.
+- test only the highest one for the directory permission (dirperm1)
+- copyup on open (coo=)
+- nested mount, i.e. aufs as readonly no-whiteout branch of another aufs
+  (robr)
+- statistics of aufs thread (/sys/fs/aufs/stat)
+- delegation mode (dlgt)
+  a delegation of the internal branch access to support task I/O
+  accounting, which also supports Linux Security Modules (LSM) mainly
+  for Suse AppArmor.
+- intent.open/create (file open in a single lookup)
+
+Features or just an idea in the future (see also design/*.txt),
+- reorder the branch index without del/re-add.
+- permanent xino files for NFSD
+- an option for refreshing the opened files after add/del branches
+- 'move' policy for copy-up between two writable branches, after
+  checking free space.
+- light version, without branch manipulation. (unnecessary?)
+- copyup in userspace
+- inotify in userspace
+- readv/writev
+- xattr, acl
+
+
+2. Download
+----------------------------------------
+There were three GIT trees for aufs3, aufs3-linux.git,
+aufs3-standalone.git, and aufs-util.git. Note that there is no "3" in
+"aufs-util.git."
+While the aufs-util is always necessary, you need either of aufs3-linux
+or aufs3-standalone.
+
+The aufs3-linux tree includes the whole linux mainline GIT tree,
+git://git.kernel.org/.../torvalds/linux.git.
+And you cannot select CONFIG_AUFS_FS=m for this version, eg. you cannot
+build aufs3 as an external kernel module.
+
+On the other hand, the aufs3-standalone tree has only aufs source files
+and necessary patches, and you can select CONFIG_AUFS_FS=m.
+
+You will find GIT branches whose name is in form of "aufs3.x" where "x"
+represents the linux kernel version, "linux-3.x". For instance,
+"aufs3.0" is for linux-3.0. For latest "linux-3.x-rcN", use
+"aufs3.x-rcN" branch.
+
+o aufs3-linux tree
+$ git clone --reference /your/linux/git/tree \
+	git://git.code.sf.net/p/aufs/aufs3-linux aufs-aufs3-linux \
+	aufs3-linux.git
+- if you don't have linux GIT tree, then remove "--reference ..."
+$ cd aufs3-linux.git
+$ git checkout origin/aufs3.0
+
+o aufs3-standalone tree
+$ git clone git://git.code.sf.net/p/aufs/aufs3-standalone \
+	aufs3-standalone.git
+$ cd aufs3-standalone.git
+$ git checkout origin/aufs3.0
+
+o aufs-util tree
+$ git clone git://git.code.sf.net/p/aufs/aufs-util \
+	aufs-util.git
+$ cd aufs-util.git
+$ git checkout origin/aufs3.0
+
+Note: The 3.x-rcN branch is to be used with `rc' kernel versions ONLY.
+The minor version number, 'x' in '3.x', of aufs may not always
+follow the minor version number of the kernel.
+Because changes in the kernel that cause the use of a new
+minor version number do not always require changes to aufs-util.
+
+Since aufs-util has its own minor version number, you may not be
+able to find a GIT branch in aufs-util for your kernel's
+exact minor version number.
+In this case, you should git-checkout the branch for the
+nearest lower number.
+
+For (an unreleased) example:
+If you are using "linux-3.10" and the "aufs3.10" branch
+does not exist in aufs-util repository, then "aufs3.9", "aufs3.8"
+or something numerically smaller is the branch for your kernel.
+
+Also you can view all branches by
+	$ git branch -a
+
+
+3. Configuration and Compilation
+----------------------------------------
+Make sure you have git-checkout'ed the correct branch.
+
+For aufs3-linux tree,
+- enable CONFIG_EXPERIMENTAL and CONFIG_AUFS_FS.
+- set other aufs configurations if necessary.
+
+For aufs3-standalone tree,
+There are several ways to build.
+
+1.
+- apply ./aufs3-kbuild.patch to your kernel source files.
+- apply ./aufs3-base.patch too.
+- apply ./aufs3-mmap.patch too.
+- apply ./aufs3-standalone.patch too, if you have a plan to set
+  CONFIG_AUFS_FS=m. otherwise you don't need ./aufs3-standalone.patch.
+- copy ./{Documentation,fs,include/linux/aufs_type.h} files to your
+  kernel source tree. Never copy $PWD/include/linux/Kbuild.
+- enable CONFIG_EXPERIMENTAL and CONFIG_AUFS_FS, you can select either
+  =m or =y.
+- and build your kernel as usual.
+- install the built kernel.
+- install the header files too by "make headers_install" to the
+  directory where you specify. By default, it is $PWD/usr.
+  "make help" shows a brief note for headers_install.
+- and reboot your system.
+
+2.
+- module only (CONFIG_AUFS_FS=m).
+- apply ./aufs3-base.patch to your kernel source files.
+- apply ./aufs3-mmap.patch too.
+- apply ./aufs3-standalone.patch too.
+- build your kernel, don't forget "make headers_install", and reboot.
+- edit ./config.mk and set other aufs configurations if necessary.
+  Note: You should read $PWD/fs/aufs/Kconfig carefully which describes
+  every aufs configurations.
+- build the module by simple "make".
+- you can specify ${KDIR} make variable which points to your kernel
+  source tree.
+- install the files
+  + run "make install" to install the aufs module, or copy the built
+    $PWD/aufs.ko to /lib/modules/... and run depmod -a (or reboot simply).
+  + run "make install_headers" (instead of headers_install) to install
+    the modified aufs header file (you can specify DESTDIR which is
+    available in aufs standalone version's Makefile only), or copy
+    $PWD/usr/include/linux/aufs_type.h to /usr/include/linux or wherever
+    you like manually. By default, the target directory is $PWD/usr.
+- no need to apply aufs3-kbuild.patch, nor copying source files to your
+  kernel source tree.
+
+Note: The header file aufs_type.h is necessary to build aufs-util
+      as well as "make headers_install" in the kernel source tree.
+      headers_install is subject to be forgotten, but it is essentially
+      necessary, not only for building aufs-util.
+      You may not meet problems without headers_install in some older
+      version though.
+
+And then,
+- read README in aufs-util, build and install it
+- note that your distribution may contain an obsoleted version of
+  aufs_type.h in /usr/include/linux or something. When you build aufs
+  utilities, make sure that your compiler refers the correct aufs header
+  file which is built by "make headers_install."
+- if you want to use readdir(3) in userspace or pathconf(3) wrapper,
+  then run "make install_ulib" too. And refer to the aufs manual in
+  detail.
+
+
+4. Usage
+----------------------------------------
+At first, make sure aufs-util are installed, and please read the aufs
+manual, aufs.5 in aufs-util.git tree.
+$ man -l aufs.5
+
+And then,
+$ mkdir /tmp/rw /tmp/aufs
+# mount -t aufs -o br=/tmp/rw:${HOME} none /tmp/aufs
+
+Here is another example. The result is equivalent.
+# mount -t aufs -o br=/tmp/rw=rw:${HOME}=ro none /tmp/aufs
+  Or
+# mount -t aufs -o br:/tmp/rw none /tmp/aufs
+# mount -o remount,append:${HOME} /tmp/aufs
+
+Then, you can see whole tree of your home dir through /tmp/aufs. If
+you modify a file under /tmp/aufs, the one on your home directory is
+not affected, instead the same named file will be newly created under
+/tmp/rw. And all of your modification to a file will be applied to
+the one under /tmp/rw. This is called the file based Copy on Write
+(COW) method.
+Aufs mount options are described in aufs.5.
+If you run chroot or something and make your aufs as a root directory,
+then you need to customize the shutdown script. See the aufs manual in
+detail.
+
+Additionally, there are some sample usages of aufs which are a
+diskless system with network booting, and LiveCD over NFS.
+See sample dir in CVS tree on SourceForge.
+
+
+5. Contact
+----------------------------------------
+When you have any problems or strange behaviour in aufs, please let me
+know with:
+- /proc/mounts (instead of the output of mount(8))
+- /sys/module/aufs/*
+- /sys/fs/aufs/* (if you have them)
+- /debug/aufs/* (if you have them)
+- linux kernel version
+  if your kernel is not plain, for example modified by distributor,
+  the url where i can download its source is necessary too.
+- aufs version which was printed at loading the module or booting the
+  system, instead of the date you downloaded.
+- configuration (define/undefine CONFIG_AUFS_xxx)
+- kernel configuration or /proc/config.gz (if you have it)
+- behaviour which you think to be incorrect
+- actual operation, reproducible one is better
+- mailto: aufs-users at lists.sourceforge.net
+
+Usually, I don't watch the Public Areas(Bugs, Support Requests, Patches,
+and Feature Requests) on SourceForge. Please join and write to
+aufs-users ML.
+
+
+6. Acknowledgements
+----------------------------------------
+Thanks to everyone who have tried and are using aufs, whoever
+have reported a bug or any feedback.
+
+Especially donators:
+Tomas Matejicek(slax.org) made a donation (much more than once).
+	Since Apr 2010, Tomas M (the author of Slax and Linux Live
+	scripts) is making "doubling" donations.
+	Unfortunately I cannot list all of the donators, but I really
+	appreciate.
+	It ends Aug 2010, but the ordinary donation URL is still available.
+	<http://sourceforge.net/donate/index.php?group_id=167503>
+Dai Itasaka made a donation (2007/8).
+Chuck Smith made a donation (2008/4, 10 and 12).
+Henk Schoneveld made a donation (2008/9).
+Chih-Wei Huang, ASUS, CTC donated Eee PC 4G (2008/10).
+Francois Dupoux made a donation (2008/11).
+Bruno Cesar Ribas and Luis Carlos Erpen de Bona, C3SL serves public
+	aufs2 GIT tree (2009/2).
+William Grant made a donation (2009/3).
+Patrick Lane made a donation (2009/4).
+The Mail Archive (mail-archive.com) made donations (2009/5).
+Nippy Networks (Ed Wildgoose) made a donation (2009/7).
+New Dream Network, LLC (www.dreamhost.com) made a donation (2009/11).
+Pavel Pronskiy made a donation (2011/2).
+Iridium and Inmarsat satellite phone retailer (www.mailasail.com), Nippy
+	Networks (Ed Wildgoose) made a donation for hardware (2011/3).
+Max Lekomcev (DOM-TV project) made a donation (2011/7, 12, 2012/3, 6 and
+11).
+Sam Liddicott made a donation (2011/9).
+Era Scarecrow made a donation (2013/4).
+Bor Ratajc made a donation (2013/4).
+Alessandro Gorreta made a donation (2013/4).
+POIRETTE Marc made a donation (2013/4).
+Alessandro Gorreta made a donation (2013/4).
+lauri kasvandik made a donation (2013/5).
+"pemasu from Finland" made a donation (2013/7).
+The Parted Magic Project made a donation (2013/9).
+Pavel Barta made a donation (2013/10).
+
+Thank you very much.
+Donations are always, including future donations, very important and
+helpful for me to keep on developing aufs.
+
+
+7.
+----------------------------------------
+If you are an experienced user, no explanation is needed. Aufs is
+just a linux filesystem.
+
+
+Enjoy!
+
+# Local variables: ;
+# mode: text;
+# End: ;
diff -ru --new-file linux-3.x-orig/drivers/ata/libata-core.c linux-3.x/drivers/ata/libata-core.c
--- linux-3.x-orig/drivers/ata/libata-core.c	2014-12-11 11:32:19.000000000 +0000
+++ linux-3.x/drivers/ata/libata-core.c	2014-12-23 17:23:09.015087000 +0000
@@ -7415,7 +7415,7 @@
 int (*funcSYNODiskRetryReport)(unsigned int, unsigned int) = NULL;
 EXPORT_SYMBOL(funcSYNODiskRetryReport);
 
-#ifdef SYNO_SATA_EBOX_REFRESH
+#if defined(SYNO_SATA_EBOX_REFRESH) || defined(XPENOLOGY)
 int (*funcSYNOSendEboxRefreshEvent)(int portIndex) = NULL;
 EXPORT_SYMBOL(funcSYNOSendEboxRefreshEvent);
 #endif
diff -ru --new-file linux-3.x-orig/drivers/ata/libata-eh.c linux-3.x/drivers/ata/libata-eh.c
--- linux-3.x-orig/drivers/ata/libata-eh.c	2014-12-11 11:32:19.000000000 +0000
+++ linux-3.x/drivers/ata/libata-eh.c	2014-12-23 17:23:09.023087000 +0000
@@ -103,6 +103,8 @@
 extern int syno_is_alpine_internal_ahci(struct ata_port *);
 #endif
 
+extern int (*funcSYNODiskRetryReport)(unsigned int, unsigned int);
+
 /* The following table determines how we sequence resets.  Each entry
  * represents timeout for that try.  The first try can be soft or
  * hardreset.  All others are hardreset if available.  In most cases
diff -ru --new-file linux-3.x-orig/drivers/ata/libata-scsi.c linux-3.x/drivers/ata/libata-scsi.c
--- linux-3.x-orig/drivers/ata/libata-scsi.c	2014-12-11 11:32:19.000000000 +0000
+++ linux-3.x/drivers/ata/libata-scsi.c	2014-12-23 17:23:09.023087000 +0000
@@ -712,6 +712,7 @@
 END:
 	return iRet;
 }
+EXPORT_SYMBOL(syno_libata_port_power_ctl);
 
 /*
  *
@@ -5829,5 +5830,6 @@
 
 	return index;
 }
+EXPORT_SYMBOL(syno_libata_index_get);
 #endif
 
diff -ru --new-file linux-3.x-orig/drivers/ata/sata_mv.c linux-3.x/drivers/ata/sata_mv.c
--- linux-3.x-orig/drivers/ata/sata_mv.c	2014-12-11 11:32:19.000000000 +0000
+++ linux-3.x/drivers/ata/sata_mv.c	2014-12-23 17:23:09.023087000 +0000
@@ -3671,6 +3671,9 @@
 #ifdef SYNO_SATA_MV_GPIO_RW
 int syno_sata_mv_gpio_read(const unsigned short hostnum)
 {
+#ifdef XPENOLOGY
+	return 0;
+#else
 	struct Scsi_Host *shost = scsi_host_lookup(hostnum);
 	struct ata_port *ap = NULL;
 	void __iomem *host_mmio = NULL;
@@ -3705,12 +3708,14 @@
 		scsi_host_put(shost);
 	}
 	return ret;
+#endif
 }
 EXPORT_SYMBOL(syno_sata_mv_gpio_read);
 
 /*FIXME - Too brutal and directly, should separate into levels*/
 void syno_sata_mv_gpio_write(u8 blFaulty, const unsigned short hostnum)
 {
+#ifndef XPENOLOGY
 	struct Scsi_Host *shost = scsi_host_lookup(hostnum);
 	struct ata_port *ap = NULL;
 	void __iomem *host_mmio = NULL;
@@ -3745,6 +3750,7 @@
 	if (NULL != shost) {
 		scsi_host_put(shost);
 	}
+#endif
 	return;
 }
 EXPORT_SYMBOL(syno_sata_mv_gpio_write);
diff -ru --new-file linux-3.x-orig/drivers/i2c/busses/Kconfig linux-3.x/drivers/i2c/busses/Kconfig
--- linux-3.x-orig/drivers/i2c/busses/Kconfig	2014-12-11 11:27:34.000000000 +0000
+++ linux-3.x/drivers/i2c/busses/Kconfig	2014-12-23 17:23:09.023087000 +0000
@@ -607,10 +607,6 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-pxa.
 
-config I2C_PXA_PCI
-	def_bool I2C_PXA && X86_32 && PCI && OF
-	depends on !ARCH_GEN3
-
 config I2C_PXA_SLAVE
 	bool "Intel PXA2XX I2C Slave comms support"
 	depends on I2C_PXA && !X86_32
diff -ru --new-file linux-3.x-orig/drivers/pci/quirks.c linux-3.x/drivers/pci/quirks.c
--- linux-3.x-orig/drivers/pci/quirks.c	2014-12-11 11:32:12.000000000 +0000
+++ linux-3.x/drivers/pci/quirks.c	2014-12-23 17:23:09.023087000 +0000
@@ -618,7 +618,9 @@
          ( pin < 0 || pin >= 96 ) ||
          NULL == pValue )
     {
+#ifndef XPENOLOGY
         printk("parameter error. gpiobase=%08X, pin=%d, pValue=%p\n", gpiobase, pin, pValue);
+#endif
         goto END;
     }
     
diff -ru --new-file linux-3.x-orig/drivers/scsi/sd.c linux-3.x/drivers/scsi/sd.c
--- linux-3.x-orig/drivers/scsi/sd.c	2014-12-11 11:32:03.000000000 +0000
+++ linux-3.x/drivers/scsi/sd.c	2014-12-23 17:23:09.023087000 +0000
@@ -94,6 +94,11 @@
 MODULE_ALIAS_SCSI_DEVICE(TYPE_MOD);
 MODULE_ALIAS_SCSI_DEVICE(TYPE_RBC);
 
+#ifdef XPENOLOGY
+int gSynoVid;
+int gSynoPid;
+#endif
+
 #if !defined(CONFIG_DEBUG_BLOCK_EXT_DEVT)
 #define SD_MINORS	16
 #else
@@ -3053,8 +3058,8 @@
 		if (NULL == usbdev) {
 			return SYNO_DISK_USB;
 		}
-		if (IS_SYNO_USBBOOT_ID_VENDOR(le16_to_cpu(usbdev->descriptor.idVendor)) &&
-			IS_SYNO_USBBOOT_ID_PRODUCT(le16_to_cpu(usbdev->descriptor.idProduct)) &&
+		if ((le16_to_cpu(usbdev->descriptor.idVendor) == gSynoVid) &&
+			(le16_to_cpu(usbdev->descriptor.idProduct) == gSynoPid) &&
 			gSynoHasDynModule) {
 			if (!syno_find_synoboot()) {
 				return SYNO_DISK_SYNOBOOT;
diff -ru --new-file linux-3.x-orig/drivers/spi/Kconfig linux-3.x/drivers/spi/Kconfig
--- linux-3.x-orig/drivers/spi/Kconfig	2014-12-11 11:27:36.000000000 +0000
+++ linux-3.x/drivers/spi/Kconfig	2014-12-23 17:23:09.027087000 +0000
@@ -297,9 +297,6 @@
 	help
 	  This drivers supports the Intel CE SPI master controller
 
-config SPI_PXA2XX_PCI
-	def_bool SPI_PXA2XX && X86_32 && PCI && !GEN3_SPI 
-
 config SPI_CE5XX_SPI_SLAVE
 	tristate "CE5XX SPI SLAVE"
 	depends on ARCH_GEN3
diff -ru --new-file linux-3.x-orig/drivers/tty/vt/vt.c linux-3.x/drivers/tty/vt/vt.c
--- linux-3.x-orig/drivers/tty/vt/vt.c	2014-12-11 11:32:19.000000000 +0000
+++ linux-3.x/drivers/tty/vt/vt.c	2014-12-23 17:23:09.027087000 +0000
@@ -2474,7 +2474,7 @@
 		return kmsg_con;
 }
 
-#ifndef SYNO_X86_TTY_CONSOLE_OUTPUT
+#if !defined(SYNO_X86_TTY_CONSOLE_OUTPUT) || defined(XPENOLOGY)
 /*
  *	Console on virtual terminal
  *
@@ -2574,7 +2574,7 @@
 }
 #endif
 
-#ifndef SYNO_X86_TTY_CONSOLE_OUTPUT
+#if !defined(SYNO_X86_TTY_CONSOLE_OUTPUT) || defined(XPENOLOGY)
 static struct tty_driver *vt_console_device(struct console *c, int *index)
 {
 	*index = c->index ? c->index-1 : fg_console;
@@ -2942,7 +2942,7 @@
 
 	console_unlock();
 
-#ifndef SYNO_X86_TTY_CONSOLE_OUTPUT
+#if !defined(SYNO_X86_TTY_CONSOLE_OUTPUT) || defined(XPENOLOGY)
 #ifdef CONFIG_VT_CONSOLE
 	register_console(&vt_console_driver);
 #endif
diff -ru --new-file linux-3.x-orig/fs/aufs/aufs.h linux-3.x/fs/aufs/aufs.h
--- linux-3.x-orig/fs/aufs/aufs.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/aufs.h	2014-12-23 17:23:09.027087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -ru --new-file linux-3.x-orig/fs/aufs/branch.c linux-3.x/fs/aufs/branch.c
--- linux-3.x-orig/fs/aufs/branch.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/branch.c	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,13 +21,40 @@
  */
 
 #include <linux/compat.h>
-#include <linux/file.h>
 #include <linux/statfs.h>
 #include "aufs.h"
 
 /*
  * free a single branch
  */
+
+/* prohibit rmdir to the root of the branch */
+/* todo: another new flag? */
+static void au_br_dflags_force(struct au_branch *br)
+{
+	struct dentry *h_dentry;
+
+	h_dentry = au_br_dentry(br);
+	spin_lock(&h_dentry->d_lock);
+	br->br_dflags = h_dentry->d_flags & DCACHE_MOUNTED;
+	h_dentry->d_flags |= DCACHE_MOUNTED;
+	spin_unlock(&h_dentry->d_lock);
+}
+
+/* restore its d_flags */
+static void au_br_dflags_restore(struct au_branch *br)
+{
+	struct dentry *h_dentry;
+
+	if (br->br_dflags)
+		return;
+
+	h_dentry = au_br_dentry(br);
+	spin_lock(&h_dentry->d_lock);
+	h_dentry->d_flags &= ~DCACHE_MOUNTED;
+	spin_unlock(&h_dentry->d_lock);
+}
+
 static void au_br_do_free(struct au_branch *br)
 {
 	int i;
@@ -57,7 +84,12 @@
 		else
 			break;
 
-	mntput(br->br_mnt);
+	au_br_dflags_restore(br);
+
+	/* recursive lock, s_umount of branch's */
+	lockdep_off();
+	path_put(&br->br_path);
+	lockdep_on();
 	kfree(wbr);
 	kfree(br);
 }
@@ -254,12 +286,12 @@
 		if ((h_inode->i_mode & S_IALLUGO) != (inode->i_mode & S_IALLUGO)
 		    || h_inode->i_uid != inode->i_uid
 		    || h_inode->i_gid != inode->i_gid)
-			pr_warning("uid/gid/perm %s %u/%u/0%o, %u/%u/0%o\n",
-				   add->pathname,
-				   inode->i_uid, inode->i_gid,
-				   (inode->i_mode & S_IALLUGO),
-				   h_inode->i_uid, h_inode->i_gid,
-				   (h_inode->i_mode & S_IALLUGO));
+			pr_warn("uid/gid/perm %s %u/%u/0%o, %u/%u/0%o\n",
+				add->pathname,
+				inode->i_uid, inode->i_gid,
+				(inode->i_mode & S_IALLUGO),
+				h_inode->i_uid, h_inode->i_gid,
+				(h_inode->i_mode & S_IALLUGO));
 	}
 
 out:
@@ -270,7 +302,7 @@
  * initialize or clean the whiteouts for an adding branch
  */
 static int au_br_init_wh(struct super_block *sb, struct au_branch *br,
-			 int new_perm, struct dentry *h_root)
+			 int new_perm)
 {
 	int err, old_perm;
 	aufs_bindex_t bindex;
@@ -288,14 +320,14 @@
 		hdir = au_hi(sb->s_root->d_inode, bindex);
 		au_hn_imtx_lock_nested(hdir, AuLsc_I_PARENT);
 	} else {
-		h_mtx = &h_root->d_inode->i_mutex;
+		h_mtx = &au_br_dentry(br)->d_inode->i_mutex;
 		mutex_lock_nested(h_mtx, AuLsc_I_PARENT);
 	}
 	if (!wbr)
-		err = au_wh_init(h_root, br, sb);
+		err = au_wh_init(br, sb);
 	else {
 		wbr_wh_write_lock(wbr);
-		err = au_wh_init(h_root, br, sb);
+		err = au_wh_init(br, sb);
 		wbr_wh_write_unlock(wbr);
 	}
 	if (hdir)
@@ -313,12 +345,11 @@
 }
 
 static int au_wbr_init(struct au_branch *br, struct super_block *sb,
-		       int perm, struct path *path)
+		       int perm)
 {
 	int err;
 	struct kstatfs kst;
 	struct au_wbr *wbr;
-	struct dentry *h_dentry;
 
 	wbr = br->br_wbr;
 	au_rw_init(&wbr->wbr_wh_rwsem);
@@ -330,17 +361,16 @@
 	 * a limit for rmdir/rename a dir
 	 * cf. AUFS_MAX_NAMELEN in include/linux/aufs_type.h
 	 */
-	err = vfs_statfs(path, &kst);
+	err = vfs_statfs(&br->br_path, &kst);
 	if (unlikely(err))
 		goto out;
 	err = -EINVAL;
-	h_dentry = path->dentry;
 	if (kst.f_namelen >= NAME_MAX)
-		err = au_br_init_wh(sb, br, perm, h_dentry);
+		err = au_br_init_wh(sb, br, perm);
 	else
 		pr_err("%.*s(%s), unsupported namelen %ld\n",
-		       AuDLNPair(h_dentry), au_sbtype(h_dentry->d_sb),
-		       kst.f_namelen);
+		       AuDLNPair(au_br_dentry(br)),
+		       au_sbtype(au_br_dentry(br)->d_sb), kst.f_namelen);
 
 out:
 	return err;
@@ -356,17 +386,19 @@
 	memset(&br->br_xino, 0, sizeof(br->br_xino));
 	mutex_init(&br->br_xino.xi_nondir_mtx);
 	br->br_perm = add->perm;
-	br->br_mnt = add->path.mnt; /* set first, mntget() later */
+	BUILD_BUG_ON(sizeof(br->br_dflags)
+		     != sizeof(br->br_path.dentry->d_flags));
+	br->br_dflags = DCACHE_MOUNTED;
+	br->br_path = add->path; /* set first, path_get() later */
 	spin_lock_init(&br->br_dykey_lock);
 	memset(br->br_dykey, 0, sizeof(br->br_dykey));
 	atomic_set(&br->br_count, 0);
-	br->br_xino_upper = AUFS_XINO_TRUNC_INIT;
 	atomic_set(&br->br_xino_running, 0);
 	br->br_id = au_new_br_id(sb);
 	AuDebugOn(br->br_id < 0);
 
 	if (au_br_writable(add->perm)) {
-		err = au_wbr_init(br, sb, add->perm, &add->path);
+		err = au_wbr_init(br, sb, add->perm);
 		if (unlikely(err))
 			goto out_err;
 	}
@@ -381,11 +413,11 @@
 	}
 
 	sysaufs_br_init(br);
-	mntget(add->path.mnt);
+	path_get(&br->br_path);
 	goto out; /* success */
 
 out_err:
-	br->br_mnt = NULL;
+	memset(&br->br_path, 0, sizeof(br->br_path));
 out:
 	return err;
 }
@@ -437,23 +469,28 @@
 		iinfo->ii_bstart = 0;
 }
 
-static void au_br_do_add(struct super_block *sb, struct dentry *h_dentry,
-			 struct au_branch *br, aufs_bindex_t bindex)
+static void au_br_do_add(struct super_block *sb, struct au_branch *br,
+			 aufs_bindex_t bindex)
 {
-	struct dentry *root;
+	struct dentry *root, *h_dentry;
 	struct inode *root_inode;
 	aufs_bindex_t bend, amount;
 
+	au_br_dflags_force(br);
+
 	root = sb->s_root;
 	root_inode = root->d_inode;
 	bend = au_sbend(sb);
 	amount = bend + 1 - bindex;
+	h_dentry = au_br_dentry(br);
+	au_sbilist_lock();
 	au_br_do_add_brp(au_sbi(sb), bindex, br, bend, amount);
 	au_br_do_add_hdp(au_di(root), bindex, bend, amount);
 	au_br_do_add_hip(au_ii(root_inode), bindex, bend, amount);
 	au_set_h_dptr(root, bindex, dget(h_dentry));
 	au_set_h_iptr(root_inode, bindex, au_igrab(h_dentry->d_inode),
 		      /*flags*/0);
+	au_sbilist_unlock();
 }
 
 int au_br_add(struct super_block *sb, struct au_opt_add *add, int remount)
@@ -488,15 +525,15 @@
 	}
 
 	add_bindex = add->bindex;
-	h_dentry = add->path.dentry;
 	if (!remount)
-		au_br_do_add(sb, h_dentry, add_branch, add_bindex);
+		au_br_do_add(sb, add_branch, add_bindex);
 	else {
 		sysaufs_brs_del(sb, add_bindex);
-		au_br_do_add(sb, h_dentry, add_branch, add_bindex);
+		au_br_do_add(sb, add_branch, add_bindex);
 		sysaufs_brs_add(sb, add_bindex);
 	}
 
+	h_dentry = add->path.dentry;
 	if (!add_bindex) {
 		au_cpup_attr_all(root_inode, /*force*/1);
 		sb->s_maxbytes = h_dentry->d_sb->s_maxbytes;
@@ -631,7 +668,7 @@
 			continue;
 
 		/* AuDbgInode(i); */
-		if (au_iigen(i) == sigen)
+		if (au_iigen(i, NULL) == sigen)
 			ii_read_lock_child(i);
 		else {
 			ii_write_lock_child(i);
@@ -695,7 +732,7 @@
 	sbinfo->si_branch[0 + bend] = NULL;
 	sbinfo->si_bend--;
 
-	p = krealloc(sbinfo->si_branch, sizeof(*p) * bend, GFP_NOFS);
+	p = krealloc(sbinfo->si_branch, sizeof(*p) * bend, AuGFP_SBILIST);
 	if (p)
 		sbinfo->si_branch = p;
 	/* harmless error */
@@ -715,7 +752,7 @@
 	hdp[0 + bend].hd_dentry = NULL;
 	dinfo->di_bend--;
 
-	p = krealloc(hdp, sizeof(*p) * bend, GFP_NOFS);
+	p = krealloc(hdp, sizeof(*p) * bend, AuGFP_SBILIST);
 	if (p)
 		dinfo->di_hdentry = p;
 	/* harmless error */
@@ -735,7 +772,7 @@
 	au_hn_init(iinfo->ii_hinode + bend);
 	iinfo->ii_bend--;
 
-	p = krealloc(iinfo->ii_hinode, sizeof(*p) * bend, GFP_NOFS);
+	p = krealloc(iinfo->ii_hinode, sizeof(*p) * bend, AuGFP_SBILIST);
 	if (p)
 		iinfo->ii_hinode = p;
 	/* harmless error */
@@ -746,8 +783,9 @@
 {
 	aufs_bindex_t bend;
 	struct au_sbinfo *sbinfo;
-	struct dentry *root;
-	struct inode *inode;
+	struct dentry *root, *h_root;
+	struct inode *inode, *h_inode;
+	struct au_hinode *hinode;
 
 	SiMustWriteLock(sb);
 
@@ -756,13 +794,20 @@
 	sbinfo = au_sbi(sb);
 	bend = sbinfo->si_bend;
 
-	dput(au_h_dptr(root, bindex));
-	au_hiput(au_hi(inode, bindex));
-	au_br_do_free(br);
+	h_root = au_h_dptr(root, bindex);
+	hinode = au_hi(inode, bindex);
+	h_inode = au_igrab(hinode->hi_inode);
+	au_hiput(hinode);
 
+	au_sbilist_lock();
 	au_br_do_del_brp(sbinfo, bindex, bend);
 	au_br_do_del_hdp(au_di(root), bindex, bend);
 	au_br_do_del_hip(au_ii(inode), bindex, bend);
+	au_sbilist_unlock();
+
+	dput(h_root);
+	iput(h_inode);
+	au_br_do_free(br);
 }
 
 int au_br_del(struct super_block *sb, struct au_opt_del *del, int remount)
@@ -794,6 +839,7 @@
 		goto out;
 	}
 	br = au_sbr(sb, bindex);
+	AuDebugOn(!path_equal(&br->br_path, &del->h_path));
 	i = atomic_read(&br->br_count);
 	if (unlikely(i)) {
 		AuVerbose(verbose, "%d file(s) opened\n", i);
@@ -842,10 +888,10 @@
 
 out_wh:
 	/* revert */
-	rerr = au_br_init_wh(sb, br, br->br_perm, del->h_path.dentry);
+	rerr = au_br_init_wh(sb, br, br->br_perm);
 	if (rerr)
-		pr_warning("failed re-creating base whiteout, %s. (%d)\n",
-			   del->pathname, rerr);
+		pr_warn("failed re-creating base whiteout, %s. (%d)\n",
+			del->pathname, rerr);
 out:
 	return err;
 }
@@ -1079,7 +1125,6 @@
 {
 	int err, rerr;
 	aufs_bindex_t bindex;
-	struct path path;
 	struct dentry *root;
 	struct au_branch *br;
 
@@ -1099,12 +1144,13 @@
 		goto out;
 
 	br = au_sbr(sb, bindex);
+	AuDebugOn(mod->h_root != au_br_dentry(br));
 	if (br->br_perm == mod->perm)
 		return 0; /* success */
 
 	if (au_br_writable(br->br_perm)) {
 		/* remove whiteout base */
-		err = au_br_init_wh(sb, br, mod->perm, mod->h_root);
+		err = au_br_init_wh(sb, br, mod->perm);
 		if (unlikely(err))
 			goto out;
 
@@ -1121,12 +1167,8 @@
 				rerr = -ENOMEM;
 				br->br_wbr = kmalloc(sizeof(*br->br_wbr),
 						     GFP_NOFS);
-				if (br->br_wbr) {
-					path.mnt = br->br_mnt;
-					path.dentry = mod->h_root;
-					rerr = au_wbr_init(br, sb, br->br_perm,
-							   &path);
-				}
+				if (br->br_wbr)
+					rerr = au_wbr_init(br, sb, br->br_perm);
 				if (unlikely(rerr)) {
 					AuIOErr("nested error %d (%d)\n",
 						rerr, err);
@@ -1139,9 +1181,7 @@
 		err = -ENOMEM;
 		br->br_wbr = kmalloc(sizeof(*br->br_wbr), GFP_NOFS);
 		if (br->br_wbr) {
-			path.mnt = br->br_mnt;
-			path.dentry = mod->h_root;
-			err = au_wbr_init(br, sb, mod->perm, &path);
+			err = au_wbr_init(br, sb, mod->perm);
 			if (unlikely(err)) {
 				kfree(br->br_wbr);
 				br->br_wbr = NULL;
@@ -1150,6 +1190,12 @@
 	}
 
 	if (!err) {
+		if ((br->br_perm & AuBrAttr_UNPIN)
+		    && !(mod->perm & AuBrAttr_UNPIN))
+			au_br_dflags_force(br);
+		else if (!(br->br_perm & AuBrAttr_UNPIN)
+			 && (mod->perm & AuBrAttr_UNPIN))
+			au_br_dflags_restore(br);
 		*do_refresh |= need_sigen_inc(br->br_perm, mod->perm);
 		br->br_perm = mod->perm;
 	}
diff -ru --new-file linux-3.x-orig/fs/aufs/branch.h linux-3.x/fs/aufs/branch.h
--- linux-3.x-orig/fs/aufs/branch.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/branch.h	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,9 +25,7 @@
 
 #ifdef __KERNEL__
 
-#include <linux/fs.h>
 #include <linux/mount.h>
-#include <linux/aufs_type.h>
 #include "dynop.h"
 #include "rwsem.h"
 #include "super.h"
@@ -63,6 +61,18 @@
 /* ext2 has 3 types of operations at least, ext3 has 4 */
 #define AuBrDynOp (AuDyLast * 4)
 
+/* sysfs entries */
+struct au_brsysfs {
+	char			name[16];
+	struct attribute	attr;
+};
+
+enum {
+	AuBrSysfs_BR,
+	AuBrSysfs_BRID,
+	AuBrSysfs_Last
+};
+
 /* protected by superblock rwsem */
 struct au_branch {
 	struct au_xino_file	br_xino;
@@ -70,7 +80,8 @@
 	aufs_bindex_t		br_id;
 
 	int			br_perm;
-	struct vfsmount		*br_mnt;
+	unsigned int		br_dflags;
+	struct path		br_path;
 	spinlock_t		br_dykey_lock;
 	struct au_dykey		*br_dykey[AuBrDynOp];
 	atomic_t		br_count;
@@ -78,7 +89,6 @@
 	struct au_wbr		*br_wbr;
 
 	/* xino truncation */
-	blkcnt_t		br_xino_upper;	/* watermark in blocks */
 	atomic_t		br_xino_running;
 
 #ifdef CONFIG_AUFS_HFSNOTIFY
@@ -87,43 +97,59 @@
 #endif
 
 #ifdef CONFIG_SYSFS
-	/* an entry under sysfs per mount-point */
-	char			br_name[8];
-	struct attribute	br_attr;
+	/* entries under sysfs per mount-point */
+	struct au_brsysfs	br_sysfs[AuBrSysfs_Last];
 #endif
 };
 
 /* ---------------------------------------------------------------------- */
 
-/* branch permission and attribute */
-enum {
-	AuBrPerm_RW,		/* writable, linkable wh */
-	AuBrPerm_RO,		/* readonly, no wh */
-	AuBrPerm_RR,		/* natively readonly, no wh */
+static inline struct vfsmount *au_br_mnt(struct au_branch *br)
+{
+	return br->br_path.mnt;
+}
 
-	AuBrPerm_RWNoLinkWH,	/* un-linkable whiteouts */
+static inline struct dentry *au_br_dentry(struct au_branch *br)
+{
+	return br->br_path.dentry;
+}
 
-	AuBrPerm_ROWH,		/* whiteout-able */
-	AuBrPerm_RRWH,		/* whiteout-able */
+static inline struct super_block *au_br_sb(struct au_branch *br)
+{
+	return au_br_mnt(br)->mnt_sb;
+}
 
-	AuBrPerm_Last
-};
+/* branch permissions and attributes */
+#define AuBrPerm_RW		1		/* writable, hardlinkable wh */
+#define AuBrPerm_RO		(1 << 1)	/* readonly */
+#define AuBrPerm_RR		(1 << 2)	/* natively readonly */
+#define AuBrPerm_Mask		(AuBrPerm_RW | AuBrPerm_RO | AuBrPerm_RR)
+
+#define AuBrRAttr_WH		(1 << 3)	/* whiteout-able */
+
+#define AuBrWAttr_NoLinkWH	(1 << 4)	/* un-hardlinkable whiteouts */
+
+#define AuBrAttr_UNPIN		(1 << 5)	/* rename-able top dir of
+						   branch */
 
 static inline int au_br_writable(int brperm)
 {
-	return brperm == AuBrPerm_RW || brperm == AuBrPerm_RWNoLinkWH;
+	return brperm & AuBrPerm_RW;
 }
 
 static inline int au_br_whable(int brperm)
 {
-	return brperm == AuBrPerm_RW
-		|| brperm == AuBrPerm_ROWH
-		|| brperm == AuBrPerm_RRWH;
+	return brperm & (AuBrPerm_RW | AuBrRAttr_WH);
+}
+
+static inline int au_br_wh_linkable(int brperm)
+{
+	return !(brperm & AuBrWAttr_NoLinkWH);
 }
 
 static inline int au_br_rdonly(struct au_branch *br)
 {
-	return ((br->br_mnt->mnt_sb->s_flags & MS_RDONLY)
+	return ((au_br_sb(br)->s_flags & MS_RDONLY)
 		|| !au_br_writable(br->br_perm))
 		? -EROFS : 0;
 }
@@ -131,7 +157,7 @@
 static inline int au_br_hnotifyable(int brperm __maybe_unused)
 {
 #ifdef CONFIG_AUFS_HNOTIFY
-	return brperm != AuBrPerm_RR && brperm != AuBrPerm_RRWH;
+	return !(brperm & AuBrPerm_RR);
 #else
 	return 0;
 #endif
@@ -193,13 +219,13 @@
 static inline
 struct vfsmount *au_sbr_mnt(struct super_block *sb, aufs_bindex_t bindex)
 {
-	return au_sbr(sb, bindex)->br_mnt;
+	return au_br_mnt(au_sbr(sb, bindex));
 }
 
 static inline
 struct super_block *au_sbr_sb(struct super_block *sb, aufs_bindex_t bindex)
 {
-	return au_sbr_mnt(sb, bindex)->mnt_sb;
+	return au_br_sb(au_sbr(sb, bindex));
 }
 
 static inline void au_sbr_put(struct super_block *sb, aufs_bindex_t bindex)
diff -ru --new-file linux-3.x-orig/fs/aufs/conf.mk linux-3.x/fs/aufs/conf.mk
--- linux-3.x-orig/fs/aufs/conf.mk	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.x/fs/aufs/conf.mk	2014-12-23 17:23:09.031087000 +0000
@@ -0,0 +1,37 @@
+
+AuConfStr = CONFIG_AUFS_FS=${CONFIG_AUFS_FS}
+
+define AuConf
+ifdef ${1}
+AuConfStr += ${1}=${${1}}
+endif
+endef
+
+AuConfAll = BRANCH_MAX_127 BRANCH_MAX_511 BRANCH_MAX_1023 BRANCH_MAX_32767 \
+	SBILIST \
+	HNOTIFY HFSNOTIFY \
+	EXPORT INO_T_64 \
+	RDU \
+	SP_IATTR \
+	SHWH \
+	BR_RAMFS \
+	BR_FUSE POLL \
+	BR_HFSPLUS \
+	BDEV_LOOP \
+	DEBUG MAGIC_SYSRQ
+$(foreach i, ${AuConfAll}, \
+	$(eval $(call AuConf,CONFIG_AUFS_${i})))
+
+AuConfName = ${obj}/conf.str
+${AuConfName}.tmp: FORCE
+	@echo ${AuConfStr} | tr ' ' '\n' | sed -e 's/^/"/' -e 's/$$/\\n"/' > $@
+${AuConfName}: ${AuConfName}.tmp
+	@diff -q $< $@ > /dev/null 2>&1 || { \
+	echo '  GEN    ' $@; \
+	cp -p $< $@; \
+	}
+FORCE:
+clean-files += ${AuConfName} ${AuConfName}.tmp
+${obj}/sysfs.o: ${AuConfName}
+
+-include ${srctree}/${src}/conf_priv.mk
diff -ru --new-file linux-3.x-orig/fs/aufs/cpup.c linux-3.x/fs/aufs/cpup.c
--- linux-3.x-orig/fs/aufs/cpup.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/cpup.c	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,18 +20,18 @@
  * copy-up functions, see wbr_policy.c for copy-down
  */
 
-#include <linux/file.h>
 #include <linux/fs_stack.h>
 #include <linux/mm.h>
-#include <linux/uaccess.h>
 #include "aufs.h"
 
-void au_cpup_attr_flags(struct inode *dst, struct inode *src)
+void au_cpup_attr_flags(struct inode *dst, unsigned int iflags)
 {
 	const unsigned int mask = S_DEAD | S_SWAPFILE | S_PRIVATE
-		| S_NOATIME | S_NOCMTIME;
+		| S_NOATIME | S_NOCMTIME | S_AUTOMOUNT;
 
-	dst->i_flags |= src->i_flags & ~mask;
+	BUILD_BUG_ON(sizeof(iflags) != sizeof(dst->i_flags));
+
+	dst->i_flags |= iflags & ~mask;
 	if (au_test_fs_notime(dst->i_sb))
 		dst->i_flags |= S_NOATIME | S_NOCMTIME;
 }
@@ -60,7 +60,7 @@
 	    && au_plink_test(inode))
 		return;
 
-	inode->i_nlink = h_inode->i_nlink;
+	set_nlink(inode, h_inode->i_nlink);
 
 	/*
 	 * fewer nlink makes find(1) noisy, but larger nlink doesn't.
@@ -85,7 +85,7 @@
 	inode->i_uid = h_inode->i_uid;
 	inode->i_gid = h_inode->i_gid;
 	au_cpup_attr_timesizes(inode);
-	au_cpup_attr_flags(inode, h_inode);
+	au_cpup_attr_flags(inode, h_inode->i_flags);
 }
 
 void au_cpup_igen(struct inode *inode, struct inode *h_inode)
@@ -141,18 +141,27 @@
 
 	err = vfsub_notify_change(&dt->dt_h_path, &attr);
 	if (unlikely(err))
-		pr_warning("restoring timestamps failed(%d). ignored\n", err);
+		pr_warn("restoring timestamps failed(%d). ignored\n", err);
 }
 
 /* ---------------------------------------------------------------------- */
 
+/* internal use only */
+struct au_cpup_reg_attr {
+	int		valid;
+	struct kstat	st;
+	unsigned int	iflags; /* inode->i_flags */
+};
+
 static noinline_for_stack
-int cpup_iattr(struct dentry *dst, aufs_bindex_t bindex, struct dentry *h_src)
+int cpup_iattr(struct dentry *dst, aufs_bindex_t bindex, struct dentry *h_src,
+	       struct au_cpup_reg_attr *h_src_attr)
 {
 	int err, sbits;
 	struct iattr ia;
 	struct path h_path;
 	struct inode *h_isrc, *h_idst;
+	struct kstat *h_st;
 
 	h_path.dentry = au_h_dptr(dst, bindex);
 	h_idst = h_path.dentry->d_inode;
@@ -161,17 +170,32 @@
 	ia.ia_valid = ATTR_FORCE | ATTR_UID | ATTR_GID
 		| ATTR_ATIME | ATTR_MTIME
 		| ATTR_ATIME_SET | ATTR_MTIME_SET;
-	ia.ia_uid = h_isrc->i_uid;
-	ia.ia_gid = h_isrc->i_gid;
-	ia.ia_atime = h_isrc->i_atime;
-	ia.ia_mtime = h_isrc->i_mtime;
-	if (h_idst->i_mode != h_isrc->i_mode
-	    && !S_ISLNK(h_idst->i_mode)) {
-		ia.ia_valid |= ATTR_MODE;
-		ia.ia_mode = h_isrc->i_mode;
+	if (h_src_attr && h_src_attr->valid) {
+		h_st = &h_src_attr->st;
+		ia.ia_uid = h_st->uid;
+		ia.ia_gid = h_st->gid;
+		ia.ia_atime = h_st->atime;
+		ia.ia_mtime = h_st->mtime;
+		if (h_idst->i_mode != h_st->mode
+		    && !S_ISLNK(h_idst->i_mode)) {
+			ia.ia_valid |= ATTR_MODE;
+			ia.ia_mode = h_st->mode;
+		}
+		sbits = !!(h_st->mode & (S_ISUID | S_ISGID));
+		au_cpup_attr_flags(h_idst, h_src_attr->iflags);
+	} else {
+		ia.ia_uid = h_isrc->i_uid;
+		ia.ia_gid = h_isrc->i_gid;
+		ia.ia_atime = h_isrc->i_atime;
+		ia.ia_mtime = h_isrc->i_mtime;
+		if (h_idst->i_mode != h_isrc->i_mode
+		    && !S_ISLNK(h_idst->i_mode)) {
+			ia.ia_valid |= ATTR_MODE;
+			ia.ia_mode = h_isrc->i_mode;
+		}
+		sbits = !!(h_isrc->i_mode & (S_ISUID | S_ISGID));
+		au_cpup_attr_flags(h_idst, h_isrc->i_flags);
 	}
-	sbits = !!(h_isrc->i_mode & (S_ISUID | S_ISGID));
-	au_cpup_attr_flags(h_idst, h_isrc);
 	err = vfsub_notify_change(&h_path, &ia);
 
 	/* is this nfs only? */
@@ -237,6 +261,8 @@
 				wbytes -= b;
 				p += b;
 			}
+			if (unlikely(err < 0))
+				break;
 		} else {
 			loff_t res;
 
@@ -320,8 +346,7 @@
  * to support a sparse file which is opened with O_APPEND,
  * we need to close the file.
  */
-static int au_cp_regular(struct dentry *dentry, aufs_bindex_t bdst,
-			 aufs_bindex_t bsrc, loff_t len)
+static int au_cp_regular(struct au_cp_generic *cpg)
 {
 	int err, i;
 	enum { SRC, DST };
@@ -333,14 +358,14 @@
 		void *label, *label_file;
 	} *f, file[] = {
 		{
-			.bindex = bsrc,
+			.bindex = cpg->bsrc,
 			.flags = O_RDONLY | O_NOATIME | O_LARGEFILE,
 			.file = NULL,
 			.label = &&out,
 			.label_file = &&out_src
 		},
 		{
-			.bindex = bdst,
+			.bindex = cpg->bdst,
 			.flags = O_WRONLY | O_NOATIME | O_LARGEFILE,
 			.file = NULL,
 			.label = &&out_src,
@@ -350,11 +375,12 @@
 	struct super_block *sb;
 
 	/* bsrc branch can be ro/rw. */
-	sb = dentry->d_sb;
+	sb = cpg->dentry->d_sb;
 	f = file;
 	for (i = 0; i < 2; i++, f++) {
-		f->dentry = au_h_dptr(dentry, f->bindex);
-		f->file = au_h_open(dentry, f->bindex, f->flags, /*file*/NULL);
+		f->dentry = au_h_dptr(cpg->dentry, f->bindex);
+		f->file = au_h_open(cpg->dentry, f->bindex, f->flags,
+				    /*file*/NULL);
 		err = PTR_ERR(f->file);
 		if (IS_ERR(f->file))
 			goto *f->label;
@@ -365,7 +391,7 @@
 
 	/* try stopping to update while we copyup */
 	IMustLock(file[SRC].dentry->d_inode);
-	err = au_copy_file(file[DST].file, file[SRC].file, len);
+	err = au_copy_file(file[DST].file, file[SRC].file, cpg->len);
 
 out_dst:
 	fput(file[DST].file);
@@ -377,27 +403,39 @@
 	return err;
 }
 
-static int au_do_cpup_regular(struct dentry *dentry, aufs_bindex_t bdst,
-			      aufs_bindex_t bsrc, loff_t len,
-			      struct inode *h_dir, struct path *h_path)
+static int au_do_cpup_regular(struct au_cp_generic *cpg,
+			      struct au_cpup_reg_attr *h_src_attr)
 {
 	int err, rerr;
 	loff_t l;
+	struct dentry *h_src_dentry;
+	struct inode *h_src_inode;
+	struct vfsmount *h_src_mnt;
 
 	err = 0;
-	l = i_size_read(au_h_iptr(dentry->d_inode, bsrc));
-	if (len == -1 || l < len)
-		len = l;
-	if (len)
-		err = au_cp_regular(dentry, bdst, bsrc, len);
-	if (!err)
-		goto out; /* success */
+	h_src_inode = au_h_iptr(cpg->dentry->d_inode, cpg->bsrc);
+	l = i_size_read(h_src_inode);
+	if (cpg->len == -1 || l < cpg->len)
+		cpg->len = l;
+	if (cpg->len) {
+		/* try stopping to update while we are referencing */
+		mutex_lock_nested(&h_src_inode->i_mutex, AuLsc_I_CHILD);
+		au_pin_hdir_unlock(cpg->pin);
 
-	rerr = vfsub_unlink(h_dir, h_path, /*force*/0);
-	if (rerr) {
-		AuIOErr("failed unlinking cpup-ed %.*s(%d, %d)\n",
-			AuDLNPair(h_path->dentry), err, rerr);
-		err = -EIO;
+		h_src_dentry = au_h_dptr(cpg->dentry, cpg->bsrc);
+		h_src_mnt = au_sbr_mnt(cpg->dentry->d_sb, cpg->bsrc);
+		h_src_attr->iflags = h_src_inode->i_flags;
+		err = vfs_getattr(h_src_mnt, h_src_dentry, &h_src_attr->st);
+		if (unlikely(err)) {
+			mutex_unlock(&h_src_inode->i_mutex);
+			goto out;
+		}
+		h_src_attr->valid = 1;
+		err = au_cp_regular(cpg);
+		mutex_unlock(&h_src_inode->i_mutex);
+		rerr = au_pin_hdir_relock(cpg->pin);
+		if (!err && rerr)
+			err = rerr;
 	}
 
 out:
@@ -423,6 +461,7 @@
 	if (unlikely(!sym.k))
 		goto out;
 
+	/* unnecessary to support mmap_sem since symlink is not mmap-able */
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
 	symlen = h_src->d_inode->i_op->readlink(h_src, sym.u, PATH_MAX);
@@ -439,17 +478,15 @@
 	return err;
 }
 
-/* return with the lower dst inode is locked */
 static noinline_for_stack
-int cpup_entry(struct dentry *dentry, aufs_bindex_t bdst,
-	       aufs_bindex_t bsrc, loff_t len, unsigned int flags,
-	       struct dentry *dst_parent)
+int cpup_entry(struct au_cp_generic *cpg, struct dentry *dst_parent,
+	       struct au_cpup_reg_attr *h_src_attr)
 {
 	int err;
 	umode_t mode;
 	unsigned int mnt_flags;
 	unsigned char isdir;
-	const unsigned char do_dt = !!au_ftest_cpup(flags, DTIME);
+	const unsigned char do_dt = !!au_ftest_cpup(cpg->flags, DTIME);
 	struct au_dtime dt;
 	struct path h_path;
 	struct dentry *h_src, *h_dst, *h_parent;
@@ -457,19 +494,22 @@
 	struct super_block *sb;
 
 	/* bsrc branch can be ro/rw. */
-	h_src = au_h_dptr(dentry, bsrc);
+	h_src = au_h_dptr(cpg->dentry, cpg->bsrc);
 	h_inode = h_src->d_inode;
-	AuDebugOn(h_inode != au_h_iptr(dentry->d_inode, bsrc));
+	AuDebugOn(h_inode != au_h_iptr(cpg->dentry->d_inode, cpg->bsrc));
 
 	/* try stopping to be referenced while we are creating */
-	h_dst = au_h_dptr(dentry, bdst);
+	h_dst = au_h_dptr(cpg->dentry, cpg->bdst);
+	if (au_ftest_cpup(cpg->flags, RENAME))
+		AuDebugOn(strncmp(h_dst->d_name.name, AUFS_WH_PFX,
+				  AUFS_WH_PFX_LEN));
 	h_parent = h_dst->d_parent; /* dir inode is locked */
 	h_dir = h_parent->d_inode;
 	IMustLock(h_dir);
 	AuDebugOn(h_parent != h_dst->d_parent);
 
-	sb = dentry->d_sb;
-	h_path.mnt = au_sbr_mnt(sb, bdst);
+	sb = cpg->dentry->d_sb;
+	h_path.mnt = au_sbr_mnt(sb, cpg->bdst);
 	if (do_dt) {
 		h_path.dentry = h_parent;
 		au_dtime_store(&dt, dst_parent, &h_path);
@@ -480,13 +520,9 @@
 	mode = h_inode->i_mode;
 	switch (mode & S_IFMT) {
 	case S_IFREG:
-		/* try stopping to update while we are referencing */
-		IMustLock(h_inode);
 		err = vfsub_create(h_dir, &h_path, mode | S_IWUSR);
 		if (!err)
-			err = au_do_cpup_regular
-				(dentry, bdst, bsrc, len,
-				 au_h_iptr(dst_parent->d_inode, bdst), &h_path);
+			err = au_do_cpup_regular(cpg, h_src_attr);
 		break;
 	case S_IFDIR:
 		isdir = 1;
@@ -496,10 +532,10 @@
 			 * strange behaviour from the users view,
 			 * particularry setattr case
 			 */
-			if (au_ibstart(dst_parent->d_inode) == bdst)
+			if (au_ibstart(dst_parent->d_inode) == cpg->bdst)
 				au_cpup_attr_nlink(dst_parent->d_inode,
 						   /*force*/1);
-			au_cpup_attr_nlink(dentry->d_inode, /*force*/1);
+			au_cpup_attr_nlink(cpg->dentry->d_inode, /*force*/1);
 		}
 		break;
 	case S_IFLNK:
@@ -524,10 +560,10 @@
 	    && au_opt_test(mnt_flags, XINO)
 	    && h_inode->i_nlink == 1
 	    /* todo: unnecessary? */
-	    /* && dentry->d_inode->i_nlink == 1 */
-	    && bdst < bsrc
-	    && !au_ftest_cpup(flags, KEEPLINO))
-		au_xino_write(sb, bsrc, h_inode->i_ino, /*ino*/0);
+	    /* && cpg->dentry->d_inode->i_nlink == 1 */
+	    && cpg->bdst < cpg->bsrc
+	    && !au_ftest_cpup(cpg->flags, KEEPLINO))
+		au_xino_write(sb, cpg->bsrc, h_inode->i_ino, /*ino*/0);
 		/* ignore this error */
 
 	if (do_dt)
@@ -535,172 +571,271 @@
 	return err;
 }
 
+static int au_do_ren_after_cpup(struct dentry *dentry, aufs_bindex_t bdst,
+				struct path *h_path)
+{
+	int err;
+	struct dentry *h_dentry, *h_parent;
+	struct inode *h_dir;
+
+	h_dentry = dget(au_h_dptr(dentry, bdst));
+	au_set_h_dptr(dentry, bdst, NULL);
+	err = au_lkup_neg(dentry, bdst, /*wh*/0);
+	if (unlikely(err)) {
+		au_set_h_dptr(dentry, bdst, h_dentry);
+		goto out;
+	}
+
+	h_path->dentry = dget(au_h_dptr(dentry, bdst));
+	au_set_h_dptr(dentry, bdst, h_dentry);
+	h_parent = h_dentry->d_parent; /* dir inode is locked */
+	h_dir = h_parent->d_inode;
+	IMustLock(h_dir);
+	AuDbg("%.*s %.*s\n", AuDLNPair(h_dentry), AuDLNPair(h_path->dentry));
+	err = vfsub_rename(h_dir, h_dentry, h_dir, h_path);
+	dput(h_path->dentry);
+
+out:
+	return err;
+}
+
 /*
  * copyup the @dentry from @bsrc to @bdst.
  * the caller must set the both of lower dentries.
  * @len is for truncating when it is -1 copyup the entire file.
  * in link/rename cases, @dst_parent may be different from the real one.
  */
-static int au_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
-			  aufs_bindex_t bsrc, loff_t len, unsigned int flags,
-			  struct dentry *dst_parent)
+static int au_cpup_single(struct au_cp_generic *cpg, struct dentry *dst_parent)
 {
 	int err, rerr;
 	aufs_bindex_t old_ibstart;
 	unsigned char isdir, plink;
-	struct au_dtime dt;
-	struct path h_path;
 	struct dentry *h_src, *h_dst, *h_parent;
 	struct inode *dst_inode, *h_dir, *inode;
 	struct super_block *sb;
+	struct au_branch *br;
+	/* to reuduce stack size */
+	struct {
+		struct au_dtime dt;
+		struct path h_path;
+		struct au_cpup_reg_attr h_src_attr;
+	} *a;
+
+	AuDebugOn(cpg->bsrc <= cpg->bdst);
 
-	AuDebugOn(bsrc <= bdst);
+	err = -ENOMEM;
+	a = kmalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+	a->h_src_attr.valid = 0;
 
-	sb = dentry->d_sb;
-	h_path.mnt = au_sbr_mnt(sb, bdst);
-	h_dst = au_h_dptr(dentry, bdst);
+	sb = cpg->dentry->d_sb;
+	br = au_sbr(sb, cpg->bdst);
+	a->h_path.mnt = au_br_mnt(br);
+	h_dst = au_h_dptr(cpg->dentry, cpg->bdst);
 	h_parent = h_dst->d_parent; /* dir inode is locked */
 	h_dir = h_parent->d_inode;
 	IMustLock(h_dir);
 
-	h_src = au_h_dptr(dentry, bsrc);
-	inode = dentry->d_inode;
+	h_src = au_h_dptr(cpg->dentry, cpg->bsrc);
+	inode = cpg->dentry->d_inode;
 
 	if (!dst_parent)
-		dst_parent = dget_parent(dentry);
+		dst_parent = dget_parent(cpg->dentry);
 	else
 		dget(dst_parent);
 
 	plink = !!au_opt_test(au_mntflags(sb), PLINK);
-	dst_inode = au_h_iptr(inode, bdst);
+	dst_inode = au_h_iptr(inode, cpg->bdst);
 	if (dst_inode) {
 		if (unlikely(!plink)) {
 			err = -EIO;
 			AuIOErr("hi%lu(i%lu) exists on b%d "
 				"but plink is disabled\n",
-				dst_inode->i_ino, inode->i_ino, bdst);
-			goto out;
+				dst_inode->i_ino, inode->i_ino, cpg->bdst);
+			goto out_parent;
 		}
 
 		if (dst_inode->i_nlink) {
-			const int do_dt = au_ftest_cpup(flags, DTIME);
+			const int do_dt = au_ftest_cpup(cpg->flags, DTIME);
 
-			h_src = au_plink_lkup(inode, bdst);
+			h_src = au_plink_lkup(inode, cpg->bdst);
 			err = PTR_ERR(h_src);
 			if (IS_ERR(h_src))
-				goto out;
+				goto out_parent;
 			if (unlikely(!h_src->d_inode)) {
 				err = -EIO;
 				AuIOErr("i%lu exists on a upper branch "
 					"but not pseudo-linked\n",
 					inode->i_ino);
 				dput(h_src);
-				goto out;
+				goto out_parent;
 			}
 
 			if (do_dt) {
-				h_path.dentry = h_parent;
-				au_dtime_store(&dt, dst_parent, &h_path);
+				a->h_path.dentry = h_parent;
+				au_dtime_store(&a->dt, dst_parent, &a->h_path);
 			}
-			h_path.dentry = h_dst;
-			err = vfsub_link(h_src, h_dir, &h_path);
+
+			a->h_path.dentry = h_dst;
+			err = vfsub_link(h_src, h_dir, &a->h_path);
+			if (!err && au_ftest_cpup(cpg->flags, RENAME))
+				err = au_do_ren_after_cpup
+					(cpg->dentry, cpg->bdst, &a->h_path);
 			if (do_dt)
-				au_dtime_revert(&dt);
+				au_dtime_revert(&a->dt);
 			dput(h_src);
-			goto out;
+			goto out_parent;
 		} else
 			/* todo: cpup_wh_file? */
 			/* udba work */
 			au_update_ibrange(inode, /*do_put_zero*/1);
 	}
 
+	isdir = S_ISDIR(inode->i_mode);
 	old_ibstart = au_ibstart(inode);
-	err = cpup_entry(dentry, bdst, bsrc, len, flags, dst_parent);
+	err = cpup_entry(cpg, dst_parent, &a->h_src_attr);
 	if (unlikely(err))
-		goto out;
+		goto out_rev;
 	dst_inode = h_dst->d_inode;
 	mutex_lock_nested(&dst_inode->i_mutex, AuLsc_I_CHILD2);
+	/* todo: necessary? */
+	/* au_pin_hdir_unlock(cpg->pin); */
 
-	err = cpup_iattr(dentry, bdst, h_src);
-	isdir = S_ISDIR(dst_inode->i_mode);
-	if (!err) {
-		if (bdst < old_ibstart) {
-			if (S_ISREG(inode->i_mode)) {
-				err = au_dy_iaop(inode, bdst, dst_inode);
-				if (unlikely(err))
-					goto out_rev;
+	err = cpup_iattr(cpg->dentry, cpg->bdst, h_src, &a->h_src_attr);
+	if (unlikely(err)) {
+		/* todo: necessary? */
+		/* au_pin_hdir_relock(cpg->pin); */ /* ignore an error */
+		mutex_unlock(&dst_inode->i_mutex);
+		goto out_rev;
+	}
+
+	if (cpg->bdst < old_ibstart) {
+		if (S_ISREG(inode->i_mode)) {
+			err = au_dy_iaop(inode, cpg->bdst, dst_inode);
+			if (unlikely(err)) {
+				/* ignore an error */
+				/* au_pin_hdir_relock(cpg->pin); */
+				mutex_unlock(&dst_inode->i_mutex);
+				goto out_rev;
 			}
-			au_set_ibstart(inode, bdst);
 		}
-		au_set_h_iptr(inode, bdst, au_igrab(dst_inode),
-			      au_hi_flags(inode, isdir));
-		mutex_unlock(&dst_inode->i_mutex);
-		if (!isdir
-		    && h_src->d_inode->i_nlink > 1
-		    && plink)
-			au_plink_append(inode, bdst, h_dst);
-		goto out; /* success */
+		au_set_ibstart(inode, cpg->bdst);
+	}
+	au_set_h_iptr(inode, cpg->bdst, au_igrab(dst_inode),
+		      au_hi_flags(inode, isdir));
+
+	/* todo: necessary? */
+	/* err = au_pin_hdir_relock(cpg->pin); */
+	mutex_unlock(&dst_inode->i_mutex);
+	if (unlikely(err))
+		goto out_rev;
+
+	if (!isdir
+	    && h_src->d_inode->i_nlink > 1
+	    && plink)
+		au_plink_append(inode, cpg->bdst, h_dst);
+
+	if (au_ftest_cpup(cpg->flags, RENAME)) {
+		a->h_path.dentry = h_dst;
+		err = au_do_ren_after_cpup(cpg->dentry, cpg->bdst, &a->h_path);
 	}
+	if (!err)
+		goto out_parent; /* success */
 
 	/* revert */
 out_rev:
-	h_path.dentry = h_parent;
-	mutex_unlock(&dst_inode->i_mutex);
-	au_dtime_store(&dt, dst_parent, &h_path);
-	h_path.dentry = h_dst;
-	if (!isdir)
-		rerr = vfsub_unlink(h_dir, &h_path, /*force*/0);
-	else
-		rerr = vfsub_rmdir(h_dir, &h_path);
-	au_dtime_revert(&dt);
+	a->h_path.dentry = h_parent;
+	au_dtime_store(&a->dt, dst_parent, &a->h_path);
+	a->h_path.dentry = h_dst;
+	rerr = 0;
+	if (h_dst->d_inode) {
+		if (!isdir)
+			rerr = vfsub_unlink(h_dir, &a->h_path, /*force*/0);
+		else
+			rerr = vfsub_rmdir(h_dir, &a->h_path);
+	}
+	au_dtime_revert(&a->dt);
 	if (rerr) {
 		AuIOErr("failed removing broken entry(%d, %d)\n", err, rerr);
 		err = -EIO;
 	}
-
-out:
+out_parent:
 	dput(dst_parent);
+	kfree(a);
+out:
 	return err;
 }
 
+#if 0 /* unused */
 struct au_cpup_single_args {
 	int *errp;
-	struct dentry *dentry;
-	aufs_bindex_t bdst, bsrc;
-	loff_t len;
-	unsigned int flags;
+	struct au_cp_generic *cpg;
 	struct dentry *dst_parent;
 };
 
 static void au_call_cpup_single(void *args)
 {
 	struct au_cpup_single_args *a = args;
-	*a->errp = au_cpup_single(a->dentry, a->bdst, a->bsrc, a->len,
-				  a->flags, a->dst_parent);
+
+	au_pin_hdir_acquire_nest(a->cpg->pin);
+	*a->errp = au_cpup_single(a->cpg, a->dst_parent);
+	au_pin_hdir_release(a->cpg->pin);
+}
+#endif
+
+/*
+ * prevent SIGXFSZ in copy-up.
+ * testing CAP_MKNOD is for generic fs,
+ * but CAP_FSETID is for xfs only, currently.
+ */
+static int au_cpup_sio_test(struct au_pin *pin, umode_t mode)
+{
+	int do_sio;
+	struct super_block *sb;
+	struct inode *h_dir;
+
+	do_sio = 0;
+	sb = au_pinned_parent(pin)->d_sb;
+	if (!au_wkq_test()
+	    && (!au_sbi(sb)->si_plink_maint_pid
+		|| au_plink_maint(sb, AuLock_NOPLM))) {
+		switch (mode & S_IFMT) {
+		case S_IFREG:
+			/* no condition about RLIMIT_FSIZE and the file size */
+			do_sio = 1;
+			break;
+		case S_IFCHR:
+		case S_IFBLK:
+			do_sio = !capable(CAP_MKNOD);
+			break;
+		}
+		if (!do_sio)
+			do_sio = ((mode & (S_ISUID | S_ISGID))
+				  && !capable(CAP_FSETID));
+		/* this workaround may be removed in the future */
+		if (!do_sio) {
+			h_dir = au_pinned_h_dir(pin);
+			do_sio = h_dir->i_mode & S_ISVTX;
+		}
+	}
+
+	return do_sio;
 }
 
-int au_sio_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
-		       aufs_bindex_t bsrc, loff_t len, unsigned int flags,
-		       struct dentry *dst_parent)
+#if 0 /* unused */
+int au_sio_cpup_single(struct au_cp_generic *cpg, struct dentry *dst_parent)
 {
 	int err, wkq_err;
-	umode_t mode;
 	struct dentry *h_dentry;
 
-	h_dentry = au_h_dptr(dentry, bsrc);
-	mode = h_dentry->d_inode->i_mode & S_IFMT;
-	if ((mode != S_IFCHR && mode != S_IFBLK)
-	    || capable(CAP_MKNOD))
-		err = au_cpup_single(dentry, bdst, bsrc, len, flags,
-				     dst_parent);
+	h_dentry = au_h_dptr(cpg->dentry, cpg->bsrc);
+	if (!au_cpup_sio_test(pin, h_dentry->d_inode->i_mode))
+		err = au_cpup_single(cpg, dst_parent);
 	else {
 		struct au_cpup_single_args args = {
 			.errp		= &err,
-			.dentry		= dentry,
-			.bdst		= bdst,
-			.bsrc		= bsrc,
-			.len		= len,
-			.flags		= flags,
+			.cpg		= cpg,
 			.dst_parent	= dst_parent
 		};
 		wkq_err = au_wkq_wait(au_call_cpup_single, &args);
@@ -710,31 +845,47 @@
 
 	return err;
 }
+#endif
 
 /*
  * copyup the @dentry from the first active lower branch to @bdst,
  * using au_cpup_single().
  */
-static int au_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-			  unsigned int flags)
+static int au_cpup_simple(struct au_cp_generic *cpg)
 {
 	int err;
+	unsigned int flags_orig;
 	aufs_bindex_t bsrc, bend;
+	struct dentry *dentry, *h_dentry;
+
+	dentry = cpg->dentry;
+	DiMustWriteLock(dentry);
 
 	bend = au_dbend(dentry);
-	for (bsrc = bdst + 1; bsrc <= bend; bsrc++)
-		if (au_h_dptr(dentry, bsrc))
-			break;
+	if (cpg->bsrc < 0) {
+		for (bsrc = cpg->bdst + 1; bsrc <= bend; bsrc++) {
+			h_dentry = au_h_dptr(dentry, bsrc);
+			if (h_dentry) {
+				AuDebugOn(!h_dentry->d_inode);
+				break;
+			}
+		}
+		AuDebugOn(bsrc > bend);
+		cpg->bsrc = bsrc;
+	}
 
-	err = au_lkup_neg(dentry, bdst);
+	err = au_lkup_neg(dentry, cpg->bdst, /*wh*/1);
 	if (!err) {
-		err = au_cpup_single(dentry, bdst, bsrc, len, flags, NULL);
+		flags_orig = cpg->flags;
+		au_fset_cpup(cpg->flags, RENAME);
+		err = au_cpup_single(cpg, NULL);
+		cpg->flags = flags_orig;
 		if (!err)
 			return 0; /* success */
 
 		/* revert */
-		au_set_h_dptr(dentry, bdst, NULL);
-		au_set_dbstart(dentry, bsrc);
+		au_set_h_dptr(dentry, cpg->bdst, NULL);
+		au_set_dbstart(dentry, cpg->bsrc);
 	}
 
 	return err;
@@ -742,49 +893,44 @@
 
 struct au_cpup_simple_args {
 	int *errp;
-	struct dentry *dentry;
-	aufs_bindex_t bdst;
-	loff_t len;
-	unsigned int flags;
+	struct au_cp_generic *cpg;
 };
 
 static void au_call_cpup_simple(void *args)
 {
 	struct au_cpup_simple_args *a = args;
-	*a->errp = au_cpup_simple(a->dentry, a->bdst, a->len, a->flags);
+
+	au_pin_hdir_acquire_nest(a->cpg->pin);
+	*a->errp = au_cpup_simple(a->cpg);
+	au_pin_hdir_release(a->cpg->pin);
 }
 
-int au_sio_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-		       unsigned int flags)
+int au_sio_cpup_simple(struct au_cp_generic *cpg)
 {
 	int err, wkq_err;
-	unsigned char do_sio;
-	struct dentry *parent;
+	struct dentry *dentry, *parent;
+	struct file *h_file;
 	struct inode *h_dir;
 
-	parent = dget_parent(dentry);
-	h_dir = au_h_iptr(parent->d_inode, bdst);
-	do_sio = !!au_test_h_perm_sio(h_dir, MAY_EXEC | MAY_WRITE);
-	if (!do_sio) {
-		/*
-		 * testing CAP_MKNOD is for generic fs,
-		 * but CAP_FSETID is for xfs only, currently.
-		 */
-		umode_t mode = dentry->d_inode->i_mode;
-		do_sio = (((mode & (S_IFCHR | S_IFBLK))
-			   && !capable(CAP_MKNOD))
-			  || ((mode & (S_ISUID | S_ISGID))
-			      && !capable(CAP_FSETID)));
+	dentry = cpg->dentry;
+	h_file = NULL;
+	if (au_ftest_cpup(cpg->flags, HOPEN)) {
+		AuDebugOn(cpg->bsrc < 0);
+		h_file = au_h_open_pre(dentry, cpg->bsrc);
+		err = PTR_ERR(h_file);
+		if (IS_ERR(h_file))
+			goto out;
 	}
-	if (!do_sio)
-		err = au_cpup_simple(dentry, bdst, len, flags);
+
+	parent = dget_parent(dentry);
+	h_dir = au_h_iptr(parent->d_inode, cpg->bdst);
+	if (!au_test_h_perm_sio(h_dir, MAY_EXEC | MAY_WRITE)
+	    && !au_cpup_sio_test(cpg->pin, dentry->d_inode->i_mode))
+		err = au_cpup_simple(cpg);
 	else {
 		struct au_cpup_simple_args args = {
 			.errp		= &err,
-			.dentry		= dentry,
-			.bdst		= bdst,
-			.len		= len,
-			.flags		= flags
+			.cpg		= cpg
 		};
 		wkq_err = au_wkq_wait(au_call_cpup_simple, &args);
 		if (unlikely(wkq_err))
@@ -792,6 +938,10 @@
 	}
 
 	dput(parent);
+	if (h_file)
+		au_h_open_post(dentry, cpg->bsrc, h_file);
+
+out:
 	return err;
 }
 
@@ -800,50 +950,57 @@
 /*
  * copyup the deleted file for writing.
  */
-static int au_do_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst,
-			 struct dentry *wh_dentry, struct file *file,
-			 loff_t len)
+static int au_do_cpup_wh(struct au_cp_generic *cpg, struct dentry *wh_dentry,
+			 struct file *file)
 {
 	int err;
-	aufs_bindex_t bstart;
-	struct au_dinfo *dinfo;
+	unsigned int flags_orig;
+	aufs_bindex_t bsrc_orig;
 	struct dentry *h_d_dst, *h_d_start;
+	struct au_dinfo *dinfo;
 	struct au_hdentry *hdp;
 
-	dinfo = au_di(dentry);
+	dinfo = au_di(cpg->dentry);
 	AuRwMustWriteLock(&dinfo->di_rwsem);
 
-	bstart = dinfo->di_bstart;
+	bsrc_orig = cpg->bsrc;
+	cpg->bsrc = dinfo->di_bstart;
 	hdp = dinfo->di_hdentry;
-	h_d_dst = hdp[0 + bdst].hd_dentry;
-	dinfo->di_bstart = bdst;
-	hdp[0 + bdst].hd_dentry = wh_dentry;
+	h_d_dst = hdp[0 + cpg->bdst].hd_dentry;
+	dinfo->di_bstart = cpg->bdst;
+	hdp[0 + cpg->bdst].hd_dentry = wh_dentry;
+	h_d_start = NULL;
 	if (file) {
-		h_d_start = hdp[0 + bstart].hd_dentry;
-		hdp[0 + bstart].hd_dentry = au_hf_top(file)->f_dentry;
+		h_d_start = hdp[0 + cpg->bsrc].hd_dentry;
+		hdp[0 + cpg->bsrc].hd_dentry = au_hf_top(file)->f_dentry;
 	}
-	err = au_cpup_single(dentry, bdst, bstart, len, !AuCpup_DTIME,
-			     /*h_parent*/NULL);
+	flags_orig = cpg->flags;
+	cpg->flags = !AuCpup_DTIME;
+	err = au_cpup_single(cpg, /*h_parent*/NULL);
+	cpg->flags = flags_orig;
 	if (file) {
 		if (!err)
 			err = au_reopen_nondir(file);
-		hdp[0 + bstart].hd_dentry = h_d_start;
+		hdp[0 + cpg->bsrc].hd_dentry = h_d_start;
 	}
-	hdp[0 + bdst].hd_dentry = h_d_dst;
-	dinfo->di_bstart = bstart;
+	hdp[0 + cpg->bdst].hd_dentry = h_d_dst;
+	dinfo->di_bstart = cpg->bsrc;
+	cpg->bsrc = bsrc_orig;
 
 	return err;
 }
 
-static int au_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-		      struct file *file)
+static int au_cpup_wh(struct au_cp_generic *cpg, struct file *file)
 {
 	int err;
+	aufs_bindex_t bdst;
 	struct au_dtime dt;
-	struct dentry *parent, *h_parent, *wh_dentry;
+	struct dentry *dentry, *parent, *h_parent, *wh_dentry;
 	struct au_branch *br;
 	struct path h_path;
 
+	dentry = cpg->dentry;
+	bdst = cpg->bdst;
 	br = au_sbr(dentry->d_sb, bdst);
 	parent = dget_parent(dentry);
 	h_parent = au_h_dptr(parent, bdst);
@@ -853,9 +1010,9 @@
 		goto out;
 
 	h_path.dentry = h_parent;
-	h_path.mnt = br->br_mnt;
+	h_path.mnt = au_br_mnt(br);
 	au_dtime_store(&dt, parent, &h_path);
-	err = au_do_cpup_wh(dentry, bdst, wh_dentry, file, len);
+	err = au_do_cpup_wh(cpg, wh_dentry, file);
 	if (unlikely(err))
 		goto out_wh;
 
@@ -882,32 +1039,37 @@
 
 struct au_cpup_wh_args {
 	int *errp;
-	struct dentry *dentry;
-	aufs_bindex_t bdst;
-	loff_t len;
+	struct au_cp_generic *cpg;
 	struct file *file;
 };
 
 static void au_call_cpup_wh(void *args)
 {
 	struct au_cpup_wh_args *a = args;
-	*a->errp = au_cpup_wh(a->dentry, a->bdst, a->len, a->file);
+
+	au_pin_hdir_acquire_nest(a->cpg->pin);
+	*a->errp = au_cpup_wh(a->cpg, a->file);
+	au_pin_hdir_release(a->cpg->pin);
 }
 
-int au_sio_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-		   struct file *file)
+int au_sio_cpup_wh(struct au_cp_generic *cpg, struct file *file)
 {
 	int err, wkq_err;
-	struct dentry *parent, *h_orph, *h_parent, *h_dentry;
-	struct inode *dir, *h_dir, *h_tmpdir, *h_inode;
+	aufs_bindex_t bdst;
+	struct dentry *dentry, *parent, *h_orph, *h_parent, *h_dentry;
+	struct inode *dir, *h_dir, *h_tmpdir;
 	struct au_wbr *wbr;
+	struct au_pin wh_pin, *pin_orig;
 
+	dentry = cpg->dentry;
+	bdst = cpg->bdst;
 	parent = dget_parent(dentry);
 	dir = parent->d_inode;
 	h_orph = NULL;
 	h_parent = NULL;
 	h_dir = au_igrab(au_h_iptr(dir, bdst));
 	h_tmpdir = h_dir;
+	pin_orig = NULL;
 	if (!h_dir->i_nlink) {
 		wbr = au_sbr(dentry->d_sb, bdst)->br_wbr;
 		h_orph = wbr->wbr_orph;
@@ -917,27 +1079,26 @@
 		h_tmpdir = h_orph->d_inode;
 		au_set_h_iptr(dir, bdst, au_igrab(h_tmpdir), /*flags*/0);
 
-		/* this temporary unlock is safe */
 		if (file)
 			h_dentry = au_hf_top(file)->f_dentry;
 		else
 			h_dentry = au_h_dptr(dentry, au_dbstart(dentry));
-		h_inode = h_dentry->d_inode;
-		IMustLock(h_inode);
-		mutex_unlock(&h_inode->i_mutex);
 		mutex_lock_nested(&h_tmpdir->i_mutex, AuLsc_I_PARENT3);
-		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
 		/* todo: au_h_open_pre()? */
+
+		pin_orig = cpg->pin;
+		au_pin_init(&wh_pin, dentry, bdst, AuLsc_DI_PARENT,
+			    AuLsc_I_PARENT3, cpg->pin->udba, AuPin_DI_LOCKED);
+		cpg->pin = &wh_pin;
 	}
 
-	if (!au_test_h_perm_sio(h_tmpdir, MAY_EXEC | MAY_WRITE))
-		err = au_cpup_wh(dentry, bdst, len, file);
+	if (!au_test_h_perm_sio(h_tmpdir, MAY_EXEC | MAY_WRITE)
+	    && !au_cpup_sio_test(cpg->pin, dentry->d_inode->i_mode))
+		err = au_cpup_wh(cpg, file);
 	else {
 		struct au_cpup_wh_args args = {
 			.errp	= &err,
-			.dentry	= dentry,
-			.bdst	= bdst,
-			.len	= len,
+			.cpg	= cpg,
 			.file	= file
 		};
 		wkq_err = au_wkq_wait(au_call_cpup_wh, &args);
@@ -950,6 +1111,8 @@
 		/* todo: au_h_open_post()? */
 		au_set_h_iptr(dir, bdst, au_igrab(h_dir), /*flags*/0);
 		au_set_h_dptr(parent, bdst, h_parent);
+		AuDebugOn(!pin_orig);
+		cpg->pin = pin_orig;
 	}
 	iput(h_dir);
 	dput(parent);
@@ -965,6 +1128,7 @@
 /* cf. revalidate function in file.c */
 int au_cp_dirs(struct dentry *dentry, aufs_bindex_t bdst,
 	       int (*cp)(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct au_pin *pin,
 			 struct dentry *h_parent, void *arg),
 	       void *arg)
 {
@@ -1010,7 +1174,7 @@
 			au_pin_set_dentry(&pin, d);
 			err = au_do_pin(&pin);
 			if (!err) {
-				err = cp(d, bdst, h_parent, arg);
+				err = cp(d, bdst, &pin, h_parent, arg);
 				au_unpin(&pin);
 			}
 		}
@@ -1027,10 +1191,19 @@
 }
 
 static int au_cpup_dir(struct dentry *dentry, aufs_bindex_t bdst,
+		       struct au_pin *pin,
 		       struct dentry *h_parent __maybe_unused ,
 		       void *arg __maybe_unused)
 {
-	return au_sio_cpup_simple(dentry, bdst, -1, AuCpup_DTIME);
+	struct au_cp_generic cpg = {
+		.dentry	= dentry,
+		.bdst	= bdst,
+		.bsrc	= -1,
+		.len	= 0,
+		.pin	= pin,
+		.flags	= AuCpup_DTIME
+	};
+	return au_sio_cpup_simple(&cpg);
 }
 
 int au_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst)
diff -ru --new-file linux-3.x-orig/fs/aufs/cpup.h linux-3.x/fs/aufs/cpup.h
--- linux-3.x-orig/fs/aufs/cpup.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/cpup.h	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,13 +26,12 @@
 #ifdef __KERNEL__
 
 #include <linux/path.h>
-#include <linux/time.h>
-#include <linux/aufs_type.h>
 
 struct inode;
 struct file;
+struct au_pin;
 
-void au_cpup_attr_flags(struct inode *dst, struct inode *src);
+void au_cpup_attr_flags(struct inode *dst, unsigned int iflags);
 void au_cpup_attr_timesizes(struct inode *inode);
 void au_cpup_attr_nlink(struct inode *inode, int force);
 void au_cpup_attr_changeable(struct inode *inode);
@@ -41,10 +40,21 @@
 
 /* ---------------------------------------------------------------------- */
 
+struct au_cp_generic {
+	struct dentry	*dentry;
+	aufs_bindex_t	bdst, bsrc;
+	loff_t		len;
+	struct au_pin	*pin;
+	unsigned int	flags;
+};
+
 /* cpup flags */
 #define AuCpup_DTIME	1		/* do dtime_store/revert */
 #define AuCpup_KEEPLINO	(1 << 1)	/* do not clear the lower xino,
 					   for link(2) */
+#define AuCpup_RENAME	(1 << 2)	/* rename after cpup */
+#define AuCpup_HOPEN	(1 << 3)	/* call h_open_pre/post() in cpup */
+
 #define au_ftest_cpup(flags, name)	((flags) & AuCpup_##name)
 #define au_fset_cpup(flags, name) \
 	do { (flags) |= AuCpup_##name; } while (0)
@@ -52,16 +62,12 @@
 	do { (flags) &= ~AuCpup_##name; } while (0)
 
 int au_copy_file(struct file *dst, struct file *src, loff_t len);
-int au_sio_cpup_single(struct dentry *dentry, aufs_bindex_t bdst,
-		       aufs_bindex_t bsrc, loff_t len, unsigned int flags,
-		       struct dentry *dst_parent);
-int au_sio_cpup_simple(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-		       unsigned int flags);
-int au_sio_cpup_wh(struct dentry *dentry, aufs_bindex_t bdst, loff_t len,
-		   struct file *file);
+int au_sio_cpup_simple(struct au_cp_generic *cpg);
+int au_sio_cpup_wh(struct au_cp_generic *cpg, struct file *file);
 
 int au_cp_dirs(struct dentry *dentry, aufs_bindex_t bdst,
 	       int (*cp)(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct au_pin *pin,
 			 struct dentry *h_parent, void *arg),
 	       void *arg);
 int au_cpup_dirs(struct dentry *dentry, aufs_bindex_t bdst);
diff -ru --new-file linux-3.x-orig/fs/aufs/dbgaufs.c linux-3.x/fs/aufs/dbgaufs.c
--- linux-3.x-orig/fs/aufs/dbgaufs.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dbgaufs.c	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -96,6 +96,101 @@
 
 /* ---------------------------------------------------------------------- */
 
+struct dbgaufs_plink_arg {
+	int n;
+	char a[];
+};
+
+static int dbgaufs_plink_release(struct inode *inode __maybe_unused,
+				 struct file *file)
+{
+	free_page((unsigned long)file->private_data);
+	return 0;
+}
+
+static int dbgaufs_plink_open(struct inode *inode, struct file *file)
+{
+	int err, i, limit;
+	unsigned long n, sum;
+	struct dbgaufs_plink_arg *p;
+	struct au_sbinfo *sbinfo;
+	struct super_block *sb;
+	struct au_sphlhead *sphl;
+
+	err = -ENOMEM;
+	p = (void *)get_zeroed_page(GFP_NOFS);
+	if (unlikely(!p))
+		goto out;
+
+	err = -EFBIG;
+	sbinfo = inode->i_private;
+	sb = sbinfo->si_sb;
+	si_noflush_read_lock(sb);
+	if (au_opt_test(au_mntflags(sb), PLINK)) {
+		limit = PAGE_SIZE - sizeof(p->n);
+
+		/* the number of buckets */
+		n = snprintf(p->a + p->n, limit, "%d\n", AuPlink_NHASH);
+		p->n += n;
+		limit -= n;
+
+		sum = 0;
+		for (i = 0, sphl = sbinfo->si_plink;
+		     i < AuPlink_NHASH;
+		     i++, sphl++) {
+			n = au_sphl_count(sphl);
+			sum += n;
+
+			n = snprintf(p->a + p->n, limit, "%lu ", n);
+			p->n += n;
+			limit -= n;
+			if (unlikely(limit <= 0))
+				goto out_free;
+		}
+		p->a[p->n - 1] = '\n';
+
+		/* the sum of plinks */
+		n = snprintf(p->a + p->n, limit, "%lu\n", sum);
+		p->n += n;
+		limit -= n;
+		if (unlikely(limit <= 0))
+			goto out_free;
+	} else {
+#define str "1\n0\n0\n"
+		p->n = sizeof(str) - 1;
+		strcpy(p->a, str);
+#undef str
+	}
+	si_read_unlock(sb);
+
+	err = 0;
+	file->private_data = p;
+	goto out; /* success */
+
+out_free:
+	free_page((unsigned long)p);
+out:
+	return err;
+}
+
+static ssize_t dbgaufs_plink_read(struct file *file, char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct dbgaufs_plink_arg *p;
+
+	p = file->private_data;
+	return simple_read_from_buffer(buf, count, ppos, p->a, p->n);
+}
+
+static const struct file_operations dbgaufs_plink_fop = {
+	.owner		= THIS_MODULE,
+	.open		= dbgaufs_plink_open,
+	.release	= dbgaufs_plink_release,
+	.read		= dbgaufs_plink_read
+};
+
+/* ---------------------------------------------------------------------- */
+
 static int dbgaufs_xib_open(struct inode *inode, struct file *file)
 {
 	int err;
@@ -137,7 +232,7 @@
 		     || memcmp(name->name, DbgaufsXi_PREFIX,
 			       sizeof(DbgaufsXi_PREFIX) - 1)))
 		goto out;
-	err = strict_strtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);
+	err = kstrtol(name->name + sizeof(DbgaufsXi_PREFIX) - 1, 10, &l);
 	if (unlikely(err))
 		goto out;
 
@@ -175,10 +270,8 @@
 	for (; bindex <= bend; bindex++) {
 		br = au_sbr(sb, bindex);
 		xi = &br->br_xino;
-		if (xi->xi_dbgaufs) {
-			debugfs_remove(xi->xi_dbgaufs);
-			xi->xi_dbgaufs = NULL;
-		}
+		debugfs_remove(xi->xi_dbgaufs);
+		xi->xi_dbgaufs = NULL;
 	}
 }
 
@@ -305,6 +398,12 @@
 	if (unlikely(!sbinfo->si_dbgaufs_xib))
 		goto out_dir;
 
+	sbinfo->si_dbgaufs_plink = debugfs_create_file
+		("plink", dbgaufs_mode, sbinfo->si_dbgaufs, sbinfo,
+		 &dbgaufs_plink_fop);
+	if (unlikely(!sbinfo->si_dbgaufs_plink))
+		goto out_dir;
+
 	err = dbgaufs_xigen_init(sbinfo);
 	if (!err)
 		goto out; /* success */
diff -ru --new-file linux-3.x-orig/fs/aufs/dbgaufs.h linux-3.x/fs/aufs/dbgaufs.h
--- linux-3.x-orig/fs/aufs/dbgaufs.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dbgaufs.h	2014-12-23 17:23:09.031087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,9 +25,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/init.h>
-#include <linux/aufs_type.h>
-
 struct super_block;
 struct au_sbinfo;
 
diff -ru --new-file linux-3.x-orig/fs/aufs/dcsub.c linux-3.x/fs/aufs/dcsub.c
--- linux-3.x-orig/fs/aufs/dcsub.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dcsub.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -ru --new-file linux-3.x-orig/fs/aufs/dcsub.h linux-3.x/fs/aufs/dcsub.h
--- linux-3.x-orig/fs/aufs/dcsub.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dcsub.h	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -27,7 +27,6 @@
 
 #include <linux/dcache.h>
 #include <linux/fs.h>
-#include <linux/types.h>
 
 struct dentry;
 
diff -ru --new-file linux-3.x-orig/fs/aufs/debug.c linux-3.x/fs/aufs/debug.c
--- linux-3.x-orig/fs/aufs/debug.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/debug.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,13 +20,42 @@
  * debug print functions
  */
 
-#include <linux/module.h>
 #include <linux/vt_kern.h>
 #include "aufs.h"
 
-int aufs_debug;
+/* Returns 0, or -errno.  arg is in kp->arg. */
+static int param_atomic_t_set(const char *val, const struct kernel_param *kp)
+{
+	int err, n;
+
+	err = kstrtoint(val, 0, &n);
+	if (!err) {
+		if (n > 0)
+			au_debug_on();
+		else
+			au_debug_off();
+	}
+	return err;
+}
+
+/* Returns length written or -errno.  Buffer is 4k (ie. be short!) */
+static int param_atomic_t_get(char *buffer, const struct kernel_param *kp)
+{
+	atomic_t *a;
+
+	a = kp->arg;
+	return sprintf(buffer, "%d", atomic_read(a));
+}
+
+static struct kernel_param_ops param_ops_atomic_t = {
+	.set = param_atomic_t_set,
+	.get = param_atomic_t_get
+	/* void (*free)(void *arg) */
+};
+
+atomic_t aufs_debug = ATOMIC_INIT(0);
 MODULE_PARM_DESC(debug, "debug print");
-module_param_named(debug, aufs_debug, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(debug, aufs_debug, atomic_t, S_IRUGO | S_IWUSR | S_IWGRP);
 
 char *au_plevel = KERN_DEBUG;
 #define dpri(fmt, ...) do {					\
@@ -78,7 +107,7 @@
 	}
 }
 
-static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode,
+static int do_pri_inode(aufs_bindex_t bindex, struct inode *inode, int hn,
 			struct dentry *wh)
 {
 	char *n = NULL;
@@ -89,7 +118,7 @@
 		return -1;
 	}
 
-	/* the type of i_blocks depends upon CONFIG_LSF */
+	/* the type of i_blocks depends upon CONFIG_LBDAF */
 	BUILD_BUG_ON(sizeof(inode->i_blocks) != sizeof(unsigned long)
 		     && sizeof(inode->i_blocks) != sizeof(u64));
 	if (wh) {
@@ -97,13 +126,13 @@
 		l = wh->d_name.len;
 	}
 
-	dpri("i%d: i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,"
-	     " ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\n",
-	     bindex,
+	dpri("i%d: %p, i%lu, %s, cnt %d, nl %u, 0%o, sz %llu, blk %llu,"
+	     " hn %d, ct %lld, np %lu, st 0x%lx, f 0x%x, v %llu, g %x%s%.*s\n",
+	     bindex, inode,
 	     inode->i_ino, inode->i_sb ? au_sbtype(inode->i_sb) : "??",
 	     atomic_read(&inode->i_count), inode->i_nlink, inode->i_mode,
 	     i_size_read(inode), (unsigned long long)inode->i_blocks,
-	     (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,
+	     hn, (long long)timespec_to_ns(&inode->i_ctime) & 0x0ffff,
 	     inode->i_mapping ? inode->i_mapping->nrpages : 0,
 	     inode->i_state, inode->i_flags, inode->i_version,
 	     inode->i_generation,
@@ -115,9 +144,9 @@
 {
 	struct au_iinfo *iinfo;
 	aufs_bindex_t bindex;
-	int err;
+	int err, hn;
 
-	err = do_pri_inode(-1, inode, NULL);
+	err = do_pri_inode(-1, inode, -1, NULL);
 	if (err || !au_test_aufs(inode->i_sb))
 		return;
 
@@ -125,12 +154,15 @@
 	if (!iinfo)
 		return;
 	dpri("i-1: bstart %d, bend %d, gen %d\n",
-	     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode));
+	     iinfo->ii_bstart, iinfo->ii_bend, au_iigen(inode, NULL));
 	if (iinfo->ii_bstart < 0)
 		return;
-	for (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++)
-		do_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode,
+	hn = 0;
+	for (bindex = iinfo->ii_bstart; bindex <= iinfo->ii_bend; bindex++) {
+		hn = !!au_hn(iinfo->ii_hinode + bindex);
+		do_pri_inode(bindex, iinfo->ii_hinode[0 + bindex].hi_inode, hn,
 			     iinfo->ii_hinode[0 + bindex].hi_whdentry);
+	}
 }
 
 void au_dpri_dalias(struct inode *inode)
@@ -146,6 +178,7 @@
 static int do_pri_dentry(aufs_bindex_t bindex, struct dentry *dentry)
 {
 	struct dentry *wh = NULL;
+	int hn;
 
 	if (!dentry || IS_ERR(dentry)) {
 		dpri("d%d: err %ld\n", bindex, PTR_ERR(dentry));
@@ -158,12 +191,15 @@
 	     AuDLNPair(dentry->d_parent), AuDLNPair(dentry),
 	     dentry->d_sb ? au_sbtype(dentry->d_sb) : "??",
 	     dentry->d_count, dentry->d_flags);
+	hn = -1;
 	if (bindex >= 0 && dentry->d_inode && au_test_aufs(dentry->d_sb)) {
 		struct au_iinfo *iinfo = au_ii(dentry->d_inode);
-		if (iinfo)
+		if (iinfo) {
+			hn = !!au_hn(iinfo->ii_hinode + bindex);
 			wh = iinfo->ii_hinode[0 + bindex].hi_whdentry;
+		}
 	}
-	do_pri_inode(bindex, dentry->d_inode, wh);
+	do_pri_inode(bindex, dentry->d_inode, hn, wh);
 	return 0;
 }
 
@@ -250,18 +286,18 @@
 
 	if (!br || IS_ERR(br))
 		goto out;
-	mnt = br->br_mnt;
+	mnt = au_br_mnt(br);
 	if (!mnt || IS_ERR(mnt))
 		goto out;
 	sb = mnt->mnt_sb;
 	if (!sb || IS_ERR(sb))
 		goto out;
 
-	dpri("s%d: {perm 0x%x, cnt %d, wbr %p}, "
+	dpri("s%d: {perm 0x%x, id %d, cnt %d, wbr %p}, "
 	     "%s, dev 0x%02x%02x, flags 0x%lx, cnt %d, active %d, "
 	     "xino %d\n",
-	     bindex, br->br_perm, atomic_read(&br->br_count), br->br_wbr,
-	     au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),
+	     bindex, br->br_perm, br->br_id, atomic_read(&br->br_count),
+	     br->br_wbr, au_sbtype(sb), MAJOR(sb->s_dev), MINOR(sb->s_dev),
 	     sb->s_flags, sb->s_count,
 	     atomic_read(&sb->s_active), !!br->br_xino.xi_file);
 	return 0;
@@ -291,7 +327,7 @@
 
 	a->mnt.mnt_sb = sb;
 	a->fake.br_perm = 0;
-	a->fake.br_mnt = &a->mnt;
+	a->fake.br_path.mnt = &a->mnt;
 	a->fake.br_xino.xi_file = NULL;
 	atomic_set(&a->fake.br_count, 0);
 	smp_mb(); /* atomic_set */
@@ -321,8 +357,11 @@
 
 void au_dbg_iattr(struct iattr *ia)
 {
-#define AuBit(name)	if (ia->ia_valid & ATTR_ ## name) \
-				dpri(#name "\n")
+#define AuBit(name)					\
+	do {						\
+		if (ia->ia_valid & ATTR_ ## name)	\
+			dpri(#name "\n");		\
+	} while (0)
 	AuBit(MODE);
 	AuBit(UID);
 	AuBit(GID);
@@ -370,14 +409,11 @@
 			continue;
 		h_inode = au_h_iptr(inode, bindex);
 		if (unlikely(h_inode != h_dentry->d_inode)) {
-			int old = au_debug_test();
-			if (!old)
-				au_debug(1);
+			au_debug_on();
 			AuDbg("b%d, %s:%d\n", bindex, func, line);
 			AuDbgDentry(dentry);
 			AuDbgInode(inode);
-			if (!old)
-				au_debug(0);
+			au_debug_off();
 			BUG();
 		}
 	}
@@ -428,9 +464,13 @@
 
 void au_dbg_verify_kthread(void)
 {
-	if (current->flags & PF_WQ_WORKER) {
+	if (au_wkq_test()) {
 		au_dbg_blocked();
-		WARN_ON(1);
+		/*
+		 * It may be recursive, but udba=notify between two aufs mounts,
+		 * where a single ro branch is shared, is not a problem.
+		 */
+		/* WARN_ON(1); */
 	}
 }
 
@@ -468,7 +508,7 @@
 	AuDebugOn(destr.len < NAME_MAX);
 
 #ifdef CONFIG_4KSTACKS
-	pr_warning("CONFIG_4KSTACKS is defined.\n");
+	pr_warn("CONFIG_4KSTACKS is defined.\n");
 #endif
 
 #ifdef AuForceNoBrs
diff -ru --new-file linux-3.x-orig/fs/aufs/debug.h linux-3.x/fs/aufs/debug.h
--- linux-3.x-orig/fs/aufs/debug.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/debug.h	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,38 +26,38 @@
 #ifdef __KERNEL__
 
 #include <asm/system.h>
-#include <linux/bug.h>
-/* #include <linux/err.h> */
-#include <linux/init.h>
+#include <linux/atomic.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-/* #include <linux/kernel.h> */
-#include <linux/delay.h>
-/* #include <linux/kd.h> */
 #include <linux/sysrq.h>
-#include <linux/aufs_type.h>
 
 #ifdef CONFIG_AUFS_DEBUG
 #define AuDebugOn(a)		BUG_ON(a)
 
 /* module parameter */
-extern int aufs_debug;
-static inline void au_debug(int n)
+extern atomic_t aufs_debug;
+static inline void au_debug_on(void)
 {
-	aufs_debug = n;
-	smp_mb();
+	atomic_inc(&aufs_debug);
+}
+static inline void au_debug_off(void)
+{
+	atomic_dec_if_positive(&aufs_debug);
 }
 
 static inline int au_debug_test(void)
 {
-	return aufs_debug;
+	return atomic_read(&aufs_debug) > 0;
 }
 #else
 #define AuDebugOn(a)		do {} while (0)
-AuStubVoid(au_debug, int n)
+AuStubVoid(au_debug_on, void)
+AuStubVoid(au_debug_off, void)
 AuStubInt0(au_debug_test, void)
 #endif /* CONFIG_AUFS_DEBUG */
 
+#define param_check_atomic_t(name, p) __param_check(name, p, atomic_t)
+
 /* ---------------------------------------------------------------------- */
 
 /* debug print */
@@ -71,7 +71,7 @@
 #define AuWarn1(fmt, ...) do { \
 	static unsigned char _c; \
 	if (!_c++) \
-		pr_warning(fmt, ##__VA_ARGS__); \
+		pr_warn(fmt, ##__VA_ARGS__); \
 } while (0)
 
 #define AuErr1(fmt, ...) do { \
diff -ru --new-file linux-3.x-orig/fs/aufs/dentry.c linux-3.x/fs/aufs/dentry.c
--- linux-3.x-orig/fs/aufs/dentry.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dentry.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -60,7 +60,7 @@
 
 	au_h_nd(&h_nd, nd);
 	h_nd.path.dentry = h_parent;
-	h_nd.path.mnt = br->br_mnt;
+	h_nd.path.mnt = au_br_mnt(br);
 
 	err = vfsub_name_hash(name->name, &h_nd.last, name->len);
 	h_dentry = ERR_PTR(err);
@@ -308,15 +308,19 @@
 /*
  * lookup @dentry on @bindex which should be negative.
  */
-int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex)
+int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex, int wh)
 {
 	int err;
 	struct dentry *parent, *h_parent, *h_dentry;
+	struct au_branch *br;
 
 	parent = dget_parent(dentry);
 	h_parent = au_h_dptr(parent, bindex);
-	h_dentry = au_sio_lkup_one(&dentry->d_name, h_parent,
-				   au_sbr(dentry->d_sb, bindex));
+	br = au_sbr(dentry->d_sb, bindex);
+	if (wh)
+		h_dentry = au_whtmp_lkup(h_parent, br, &dentry->d_name);
+	else
+		h_dentry = au_sio_lkup_one(&dentry->d_name, h_parent, br);
 	err = PTR_ERR(h_dentry);
 	if (IS_ERR(h_dentry))
 		goto out;
@@ -849,7 +853,7 @@
 		BUG_ON(bindex > au_dbend(parent));
 		h_nd.path.dentry = au_h_dptr(parent, bindex);
 		BUG_ON(!h_nd.path.dentry);
-		h_nd.path.mnt = au_sbr(parent->d_sb, bindex)->br_mnt;
+		h_nd.path.mnt = au_sbr_mnt(parent->d_sb, bindex);
 		path_get(&h_nd.path);
 		valid = reval(h_dentry, &h_nd);
 		path_put(&h_nd.path);
diff -ru --new-file linux-3.x-orig/fs/aufs/dentry.h linux-3.x/fs/aufs/dentry.h
--- linux-3.x-orig/fs/aufs/dentry.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dentry.h	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
 #ifdef __KERNEL__
 
 #include <linux/dcache.h>
-#include <linux/aufs_type.h>
 #include "rwsem.h"
 
 struct au_hdentry {
@@ -56,7 +55,7 @@
 
 int au_lkup_dentry(struct dentry *dentry, aufs_bindex_t bstart, mode_t type,
 		   struct nameidata *nd);
-int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex);
+int au_lkup_neg(struct dentry *dentry, aufs_bindex_t bindex, int wh);
 int au_refresh_dentry(struct dentry *dentry, struct dentry *parent);
 int au_reval_dpath(struct dentry *dentry, unsigned int sigen);
 
diff -ru --new-file linux-3.x-orig/fs/aufs/dinfo.c linux-3.x/fs/aufs/dinfo.c
--- linux-3.x-orig/fs/aufs/dinfo.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dinfo.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -ru --new-file linux-3.x-orig/fs/aufs/dir.c linux-3.x/fs/aufs/dir.c
--- linux-3.x-orig/fs/aufs/dir.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dir.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,26 +20,35 @@
  * directory operations
  */
 
-#include <linux/file.h>
 #include <linux/fs_stack.h>
 #include "aufs.h"
 
 void au_add_nlink(struct inode *dir, struct inode *h_dir)
 {
+	unsigned int nlink;
+
 	AuDebugOn(!S_ISDIR(dir->i_mode) || !S_ISDIR(h_dir->i_mode));
 
-	dir->i_nlink += h_dir->i_nlink - 2;
+	nlink = dir->i_nlink;
+	nlink += h_dir->i_nlink - 2;
 	if (h_dir->i_nlink < 2)
-		dir->i_nlink += 2;
+		nlink += 2;
+	smp_mb();
+	set_nlink(dir, nlink);
 }
 
 void au_sub_nlink(struct inode *dir, struct inode *h_dir)
 {
+	unsigned int nlink;
+
 	AuDebugOn(!S_ISDIR(dir->i_mode) || !S_ISDIR(h_dir->i_mode));
 
-	dir->i_nlink -= h_dir->i_nlink - 2;
+	nlink = dir->i_nlink;
+	nlink -= h_dir->i_nlink - 2;
 	if (h_dir->i_nlink < 2)
-		dir->i_nlink -= 2;
+		nlink -= 2;
+	smp_mb();
+	set_nlink(dir, nlink);
 }
 
 loff_t au_dir_size(struct file *file, struct dentry *dentry)
@@ -277,31 +286,15 @@
 	bend = au_dbend(dentry);
 	for (bindex = au_dbstart(dentry); !err && bindex <= bend; bindex++) {
 		struct path h_path;
-		struct inode *h_inode;
 
 		if (au_test_ro(sb, bindex, inode))
 			continue;
 		h_path.dentry = au_h_dptr(dentry, bindex);
 		if (!h_path.dentry)
 			continue;
-		h_inode = h_path.dentry->d_inode;
-		if (!h_inode)
-			continue;
 
-		/* no mnt_want_write() */
-		/* cf. fs/nsfd/vfs.c and fs/nfsd/nfs4recover.c */
-		/* todo: inotiry fired? */
 		h_path.mnt = au_sbr_mnt(sb, bindex);
-		mutex_lock(&h_inode->i_mutex);
-		err = filemap_fdatawrite(h_inode->i_mapping);
-		AuDebugOn(!h_inode->i_fop);
-		if (!err && h_inode->i_fop->fsync)
-			err = h_inode->i_fop->fsync(NULL, datasync);
-		if (!err)
-			err = filemap_fdatawrite(h_inode->i_mapping);
-		if (!err)
-			vfsub_update_h_iattr(&h_path, /*did*/NULL); /*ignore*/
-		mutex_unlock(&h_inode->i_mutex);
+		err = vfsub_fsync(NULL, &h_path, datasync);
 	}
 
 	return err;
@@ -314,7 +307,6 @@
 	struct file *h_file;
 	struct super_block *sb;
 	struct inode *inode;
-	struct mutex *h_mtx;
 
 	err = au_reval_and_lock_fdi(file, reopen_dir, /*wlock*/1);
 	if (unlikely(err))
@@ -328,14 +320,7 @@
 		if (!h_file || au_test_ro(sb, bindex, inode))
 			continue;
 
-		err = vfs_fsync(h_file, datasync);
-		if (!err) {
-			h_mtx = &h_file->f_dentry->d_inode->i_mutex;
-			mutex_lock(h_mtx);
-			vfsub_update_h_iattr(&h_file->f_path, /*did*/NULL);
-			/*ignore*/
-			mutex_unlock(h_mtx);
-		}
+		err = vfsub_fsync(h_file, &h_file->f_path, datasync);
 	}
 
 out:
@@ -345,16 +330,18 @@
 /*
  * @file may be NULL
  */
-static int aufs_fsync_dir(struct file *file, int datasync)
+static int aufs_fsync_dir(struct file *file, loff_t start, loff_t end,
+			  int datasync)
 {
 	int err;
 	struct dentry *dentry;
 	struct super_block *sb;
-
-	dentry = file->f_dentry;
-	IMustLock(dentry->d_inode);
+	struct mutex *mtx;
 
 	err = 0;
+	dentry = file->f_dentry;
+	mtx = &dentry->d_inode->i_mutex;
+	mutex_lock(mtx);
 	sb = dentry->d_sb;
 	si_noflush_read_lock(sb);
 	if (file)
@@ -369,6 +356,7 @@
 		fi_write_unlock(file);
 
 	si_read_unlock(sb);
+	mutex_unlock(mtx);
 	return err;
 }
 
@@ -378,7 +366,7 @@
 {
 	int err;
 	struct dentry *dentry;
-	struct inode *inode;
+	struct inode *inode, *h_inode;
 	struct super_block *sb;
 
 	dentry = file->f_dentry;
@@ -397,22 +385,22 @@
 	if (unlikely(err))
 		goto out_unlock;
 
+	h_inode = au_h_iptr(inode, au_ibstart(inode));
 	if (!au_test_nfsd()) {
 		err = au_vdir_fill_de(file, dirent, filldir);
-		fsstack_copy_attr_atime(inode,
-					au_h_iptr(inode, au_ibstart(inode)));
+		fsstack_copy_attr_atime(inode, h_inode);
 	} else {
 		/*
 		 * nfsd filldir may call lookup_one_len(), vfs_getattr(),
 		 * encode_fh() and others.
 		 */
-		struct inode *h_inode = au_h_iptr(inode, au_ibstart(inode));
-
+		atomic_inc(&h_inode->i_count);
 		di_read_unlock(dentry, AuLock_IR);
 		si_read_unlock(sb);
 		err = au_vdir_fill_de(file, dirent, filldir);
 		fsstack_copy_attr_atime(inode, h_inode);
 		fi_write_unlock(file);
+		iput(h_inode);
 
 		AuTraceErr(err);
 		return err;
@@ -537,6 +525,7 @@
 
 	h_dentry = au_h_dptr(dentry, arg->bindex);
 	h_inode = h_dentry->d_inode;
+	/* todo: i_mode changes anytime? */
 	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
 	err = au_test_h_perm_sio(h_inode, MAY_EXEC | MAY_READ);
 	mutex_unlock(&h_inode->i_mutex);
diff -ru --new-file linux-3.x-orig/fs/aufs/dir.h linux-3.x/fs/aufs/dir.h
--- linux-3.x-orig/fs/aufs/dir.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dir.h	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
 #ifdef __KERNEL__
 
 #include <linux/fs.h>
-#include <linux/aufs_type.h>
 
 /* ---------------------------------------------------------------------- */
 
diff -ru --new-file linux-3.x-orig/fs/aufs/dynop.c linux-3.x/fs/aufs/dynop.c
--- linux-3.x-orig/fs/aufs/dynop.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dynop.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Junjiro R. Okajima
+ * Copyright (C) 2010-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -237,7 +237,7 @@
 
 	key->dk_op.dy_hop = op->dy_hop;
 	kref_init(&key->dk_kref);
-	p->set(key, op->dy_hop, br->br_mnt->mnt_sb);
+	p->set(key, op->dy_hop, au_br_sb(br));
 	old = dy_gadd(spl, key);
 	if (old) {
 		kfree(key);
diff -ru --new-file linux-3.x-orig/fs/aufs/dynop.h linux-3.x/fs/aufs/dynop.h
--- linux-3.x-orig/fs/aufs/dynop.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/dynop.h	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Junjiro R. Okajima
+ * Copyright (C) 2010-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,10 +25,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/rcupdate.h>
-#include <linux/aufs_type.h>
 #include "inode.h"
 
 enum {AuDy_AOP, AuDyLast};
diff -ru --new-file linux-3.x-orig/fs/aufs/export.c linux-3.x/fs/aufs/export.c
--- linux-3.x-orig/fs/aufs/export.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/export.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,7 +21,6 @@
  */
 
 #include <linux/exportfs.h>
-#include <linux/file.h>
 #include <linux/mnt_namespace.h>
 #include <linux/namei.h>
 #include <linux/nsproxy.h>
@@ -89,6 +88,21 @@
 	return !!(dentry->d_flags & DCACHE_DISCONNECTED);
 }
 
+int au_test_nfsd(void)
+{
+	int ret;
+	struct task_struct *tsk = current;
+	char comm[sizeof(tsk->comm)];
+
+	ret = 0;
+	if (tsk->flags & PF_KTHREAD) {
+		get_task_comm(comm, tsk);
+		ret = !strcmp(comm, "nfsd");
+	}
+
+	return ret;
+}
+
 /* ---------------------------------------------------------------------- */
 /* inode generation external table */
 
@@ -221,7 +235,7 @@
 	sigen = au_sigen(sb);
 	if (unlikely(is_bad_inode(inode)
 		     || IS_DEADDIR(inode)
-		     || sigen != au_iigen(inode)))
+		     || sigen != au_iigen(inode, NULL)))
 		goto out_iput;
 
 	dentry = NULL;
@@ -381,7 +395,8 @@
 	dentry = ERR_PTR(err);
 	if (unlikely(err))
 		goto out_name;
-	dentry = ERR_PTR(-ENOENT);
+	/* instead of ENOENT */
+	dentry = ERR_PTR(-ESTALE);
 	if (!arg.found)
 		goto out_name;
 
@@ -493,7 +508,7 @@
 	struct path path;
 
 	br = au_sbr(sb, nsi_lock->bindex);
-	h_mnt = br->br_mnt;
+	h_mnt = au_br_mnt(br);
 	h_sb = h_mnt->mnt_sb;
 	/* todo: call lower fh_to_dentry()? fh_to_parent()? */
 	h_parent = exportfs_decode_fh(h_mnt, (void *)(fh + Fh_tail),
@@ -711,7 +726,7 @@
 
 	err = -EPERM;
 	br = au_sbr(sb, bindex);
-	h_sb = br->br_mnt->mnt_sb;
+	h_sb = au_br_sb(br);
 	if (unlikely(!h_sb->s_export_op)) {
 		AuErr1("%s branch is not exportable\n", au_sbtype(h_sb));
 		goto out_dput;
diff -ru --new-file linux-3.x-orig/fs/aufs/file.c linux-3.x/fs/aufs/file.c
--- linux-3.x-orig/fs/aufs/file.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/file.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,9 +20,9 @@
  * handling file/dir, and address_space operation
  */
 
-#include <linux/file.h>
-#include <linux/fsnotify.h>
-#include <linux/namei.h>
+#ifdef CONFIG_AUFS_DEBUG
+#include <linux/migrate.h>
+#endif
 #include <linux/pagemap.h>
 #include "aufs.h"
 
@@ -67,7 +67,7 @@
 	br = au_sbr(sb, bindex);
 	h_file = ERR_PTR(-EACCES);
 	exec_flag = flags & __FMODE_EXEC;
-	if (exec_flag && (br->br_mnt->mnt_flags & MNT_NOEXEC))
+	if (exec_flag && (au_br_mnt(br)->mnt_flags & MNT_NOEXEC))
 		goto out;
 
 	/* drop flags for writing */
@@ -76,7 +76,7 @@
 	flags &= ~O_CREAT;
 	atomic_inc(&br->br_count);
 	h_path.dentry = h_dentry;
-	h_path.mnt = br->br_mnt;
+	h_path.mnt = au_br_mnt(br);
 	if (!au_special_file(h_inode->i_mode))
 		h_file = vfsub_dentry_open(&h_path, flags);
 	else {
@@ -154,13 +154,29 @@
 		au_set_h_fptr(file, bstart, NULL);
 	}
 	AuDebugOn(au_fi(file)->fi_hdir);
-	AuDebugOn(au_fbstart(file) < bstart);
+	/*
+	 * it can happen
+	 * file exists on both of rw and ro
+	 * open --> dbstart and fbstart are both 0
+	 * prepend a branch as rw, "rw" become ro
+	 * remove rw/file
+	 * delete the top branch, "rw" becomes rw again
+	 *	--> dbstart is 1, fbstart is still 0
+	 * write --> fbstart is 0 but dbstart is 1
+	 */
+	/* AuDebugOn(au_fbstart(file) < bstart); */
 
 	h_file = au_h_open(dentry, bstart, vfsub_file_flags(file) & ~O_TRUNC,
 			   file);
 	err = PTR_ERR(h_file);
-	if (IS_ERR(h_file))
+	if (IS_ERR(h_file)) {
+		if (h_file_tmp) {
+			atomic_inc(&au_sbr(dentry->d_sb, bstart)->br_count);
+			au_set_h_fptr(file, bstart, h_file_tmp);
+			h_file_tmp = NULL;
+		}
 		goto out; /* todo: close all? */
+	}
 
 	err = 0;
 	au_set_fbstart(file, bstart);
@@ -202,32 +218,39 @@
 }
 
 static int au_ready_to_write_wh(struct file *file, loff_t len,
-				aufs_bindex_t bcpup)
+				aufs_bindex_t bcpup, struct au_pin *pin)
 {
 	int err;
 	struct inode *inode, *h_inode;
-	struct dentry *dentry, *h_dentry, *hi_wh;
+	struct dentry *h_dentry, *hi_wh;
+	struct au_cp_generic cpg = {
+		.dentry	= file->f_dentry,
+		.bdst	= bcpup,
+		.bsrc	= -1,
+		.len	= len,
+		.pin	= pin
+	};
 
-	dentry = file->f_dentry;
-	au_update_dbstart(dentry);
-	inode = dentry->d_inode;
+	au_update_dbstart(cpg.dentry);
+	inode = cpg.dentry->d_inode;
 	h_inode = NULL;
-	if (au_dbstart(dentry) <= bcpup && au_dbend(dentry) >= bcpup) {
-		h_dentry = au_h_dptr(dentry, bcpup);
+	if (au_dbstart(cpg.dentry) <= bcpup
+	    && au_dbend(cpg.dentry) >= bcpup) {
+		h_dentry = au_h_dptr(cpg.dentry, bcpup);
 		if (h_dentry)
 			h_inode = h_dentry->d_inode;
 	}
 	hi_wh = au_hi_wh(inode, bcpup);
 	if (!hi_wh && !h_inode)
-		err = au_sio_cpup_wh(dentry, bcpup, len, file);
+		err = au_sio_cpup_wh(&cpg, file);
 	else
 		/* already copied-up after unlink */
 		err = au_reopen_wh(file, bcpup, hi_wh);
 
 	if (!err
 	    && inode->i_nlink > 1
-	    && au_opt_test(au_mntflags(dentry->d_sb), PLINK))
-		au_plink_append(inode, bcpup, au_h_dptr(dentry, bcpup));
+	    && au_opt_test(au_mntflags(cpg.dentry->d_sb), PLINK))
+		au_plink_append(inode, bcpup, au_h_dptr(cpg.dentry, bcpup));
 
 	return err;
 }
@@ -238,81 +261,80 @@
 int au_ready_to_write(struct file *file, loff_t len, struct au_pin *pin)
 {
 	int err;
-	aufs_bindex_t bstart, bcpup, dbstart;
-	struct dentry *dentry, *parent, *h_dentry;
-	struct inode *h_inode, *inode;
+	aufs_bindex_t dbstart;
+	struct dentry *parent, *h_dentry;
+	struct inode *inode;
 	struct super_block *sb;
 	struct file *h_file;
+	struct au_cp_generic cpg = {
+		.dentry	= file->f_dentry,
+		.bdst	= -1,
+		.bsrc	= -1,
+		.len	= len,
+		.pin	= pin,
+		.flags	= AuCpup_DTIME
+	};
 
-	dentry = file->f_dentry;
-	sb = dentry->d_sb;
-	inode = dentry->d_inode;
+	sb = cpg.dentry->d_sb;
+	inode = cpg.dentry->d_inode;
 	AuDebugOn(au_special_file(inode->i_mode));
-	bstart = au_fbstart(file);
-	err = au_test_ro(sb, bstart, inode);
+	cpg.bsrc = au_fbstart(file);
+	err = au_test_ro(sb, cpg.bsrc, inode);
 	if (!err && (au_hf_top(file)->f_mode & FMODE_WRITE)) {
-		err = au_pin(pin, dentry, bstart, AuOpt_UDBA_NONE, /*flags*/0);
+		err = au_pin(pin, cpg.dentry, cpg.bsrc, AuOpt_UDBA_NONE,
+			     /*flags*/0);
 		goto out;
 	}
 
 	/* need to cpup or reopen */
-	parent = dget_parent(dentry);
+	parent = dget_parent(cpg.dentry);
 	di_write_lock_parent(parent);
-	err = AuWbrCopyup(au_sbi(sb), dentry);
-	bcpup = err;
+	err = AuWbrCopyup(au_sbi(sb), cpg.dentry);
+	cpg.bdst = err;
 	if (unlikely(err < 0))
 		goto out_dgrade;
 	err = 0;
 
-	if (!d_unhashed(dentry) && !au_h_dptr(parent, bcpup)) {
-		err = au_cpup_dirs(dentry, bcpup);
+	if (!d_unhashed(cpg.dentry) && !au_h_dptr(parent, cpg.bdst)) {
+		err = au_cpup_dirs(cpg.dentry, cpg.bdst);
 		if (unlikely(err))
 			goto out_dgrade;
 	}
 
-	err = au_pin(pin, dentry, bcpup, AuOpt_UDBA_NONE,
+	err = au_pin(pin, cpg.dentry, cpg.bdst, AuOpt_UDBA_NONE,
 		     AuPin_DI_LOCKED | AuPin_MNT_WRITE);
 	if (unlikely(err))
 		goto out_dgrade;
 
 	h_dentry = au_hf_top(file)->f_dentry;
-	h_inode = h_dentry->d_inode;
-	dbstart = au_dbstart(dentry);
-	if (dbstart <= bcpup) {
-		h_dentry = au_h_dptr(dentry, bcpup);
+	dbstart = au_dbstart(cpg.dentry);
+	if (dbstart <= cpg.bdst) {
+		h_dentry = au_h_dptr(cpg.dentry, cpg.bdst);
 		AuDebugOn(!h_dentry);
-		h_inode = h_dentry->d_inode;
-		AuDebugOn(!h_inode);
-		bstart = bcpup;
+		cpg.bsrc = cpg.bdst;
 	}
 
-	if (dbstart <= bcpup		/* just reopen */
-	    || !d_unhashed(dentry)	/* copyup and reopen */
+	if (dbstart <= cpg.bdst		/* just reopen */
+	    || !d_unhashed(cpg.dentry)	/* copyup and reopen */
 		) {
-		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
-		h_file = au_h_open_pre(dentry, bstart);
-		if (IS_ERR(h_file)) {
+		h_file = au_h_open_pre(cpg.dentry, cpg.bsrc);
+		if (IS_ERR(h_file))
 			err = PTR_ERR(h_file);
-			h_file = NULL;
-		} else {
+		else {
 			di_downgrade_lock(parent, AuLock_IR);
-			if (dbstart > bcpup)
-				err = au_sio_cpup_simple(dentry, bcpup, len,
-							 AuCpup_DTIME);
+			if (dbstart > cpg.bdst)
+				err = au_sio_cpup_simple(&cpg);
 			if (!err)
 				err = au_reopen_nondir(file);
+			au_h_open_post(cpg.dentry, cpg.bsrc, h_file);
 		}
-		mutex_unlock(&h_inode->i_mutex);
-		au_h_open_post(dentry, bstart, h_file);
 	} else {			/* copyup as wh and reopen */
 		/*
 		 * since writable hfsplus branch is not supported,
 		 * h_open_pre/post() are unnecessary.
 		 */
-		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
-		err = au_ready_to_write_wh(file, len, bcpup);
+		err = au_ready_to_write_wh(file, len, cpg.bdst, pin);
 		di_downgrade_lock(parent, AuLock_IR);
-		mutex_unlock(&h_inode->i_mutex);
 	}
 
 	if (!err) {
@@ -363,29 +385,35 @@
 static int au_file_refresh_by_inode(struct file *file, int *need_reopen)
 {
 	int err;
-	aufs_bindex_t bstart;
 	struct au_pin pin;
 	struct au_finfo *finfo;
-	struct dentry *dentry, *parent, *hi_wh;
+	struct dentry *parent, *hi_wh;
 	struct inode *inode;
 	struct super_block *sb;
+	struct au_cp_generic cpg = {
+		.dentry	= file->f_dentry,
+		.bdst	= -1,
+		.bsrc	= -1,
+		.len	= -1,
+		.pin	= &pin,
+		.flags	= AuCpup_DTIME
+	};
 
 	FiMustWriteLock(file);
 
 	err = 0;
 	finfo = au_fi(file);
-	dentry = file->f_dentry;
-	sb = dentry->d_sb;
-	inode = dentry->d_inode;
-	bstart = au_ibstart(inode);
-	if (bstart == finfo->fi_btop || IS_ROOT(dentry))
+	sb = cpg.dentry->d_sb;
+	inode = cpg.dentry->d_inode;
+	cpg.bdst = au_ibstart(inode);
+	if (cpg.bdst == finfo->fi_btop || IS_ROOT(cpg.dentry))
 		goto out;
 
-	parent = dget_parent(dentry);
-	if (au_test_ro(sb, bstart, inode)) {
+	parent = dget_parent(cpg.dentry);
+	if (au_test_ro(sb, cpg.bdst, inode)) {
 		di_read_lock_parent(parent, !AuLock_IR);
-		err = AuWbrCopyup(au_sbi(sb), dentry);
-		bstart = err;
+		err = AuWbrCopyup(au_sbi(sb), cpg.dentry);
+		cpg.bdst = err;
 		di_read_unlock(parent, !AuLock_IR);
 		if (unlikely(err < 0))
 			goto out_parent;
@@ -393,25 +421,26 @@
 	}
 
 	di_read_lock_parent(parent, AuLock_IR);
-	hi_wh = au_hi_wh(inode, bstart);
+	hi_wh = au_hi_wh(inode, cpg.bdst);
 	if (!S_ISDIR(inode->i_mode)
 	    && au_opt_test(au_mntflags(sb), PLINK)
 	    && au_plink_test(inode)
-	    && !d_unhashed(dentry)) {
-		err = au_test_and_cpup_dirs(dentry, bstart);
+	    && !d_unhashed(cpg.dentry)
+	    && cpg.bdst < au_dbstart(cpg.dentry)) {
+		err = au_test_and_cpup_dirs(cpg.dentry, cpg.bdst);
 		if (unlikely(err))
 			goto out_unlock;
 
 		/* always superio. */
-		err = au_pin(&pin, dentry, bstart, AuOpt_UDBA_NONE,
+		err = au_pin(&pin, cpg.dentry, cpg.bdst, AuOpt_UDBA_NONE,
 			     AuPin_DI_LOCKED | AuPin_MNT_WRITE);
-		if (!err)
-			err = au_sio_cpup_simple(dentry, bstart, -1,
-						 AuCpup_DTIME);
-		au_unpin(&pin);
+		if (!err) {
+			err = au_sio_cpup_simple(&cpg);
+			au_unpin(&pin);
+		}
 	} else if (hi_wh) {
 		/* already copied-up after unlink */
-		err = au_reopen_wh(file, bstart, hi_wh);
+		err = au_reopen_wh(file, cpg.bdst, hi_wh);
 		*need_reopen = 0;
 	}
 
@@ -641,7 +670,7 @@
 static int aufs_releasepage(struct page *page, gfp_t gfp)
 { AuUnsupport(); return 0; }
 static int aufs_migratepage(struct address_space *mapping, struct page *newpage,
-			    struct page *page)
+			    struct page *page, enum migrate_mode mode)
 { AuUnsupport(); return 0; }
 static int aufs_launder_page(struct page *page)
 { AuUnsupport(); return 0; }
diff -ru --new-file linux-3.x-orig/fs/aufs/file.h linux-3.x/fs/aufs/file.h
--- linux-3.x-orig/fs/aufs/file.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/file.h	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,7 +28,6 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/poll.h>
-#include <linux/aufs_type.h>
 #include "rwsem.h"
 
 struct au_branch;
@@ -228,7 +227,7 @@
 {
 	if (atomic_inc_return(&au_fi(f)->fi_mmapped))
 		return;
-	pr_warning("fi_mmapped wrapped around\n");
+	pr_warn("fi_mmapped wrapped around\n");
 	while (!atomic_inc_return(&au_fi(f)->fi_mmapped))
 		;
 }
@@ -248,9 +247,12 @@
 static inline void au_do_vm_file_reset(struct vm_area_struct *vma,
 				       struct file *file)
 {
-	fput(vma->vm_file);
+	struct file *f;
+
+	f = vma->vm_file;
 	get_file(file);
 	vma->vm_file = file;
+	fput(f);
 }
 
 #ifdef CONFIG_MMU
@@ -268,10 +270,13 @@
 static inline void au_vm_file_reset(struct vm_area_struct *vma,
 				    struct file *file)
 {
+	struct file *f;
+
 	au_do_vm_file_reset(vma, file);
-	fput(vma->vm_region->vm_file);
+	f = vma->vm_region->vm_file;
 	get_file(file);
 	vma->vm_region->vm_file = file;
+	fput(f);
 }
 #endif /* CONFIG_MMU */
 
@@ -279,14 +284,12 @@
 static inline void au_vm_prfile_set(struct vm_area_struct *vma,
 				    struct file *file)
 {
-#ifdef CONFIG_AUFS_PROC_MAP
 	get_file(file);
 	vma->vm_prfile = file;
 #ifndef CONFIG_MMU
 	get_file(file);
 	vma->vm_region->vm_prfile = file;
 #endif
-#endif
 }
 
 #endif /* __KERNEL__ */
diff -ru --new-file linux-3.x-orig/fs/aufs/finfo.c linux-3.x/fs/aufs/finfo.c
--- linux-3.x-orig/fs/aufs/finfo.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/finfo.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,7 +20,6 @@
  * file private data
  */
 
-#include <linux/file.h>
 #include "aufs.h"
 
 void au_hfput(struct au_hfile *hf, struct file *file)
@@ -140,6 +139,11 @@
 
 	err = 0;
 	au_nfiles_inc(dentry->d_sb);
+	/* verbose coding for lock class name */
+	if (!fidir)
+		au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcNonDir_FIINFO);
+	else
+		au_rw_class(&finfo->fi_rwsem, au_lc_key + AuLcDir_FIINFO);
 	au_rw_write_lock(&finfo->fi_rwsem);
 	finfo->fi_btop = -1;
 	finfo->fi_hdir = fidir;
diff -ru --new-file linux-3.x-orig/fs/aufs/f_op.c linux-3.x/fs/aufs/f_op.c
--- linux-3.x-orig/fs/aufs/f_op.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/f_op.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,10 +20,8 @@
  * file and vm operations
  */
 
-#include <linux/file.h>
 #include <linux/fs_stack.h>
 #include <linux/mman.h>
-#include <linux/mm.h>
 #include <linux/security.h>
 #include "aufs.h"
 
@@ -115,6 +113,13 @@
 }
 
 /* ---------------------------------------------------------------------- */
+/*
+ * read and write functions acquire [fdi]_rwsem once, but release before
+ * mmap_sem. This is because to stop a race condition between mmap(2).
+ * Releasing these aufs-rwsem should be safe, no branch-mamagement (by keeping
+ * si_rwsem), no harmful copy-up should happen. Actually copy-up may happen in
+ * read functions after [fdi]_rwsem are released, but it should be harmless.
+ */
 
 static ssize_t aufs_read(struct file *file, char __user *buf, size_t count,
 			 loff_t *ppos)
@@ -132,13 +137,18 @@
 		goto out;
 
 	h_file = au_hf_top(file);
+	get_file(h_file);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
+	/* filedata may be obsoleted by concurrent copyup, but no problem */
 	err = vfsub_read_u(h_file, buf, count, ppos);
 	/* todo: necessary? */
 	/* file->f_ra = h_file->f_ra; */
+	/* update without lock, I don't think it a problem */
 	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
+	fput(h_file);
 
-	di_read_unlock(dentry, AuLock_IR);
-	fi_read_unlock(file);
 out:
 	si_read_unlock(sb);
 	return err;
@@ -172,11 +182,13 @@
 	ssize_t err;
 	struct au_pin pin;
 	struct dentry *dentry;
+	struct super_block *sb;
 	struct inode *inode;
 	struct file *h_file;
 	char __user *buf = (char __user *)ubuf;
 
 	dentry = file->f_dentry;
+	sb = dentry->d_sb;
 	inode = dentry->d_inode;
 	au_mtx_and_read_lock(inode);
 
@@ -186,20 +198,27 @@
 
 	err = au_ready_to_write(file, -1, &pin);
 	di_downgrade_lock(dentry, AuLock_IR);
-	if (unlikely(err))
-		goto out_unlock;
+	if (unlikely(err)) {
+		di_read_unlock(dentry, AuLock_IR);
+		fi_write_unlock(file);
+		goto out;
+	}
 
 	h_file = au_hf_top(file);
+	get_file(h_file);
 	au_unpin(&pin);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+
 	err = vfsub_write_u(h_file, buf, count, ppos);
+	ii_write_lock_child(inode);
 	au_cpup_attr_timesizes(inode);
 	inode->i_mode = h_file->f_dentry->d_inode->i_mode;
+	ii_write_unlock(inode);
+	fput(h_file);
 
-out_unlock:
-	di_read_unlock(dentry, AuLock_IR);
-	fi_write_unlock(file);
 out:
-	si_read_unlock(inode->i_sb);
+	si_read_unlock(sb);
 	mutex_unlock(&inode->i_mutex);
 	return err;
 }
@@ -254,12 +273,16 @@
 		goto out;
 
 	h_file = au_hf_top(file);
+	get_file(h_file);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
 	err = au_do_aio(h_file, MAY_READ, kio, iov, nv, pos);
 	/* todo: necessary? */
 	/* file->f_ra = h_file->f_ra; */
+	/* update without lock, I don't think it a problem */
 	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
-	di_read_unlock(dentry, AuLock_IR);
-	fi_read_unlock(file);
+	fput(h_file);
 
 out:
 	si_read_unlock(sb);
@@ -274,9 +297,11 @@
 	struct dentry *dentry;
 	struct inode *inode;
 	struct file *file, *h_file;
+	struct super_block *sb;
 
 	file = kio->ki_filp;
 	dentry = file->f_dentry;
+	sb = dentry->d_sb;
 	inode = dentry->d_inode;
 	au_mtx_and_read_lock(inode);
 
@@ -286,20 +311,27 @@
 
 	err = au_ready_to_write(file, -1, &pin);
 	di_downgrade_lock(dentry, AuLock_IR);
-	if (unlikely(err))
-		goto out_unlock;
+	if (unlikely(err)) {
+		di_read_unlock(dentry, AuLock_IR);
+		fi_write_unlock(file);
+		goto out;
+	}
 
-	au_unpin(&pin);
 	h_file = au_hf_top(file);
+	get_file(h_file);
+	au_unpin(&pin);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+
 	err = au_do_aio(h_file, MAY_WRITE, kio, iov, nv, pos);
+	ii_write_lock_child(inode);
 	au_cpup_attr_timesizes(inode);
 	inode->i_mode = h_file->f_dentry->d_inode->i_mode;
+	ii_write_unlock(inode);
+	fput(h_file);
 
-out_unlock:
-	di_read_unlock(dentry, AuLock_IR);
-	fi_write_unlock(file);
 out:
-	si_read_unlock(inode->i_sb);
+	si_read_unlock(sb);
 	mutex_unlock(&inode->i_mutex);
 	return err;
 }
@@ -322,17 +354,23 @@
 
 	err = -EINVAL;
 	h_file = au_hf_top(file);
+	get_file(h_file);
 	if (au_test_loopback_kthread()) {
-		file->f_mapping = h_file->f_mapping;
-		smp_mb(); /* unnecessary? */
+		au_warn_loopback(h_file->f_dentry->d_sb);
+		if (file->f_mapping != h_file->f_mapping) {
+			file->f_mapping = h_file->f_mapping;
+			smp_mb(); /* unnecessary? */
+		}
 	}
+	di_read_unlock(dentry, AuLock_IR);
+	fi_read_unlock(file);
+
 	err = vfsub_splice_to(h_file, ppos, pipe, len, flags);
 	/* todo: necessasry? */
 	/* file->f_ra = h_file->f_ra; */
+	/* update without lock, I don't think it a problem */
 	fsstack_copy_attr_atime(dentry->d_inode, h_file->f_dentry->d_inode);
-
-	di_read_unlock(dentry, AuLock_IR);
-	fi_read_unlock(file);
+	fput(h_file);
 
 out:
 	si_read_unlock(sb);
@@ -348,36 +386,65 @@
 	struct dentry *dentry;
 	struct inode *inode;
 	struct file *h_file;
+	struct super_block *sb;
 
 	dentry = file->f_dentry;
+	sb = dentry->d_sb;
 	inode = dentry->d_inode;
 	au_mtx_and_read_lock(inode);
+
 	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/1);
 	if (unlikely(err))
 		goto out;
 
 	err = au_ready_to_write(file, -1, &pin);
 	di_downgrade_lock(dentry, AuLock_IR);
-	if (unlikely(err))
-		goto out_unlock;
+	if (unlikely(err)) {
+		di_read_unlock(dentry, AuLock_IR);
+		fi_write_unlock(file);
+		goto out;
+	}
 
 	h_file = au_hf_top(file);
+	get_file(h_file);
 	au_unpin(&pin);
+	di_read_unlock(dentry, AuLock_IR);
+	fi_write_unlock(file);
+
 	err = vfsub_splice_from(pipe, h_file, ppos, len, flags);
+	ii_write_lock_child(inode);
 	au_cpup_attr_timesizes(inode);
 	inode->i_mode = h_file->f_dentry->d_inode->i_mode;
+	ii_write_unlock(inode);
+	fput(h_file);
 
-out_unlock:
-	di_read_unlock(dentry, AuLock_IR);
-	fi_write_unlock(file);
 out:
-	si_read_unlock(inode->i_sb);
+	si_read_unlock(sb);
 	mutex_unlock(&inode->i_mutex);
 	return err;
 }
 
 /* ---------------------------------------------------------------------- */
 
+/*
+ * The locking order around current->mmap_sem.
+ * - in most and regular cases
+ *   file I/O syscall -- aufs_read() or something
+ *	-- si_rwsem for read -- mmap_sem
+ *	(Note that [fdi]i_rwsem are released before mmap_sem).
+ * - in mmap case
+ *   mmap(2) -- mmap_sem -- aufs_mmap() -- si_rwsem for read -- [fdi]i_rwsem
+ * This AB-BA order is definitly bad, but is not a problem since "si_rwsem for
+ * read" allows muliple processes to acquire it and [fdi]i_rwsem are not held in
+ * file I/O. Aufs needs to stop lockdep in aufs_mmap() though.
+ * It means that when aufs acquires si_rwsem for write, the process should never
+ * acquire mmap_sem.
+ *
+ * Actually aufs_readdir() holds [fdi]i_rwsem before mmap_sem, but this is not a
+ * problem either since any directory is not able to be mmap-ed.
+ * The similar scenario is applied to aufs_readlink() too.
+ */
+
 /* cf. linux/include/linux/mman.h: calc_vm_prot_bits() */
 #define AuConv_VM_PROT(f, b)	_calc_vm_trans(f, VM_##b, PROT_##b)
 
@@ -412,124 +479,81 @@
 		| AuConv_VM_MAP(flags, EXECUTABLE)
 		| AuConv_VM_MAP(flags, LOCKED);
 }
-/*
- * This is another ugly approach to keep the lock order, particularly
- * mm->mmap_sem and aufs rwsem. The previous approach was reverted and you can
- * find it in git-log, if you want.
- *
- * native readdir: i_mutex, copy_to_user, mmap_sem
- * aufs readdir: i_mutex, rwsem, nested-i_mutex, copy_to_user, mmap_sem
- *
- * Before aufs_mmap() mmap_sem is acquired already, but aufs_mmap() has to
- * acquire aufs rwsem. It introduces a circular locking dependency.
- * To address this problem, aufs_mmap() delegates the part which requires aufs
- * rwsem to its internal workqueue.
- */
-
-struct au_mmap_pre_args {
-	/* input */
-	struct file *file;
-	struct vm_area_struct *vma;
-
-	/* output */
-	int *errp;
-	struct file *h_file;
-	struct au_branch *br;
-};
 
-static int au_mmap_pre(struct file *file, struct vm_area_struct *vma,
-		       struct file **h_file, struct au_branch **br)
+static int aufs_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	int err;
+	unsigned long prot;
 	aufs_bindex_t bstart;
 	const unsigned char wlock
-		= !!(file->f_mode & FMODE_WRITE) && (vma->vm_flags & VM_SHARED);
+		= (file->f_mode & FMODE_WRITE) && (vma->vm_flags & VM_SHARED);
 	struct dentry *dentry;
 	struct super_block *sb;
+	struct file *h_file;
+	struct au_branch *br;
+	struct au_pin pin;
+
+	AuDbgVmRegion(file, vma);
 
 	dentry = file->f_dentry;
 	sb = dentry->d_sb;
+	lockdep_off();
 	si_read_lock(sb, AuLock_NOPLMW);
 	err = au_reval_and_lock_fdi(file, au_reopen_nondir, /*wlock*/1);
 	if (unlikely(err))
 		goto out;
 
 	if (wlock) {
-		struct au_pin pin;
-
 		err = au_ready_to_write(file, -1, &pin);
 		di_write_unlock(dentry);
-		if (unlikely(err))
-			goto out_unlock;
+		if (unlikely(err)) {
+			fi_write_unlock(file);
+			goto out;
+		}
 		au_unpin(&pin);
 	} else
 		di_write_unlock(dentry);
+
 	bstart = au_fbstart(file);
-	*br = au_sbr(sb, bstart);
-	*h_file = au_hf_top(file);
-	get_file(*h_file);
+	br = au_sbr(sb, bstart);
+	h_file = au_hf_top(file);
+	get_file(h_file);
 	au_set_mmapped(file);
-
-out_unlock:
 	fi_write_unlock(file);
-out:
-	si_read_unlock(sb);
-	return err;
-}
+	lockdep_on();
 
-static void au_call_mmap_pre(void *args)
-{
-	struct au_mmap_pre_args *a = args;
-	*a->errp = au_mmap_pre(a->file, a->vma, &a->h_file, &a->br);
-}
-
-static int aufs_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	int err, wkq_err;
-	unsigned long prot;
-	struct au_mmap_pre_args args = {
-		.file		= file,
-		.vma		= vma,
-		.errp		= &err
-	};
-
-	AuDbgVmRegion(file, vma);
-	wkq_err = au_wkq_wait_pre(au_call_mmap_pre, &args);
-	if (unlikely(wkq_err))
-		err = wkq_err;
-	if (unlikely(err))
-		goto out;
-
-	au_vm_file_reset(vma, args.h_file);
+	au_vm_file_reset(vma, h_file);
 	prot = au_prot_conv(vma->vm_flags);
-	err = security_file_mmap(args.h_file, /*reqprot*/prot, prot,
+	err = security_file_mmap(h_file, /*reqprot*/prot, prot,
 				 au_flag_conv(vma->vm_flags), vma->vm_start, 0);
-	if (unlikely(err))
-		goto out_reset;
-
-	err = args.h_file->f_op->mmap(args.h_file, vma);
+	if (!err)
+		err = h_file->f_op->mmap(h_file, vma);
 	if (unlikely(err))
 		goto out_reset;
 
 	au_vm_prfile_set(vma, file);
-	vfsub_file_accessed(args.h_file);
 	/* update without lock, I don't think it a problem */
 	fsstack_copy_attr_atime(file->f_dentry->d_inode,
-				args.h_file->f_dentry->d_inode);
+				h_file->f_dentry->d_inode);
 	goto out_fput; /* success */
 
 out_reset:
 	au_unset_mmapped(file);
 	au_vm_file_reset(vma, file);
 out_fput:
-	fput(args.h_file);
+	fput(h_file);
+	lockdep_off();
 out:
+	si_read_unlock(sb);
+	lockdep_on();
+	AuTraceErr(err);
 	return err;
 }
 
 /* ---------------------------------------------------------------------- */
 
-static int aufs_fsync_nondir(struct file *file, int datasync)
+static int aufs_fsync_nondir(struct file *file, loff_t start, loff_t end,
+			     int datasync)
 {
 	int err;
 	struct au_pin pin;
@@ -540,14 +564,8 @@
 
 	dentry = file->f_dentry;
 	inode = dentry->d_inode;
-	IMustLock(file->f_mapping->host);
-	if (inode != file->f_mapping->host) {
-		mutex_unlock(&file->f_mapping->host->i_mutex);
-		mutex_lock(&inode->i_mutex);
-	}
-	IMustLock(inode);
-
 	sb = dentry->d_sb;
+	mutex_lock(&inode->i_mutex);
 	err = si_read_lock(sb, AuLock_FLUSH | AuLock_NOPLM);
 	if (unlikely(err))
 		goto out;
@@ -567,22 +585,8 @@
 
 	err = -EINVAL;
 	h_file = au_hf_top(file);
-	if (h_file->f_op && h_file->f_op->fsync) {
-		struct mutex *h_mtx;
-
-		/*
-		 * no filemap_fdatawrite() since aufs file has no its own
-		 * mapping, but dir.
-		 */
-		h_mtx = &h_file->f_dentry->d_inode->i_mutex;
-		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
-		err = h_file->f_op->fsync(h_file, datasync);
-		if (!err)
-			vfsub_update_h_iattr(&h_file->f_path, /*did*/NULL);
-		/*ignore*/
-		au_cpup_attr_timesizes(inode);
-		mutex_unlock(h_mtx);
-	}
+	err = vfsub_fsync(h_file, &h_file->f_path, datasync);
+	au_cpup_attr_timesizes(inode);
 
 out_unlock:
 	di_read_unlock(dentry, AuLock_IR);
@@ -590,10 +594,7 @@
 out_si:
 	si_read_unlock(sb);
 out:
-	if (inode != file->f_mapping->host) {
-		mutex_unlock(&inode->i_mutex);
-		mutex_lock(&file->f_mapping->host->i_mutex);
-	}
+	mutex_unlock(&inode->i_mutex);
 	return err;
 }
 
@@ -697,12 +698,7 @@
 
 const struct file_operations aufs_file_fop = {
 	.owner		= THIS_MODULE,
-	/*
-	 * while generic_file_llseek/_unlocked() don't use BKL,
-	 * don't use it since it operates file->f_mapping->host.
-	 * in aufs, it may be a real file and may confuse users by UDBA.
-	 */
-	/* .llseek		= generic_file_llseek, */
+
 	.llseek		= default_llseek,
 
 	.read		= aufs_read,
diff -ru --new-file linux-3.x-orig/fs/aufs/f_op_sp.c linux-3.x/fs/aufs/f_op_sp.c
--- linux-3.x-orig/fs/aufs/f_op_sp.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/f_op_sp.c	2014-12-23 17:23:09.035087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,7 +22,6 @@
  * their file I/O is handled out of aufs.
  */
 
-#include <linux/fs_stack.h>
 #include "aufs.h"
 
 static ssize_t aufs_aio_read_sp(struct kiocb *kio, const struct iovec *iov,
@@ -178,12 +177,19 @@
 static int au_cpup_sp(struct dentry *dentry)
 {
 	int err;
-	aufs_bindex_t bcpup;
 	struct au_pin pin;
 	struct au_wr_dir_args wr_dir_args = {
 		.force_btgt	= -1,
 		.flags		= 0
 	};
+	struct au_cp_generic cpg = {
+		.dentry	= dentry,
+		.bdst	= -1,
+		.bsrc	= -1,
+		.len	= -1,
+		.pin	= &pin,
+		.flags	= AuCpup_DTIME
+	};
 
 	AuDbg("%.*s\n", AuDLNPair(dentry));
 
@@ -192,15 +198,15 @@
 	err = au_wr_dir(dentry, /*src_dentry*/NULL, &wr_dir_args);
 	if (unlikely(err < 0))
 		goto out;
-	bcpup = err;
+	cpg.bdst = err;
 	err = 0;
-	if (bcpup == au_dbstart(dentry))
+	if (cpg.bdst == au_dbstart(dentry))
 		goto out; /* success */
 
-	err = au_pin(&pin, dentry, bcpup, au_opt_udba(dentry->d_sb),
+	err = au_pin(&pin, dentry, cpg.bdst, au_opt_udba(dentry->d_sb),
 		     AuPin_MNT_WRITE);
 	if (!err) {
-		err = au_sio_cpup_simple(dentry, bcpup, -1, AuCpup_DTIME);
+		err = au_sio_cpup_simple(&cpg);
 		au_unpin(&pin);
 	}
 
diff -ru --new-file linux-3.x-orig/fs/aufs/fstype.h linux-3.x/fs/aufs/fstype.h
--- linux-3.x-orig/fs/aufs/fstype.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/fstype.h	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,7 +28,6 @@
 #include <linux/fs.h>
 #include <linux/magic.h>
 #include <linux/romfs_fs.h>
-#include <linux/aufs_type.h>
 
 static inline int au_test_aufs(struct super_block *sb)
 {
@@ -111,15 +110,6 @@
 #endif
 }
 
-static inline int au_test_smbfs(struct super_block *sb __maybe_unused)
-{
-#if defined(CONFIG_SMB_FS) || defined(CONFIG_SMB_FS_MODULE)
-	return sb->s_magic == SMB_SUPER_MAGIC;
-#else
-	return 0;
-#endif
-}
-
 static inline int au_test_ocfs2(struct super_block *sb __maybe_unused)
 {
 #if defined(CONFIG_OCFS2_FS) || defined(CONFIG_OCFS2_FS_MODULE)
@@ -158,7 +148,7 @@
 
 static inline int au_test_ext4(struct super_block *sb __maybe_unused)
 {
-#if defined(CONFIG_EXT4DEV_FS) || defined(CONFIG_EXT4DEV_FS_MODULE)
+#if defined(CONFIG_EXT4_FS) || defined(CONFIG_EXT4_FS_MODULE)
 	return sb->s_magic == EXT4_SUPER_MAGIC;
 #else
 	return 0;
@@ -376,7 +366,6 @@
 {
 	return au_test_nfs(sb)
 		|| au_test_fuse(sb)
-		/* || au_test_smbfs(sb) */	/* untested */
 		/* || au_test_ocfs2(sb) */	/* untested */
 		/* || au_test_btrfs(sb) */	/* untested */
 		/* || au_test_coda(sb) */	/* untested */
diff -ru --new-file linux-3.x-orig/fs/aufs/hfsnotify.c linux-3.x/fs/aufs/hfsnotify.c
--- linux-3.x-orig/fs/aufs/hfsnotify.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/hfsnotify.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,15 +26,17 @@
 static const __u32 AuHfsnMask = (FS_MOVED_TO | FS_MOVED_FROM | FS_DELETE
 				 | FS_CREATE | FS_EVENT_ON_CHILD);
 static DECLARE_WAIT_QUEUE_HEAD(au_hfsn_wq);
+static __cacheline_aligned_in_smp atomic64_t au_hfsn_ifree = ATOMIC64_INIT(0);
 
 static void au_hfsn_free_mark(struct fsnotify_mark *mark)
 {
 	struct au_hnotify *hn = container_of(mark, struct au_hnotify,
 					     hn_mark);
 	AuDbg("here\n");
-	hn->hn_mark_dead = 1;
-	smp_mb();
-	wake_up_all(&au_hfsn_wq);
+	au_cache_free_hnotify(hn);
+	smp_mb__before_atomic_dec();
+	atomic64_dec(&au_hfsn_ifree);
+	wake_up(&au_hfsn_wq);
 }
 
 static int au_hfsn_alloc(struct au_hinode *hinode)
@@ -49,7 +51,6 @@
 	sb = hn->hn_aufs_inode->i_sb;
 	bindex = au_br_index(sb, hinode->hi_id);
 	br = au_sbr(sb, bindex);
-	hn->hn_mark_dead = 0;
 	mark = &hn->hn_mark;
 	fsnotify_init_mark(mark, au_hfsn_free_mark);
 	mark->mask = AuHfsnMask;
@@ -61,18 +62,20 @@
 				 /*mnt*/NULL, /*allow_dups*/1);
 }
 
-static void au_hfsn_free(struct au_hinode *hinode)
+static int au_hfsn_free(struct au_hinode *hinode, struct au_hnotify *hn)
 {
-	struct au_hnotify *hn;
 	struct fsnotify_mark *mark;
+	unsigned long long ull;
+
+	ull = atomic64_inc_return(&au_hfsn_ifree);
+	BUG_ON(!ull);
 
-	hn = hinode->hi_notify;
 	mark = &hn->hn_mark;
 	fsnotify_destroy_mark(mark);
 	fsnotify_put_mark(mark);
 
-	/* TODO: bad approach */
-	wait_event(au_hfsn_wq, hn->hn_mark_dead);
+	/* free hn by myself */
+	return 0;
 }
 
 /* ---------------------------------------------------------------------- */
@@ -101,8 +104,11 @@
 static char *au_hfsn_name(u32 mask)
 {
 #ifdef CONFIG_AUFS_DEBUG
-#define test_ret(flag)	if (mask & flag) \
-				return #flag;
+#define test_ret(flag)				\
+	do {					\
+		if (mask & flag)		\
+			return #flag;		\
+	} while (0)
 	test_ret(FS_ACCESS);
 	test_ret(FS_MODIFY);
 	test_ret(FS_ATTRIB);
@@ -157,7 +163,7 @@
 	h_dir = event->to_tell;
 	h_inode = event->inode;
 #ifdef AuDbgHnotify
-	au_debug(1);
+	au_debug_on();
 	if (1 || h_child_qstr.len != sizeof(AUFS_XINO_FNAME) - 1
 	    || strncmp(h_child_qstr.name, AUFS_XINO_FNAME, h_child_qstr.len)) {
 		AuDbg("i%lu, mask 0x%x %s, hcname %.*s, hi%lu\n",
@@ -165,7 +171,7 @@
 		      AuLNPair(&h_child_qstr), h_inode ? h_inode->i_ino : 0);
 		/* WARN_ON(1); */
 	}
-	au_debug(0);
+	au_debug_off();
 #endif
 
 	AuDebugOn(!inode_mark);
@@ -236,11 +242,21 @@
 	return err;
 }
 
+/* ---------------------------------------------------------------------- */
+
+static void au_hfsn_fin(void)
+{
+	AuDbg("au_hfsn_ifree %lld\n", (long long)atomic64_read(&au_hfsn_ifree));
+	wait_event(au_hfsn_wq, !atomic64_read(&au_hfsn_ifree));
+}
+
 const struct au_hnotify_op au_hnotify_op = {
 	.ctl		= au_hfsn_ctl,
 	.alloc		= au_hfsn_alloc,
 	.free		= au_hfsn_free,
 
+	.fin		= au_hfsn_fin,
+
 	.reset_br	= au_hfsn_reset_br,
 	.fin_br		= au_hfsn_fin_br,
 	.init_br	= au_hfsn_init_br
diff -ru --new-file linux-3.x-orig/fs/aufs/hfsplus.c linux-3.x/fs/aufs/hfsplus.c
--- linux-3.x-orig/fs/aufs/hfsplus.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/hfsplus.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Junjiro R. Okajima
+ * Copyright (C) 2010-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
  * and au_h_open_post() after releasing it.
  */
 
-#include <linux/file.h>
 #include "aufs.h"
 
 struct file *au_h_open_pre(struct dentry *dentry, aufs_bindex_t bindex)
@@ -37,7 +36,6 @@
 	h_dentry = au_h_dptr(dentry, bindex);
 	AuDebugOn(!h_dentry);
 	AuDebugOn(!h_dentry->d_inode);
-	IMustLock(h_dentry->d_inode);
 
 	h_file = NULL;
 	if (au_test_hfsplus(h_dentry->d_sb)
diff -ru --new-file linux-3.x-orig/fs/aufs/hnotify.c linux-3.x/fs/aufs/hnotify.c
--- linux-3.x-orig/fs/aufs/hnotify.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/hnotify.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,9 +58,9 @@
 
 	hn = hinode->hi_notify;
 	if (hn) {
-		au_hnotify_op.free(hinode);
-		au_cache_free_hnotify(hn);
 		hinode->hi_notify = NULL;
+		if (au_hnotify_op.free(hinode, hn))
+			au_cache_free_hnotify(hn);
 	}
 }
 
@@ -108,7 +108,7 @@
 
 	err = 0;
 	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
-		pr_warning("branch root dir was changed\n");
+		pr_warn("branch root dir was changed\n");
 		goto out;
 	}
 
@@ -203,7 +203,7 @@
 
 	err = 1;
 	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
-		pr_warning("branch root dir was changed\n");
+		pr_warn("branch root dir was changed\n");
 		err = 0;
 		goto out;
 	}
@@ -259,7 +259,7 @@
 	if (IS_ROOT(dentry)
 	    /* || (inode && inode->i_ino == AUFS_ROOT_INO) */
 		) {
-		pr_warning("branch root dir was changed\n");
+		pr_warn("branch root dir was changed\n");
 		return 0;
 	}
 
@@ -358,8 +358,8 @@
 	if (au_ftest_hnjob(a->flags, MNTPNT)
 	    && a->dentry
 	    && d_mountpoint(a->dentry))
-		pr_warning("mount-point %.*s is removed or renamed\n",
-			   AuDLNPair(a->dentry));
+		pr_warn("mount-point %.*s is removed or renamed\n",
+			AuDLNPair(a->dentry));
 
 	return 0;
 }
@@ -421,7 +421,7 @@
 		goto out;
 
 	if (unlikely(inode->i_ino == AUFS_ROOT_INO)) {
-		pr_warning("wrong root branch\n");
+		pr_warn("wrong root branch\n");
 		iput(inode);
 		inode = NULL;
 		goto out;
@@ -545,7 +545,7 @@
 	       struct qstr *h_child_qstr, struct inode *h_child_inode)
 {
 	int err, len;
-	unsigned int flags[AuHnLast];
+	unsigned int flags[AuHnLast], f;
 	unsigned char isdir, isroot, wh;
 	struct inode *dir;
 	struct au_hnotify_args *args;
@@ -631,7 +631,10 @@
 		p[len] = 0;
 	}
 
-	err = au_wkq_nowait(au_hn_bh, args, dir->i_sb);
+	f = 0;
+	if (!dir->i_nlink)
+		f = AuWkq_NEST;
+	err = au_wkq_nowait(au_hn_bh, args, dir->i_sb, f);
 	if (unlikely(err)) {
 		pr_err("wkq %d\n", err);
 		iput(args->h_child_inode);
diff -ru --new-file linux-3.x-orig/fs/aufs/iinfo.c linux-3.x/fs/aufs/iinfo.c
--- linux-3.x-orig/fs/aufs/iinfo.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/iinfo.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -110,10 +110,22 @@
 	hinode->hi_whdentry = h_wh;
 }
 
-void au_update_iigen(struct inode *inode)
+void au_update_iigen(struct inode *inode, int half)
 {
-	atomic_set(&au_ii(inode)->ii_generation, au_sigen(inode->i_sb));
-	/* smp_mb(); */ /* atomic_set */
+	struct au_iinfo *iinfo;
+	struct au_iigen *iigen;
+	unsigned int sigen;
+
+	sigen = au_sigen(inode->i_sb);
+	iinfo = au_ii(inode);
+	iigen = &iinfo->ii_generation;
+	spin_lock(&iinfo->ii_genspin);
+	iigen->ig_generation = sigen;
+	if (half)
+		au_ig_fset(iigen->ig_flags, HALF_REFRESHED);
+	else
+		au_ig_fclr(iigen->ig_flags, HALF_REFRESHED);
+	spin_unlock(&iinfo->ii_genspin);
 }
 
 /* it may be called at remount time, too */
@@ -164,6 +176,7 @@
 	struct au_iinfo *iinfo = &c->iinfo;
 	static struct lock_class_key aufs_ii;
 
+	spin_lock_init(&iinfo->ii_genspin);
 	au_rw_init(&iinfo->ii_rwsem);
 	au_rw_class(&iinfo->ii_rwsem, &aufs_ii);
 	inode_init_once(&c->vfs_inode);
@@ -186,8 +199,7 @@
 		for (i = 0; i < nbr; i++)
 			iinfo->ii_hinode[i].hi_id = -1;
 
-		atomic_set(&iinfo->ii_generation, au_sigen(sb));
-		/* smp_mb(); */ /* atomic_set */
+		iinfo->ii_generation.ig_generation = au_sigen(sb);
 		iinfo->ii_bstart = -1;
 		iinfo->ii_bend = -1;
 		iinfo->ii_vdir = NULL;
diff -ru --new-file linux-3.x-orig/fs/aufs/inode.c linux-3.x/fs/aufs/inode.c
--- linux-3.x-orig/fs/aufs/inode.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/inode.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -34,7 +34,7 @@
 static void au_refresh_hinode_attr(struct inode *inode, int do_version)
 {
 	au_cpup_attr_all(inode, /*force*/0);
-	au_update_iigen(inode);
+	au_update_iigen(inode, /*half*/1);
 	if (do_version)
 		inode->i_version++;
 }
@@ -253,6 +253,8 @@
 static int reval_inode(struct inode *inode, struct dentry *dentry)
 {
 	int err;
+	unsigned int gen;
+	struct au_iigen iigen;
 	aufs_bindex_t bindex, bend;
 	struct inode *h_inode, *h_dinode;
 
@@ -271,12 +273,20 @@
 	bend = au_ibend(inode);
 	for (bindex = au_ibstart(inode); bindex <= bend; bindex++) {
 		h_inode = au_h_iptr(inode, bindex);
-		if (h_inode && h_inode == h_dinode) {
-			err = 0;
-			if (au_iigen_test(inode, au_digen(dentry)))
-				err = au_refresh_hinode(inode, dentry);
+		if (!h_inode || h_inode != h_dinode)
+			continue;
+
+		err = 0;
+		gen = au_iigen(inode, &iigen);
+		if (gen == au_digen(dentry)
+		    && !au_ig_ftest(iigen.ig_flags, HALF_REFRESHED))
 			break;
-		}
+
+		/* fully refresh inode using dentry */
+		err = au_refresh_hinode(inode, dentry);
+		if (!err)
+			au_update_iigen(inode, /*half*/0);
+		break;
 	}
 
 	if (unlikely(err))
@@ -367,6 +377,17 @@
 
 	AuDbg("%lx, new %d\n", inode->i_state, !!(inode->i_state & I_NEW));
 	if (inode->i_state & I_NEW) {
+		/* verbose coding for lock class name */
+		if (unlikely(S_ISLNK(h_inode->i_mode)))
+			au_rw_class(&au_ii(inode)->ii_rwsem,
+				    au_lc_key + AuLcSymlink_IIINFO);
+		else if (unlikely(S_ISDIR(h_inode->i_mode)))
+			au_rw_class(&au_ii(inode)->ii_rwsem,
+				    au_lc_key + AuLcDir_IIINFO);
+		else /* likely */
+			au_rw_class(&au_ii(inode)->ii_rwsem,
+				    au_lc_key + AuLcNonDir_IIINFO);
+
 		ii_write_lock_new_child(inode);
 		err = set_inode(inode, dentry);
 		if (!err) {
diff -ru --new-file linux-3.x-orig/fs/aufs/inode.h linux-3.x/fs/aufs/inode.h
--- linux-3.x-orig/fs/aufs/inode.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/inode.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,9 +25,7 @@
 
 #ifdef __KERNEL__
 
-#include <linux/fs.h>
 #include <linux/fsnotify.h>
-#include <linux/aufs_type.h>
 #include "rwsem.h"
 
 struct vfsmount;
@@ -37,7 +35,6 @@
 #ifdef CONFIG_AUFS_HFSNOTIFY
 	/* never use fsnotify_add_vfsmount_mark() */
 	struct fsnotify_mark		hn_mark;
-	int				hn_mark_dead;
 #endif
 	struct inode			*hn_aufs_inode;	/* no get/put */
 #endif
@@ -54,9 +51,22 @@
 	struct dentry		*hi_whdentry;
 };
 
+/* ig_flags */
+#define AuIG_HALF_REFRESHED		1
+#define au_ig_ftest(flags, name)	((flags) & AuIG_##name)
+#define au_ig_fset(flags, name) \
+	do { (flags) |= AuIG_##name; } while (0)
+#define au_ig_fclr(flags, name) \
+	do { (flags) &= ~AuIG_##name; } while (0)
+
+struct au_iigen {
+	__u32		ig_generation, ig_flags;
+};
+
 struct au_vdir;
 struct au_iinfo {
-	atomic_t		ii_generation;
+	spinlock_t		ii_genspin;
+	struct au_iigen		ii_generation;
 	struct super_block	*ii_hsb1;	/* no get/put */
 
 	struct au_rwsem		ii_rwsem;
@@ -91,8 +101,19 @@
 	struct dentry *parent;
 	struct au_hinode *hdir;
 	struct vfsmount *h_mnt;
+
+	/* temporary unlock/relock for copyup */
+	struct dentry *h_dentry, *h_parent;
+	struct au_branch *br;
+	struct task_struct *task;
 };
 
+void au_pin_hdir_unlock(struct au_pin *p);
+int au_pin_hdir_relock(struct au_pin *p);
+void au_pin_hdir_set_owner(struct au_pin *p, struct task_struct *task);
+void au_pin_hdir_acquire_nest(struct au_pin *p);
+void au_pin_hdir_release(struct au_pin *p);
+
 /* ---------------------------------------------------------------------- */
 
 static inline struct au_iinfo *au_ii(struct inode *inode)
@@ -134,7 +155,8 @@
 
 /* au_wr_dir flags */
 #define AuWrDir_ADD_ENTRY	1
-#define AuWrDir_ISDIR		(1 << 1)
+#define AuWrDir_TMP_WHENTRY	(1 << 1)
+#define AuWrDir_ISDIR		(1 << 2)
 #define au_ftest_wrdir(flags, name)	((flags) & AuWrDir_##name)
 #define au_fset_wrdir(flags, name) \
 	do { (flags) |= AuWrDir_##name; } while (0)
@@ -204,7 +226,7 @@
 void au_set_h_iptr(struct inode *inode, aufs_bindex_t bindex,
 		   struct inode *h_inode, unsigned int flags);
 
-void au_update_iigen(struct inode *inode);
+void au_update_iigen(struct inode *inode, int half);
 void au_update_ibrange(struct inode *inode, int do_put_zero);
 
 void au_icntnr_init_once(void *_c);
@@ -312,9 +334,19 @@
 #endif
 }
 
-static inline unsigned int au_iigen(struct inode *inode)
+static inline unsigned int au_iigen(struct inode *inode, struct au_iigen *iigen)
 {
-	return atomic_read(&au_ii(inode)->ii_generation);
+	unsigned int gen;
+	struct au_iinfo *iinfo;
+
+	iinfo = au_ii(inode);
+	spin_lock(&iinfo->ii_genspin);
+	if (iigen)
+		*iigen = iinfo->ii_generation;
+	gen = iinfo->ii_generation.ig_generation;
+	spin_unlock(&iinfo->ii_genspin);
+
+	return gen;
 }
 
 /* tiny test for inode number */
@@ -331,7 +363,12 @@
 
 static inline void au_iigen_dec(struct inode *inode)
 {
-	atomic_dec(&au_ii(inode)->ii_generation);
+	struct au_iinfo *iinfo;
+
+	iinfo = au_ii(inode);
+	spin_lock(&iinfo->ii_genspin);
+	iinfo->ii_generation.ig_generation--;
+	spin_unlock(&iinfo->ii_genspin);
 }
 
 static inline int au_iigen_test(struct inode *inode, unsigned int sigen)
@@ -339,7 +376,7 @@
 	int err;
 
 	err = 0;
-	if (unlikely(inode && au_iigen(inode) != sigen))
+	if (unlikely(inode && au_iigen(inode, NULL) != sigen))
 		err = -EIO;
 
 	return err;
@@ -457,7 +494,13 @@
 struct au_hnotify_op {
 	void (*ctl)(struct au_hinode *hinode, int do_set);
 	int (*alloc)(struct au_hinode *hinode);
-	void (*free)(struct au_hinode *hinode);
+
+	/*
+	 * if it returns true, the the caller should free hinode->hi_notify,
+	 * otherwise ->free() frees it.
+	 */
+	int (*free)(struct au_hinode *hinode,
+		    struct au_hnotify *hn) __must_check;
 
 	void (*fin)(void);
 	int (*init)(void);
@@ -489,6 +532,11 @@
 	hinode->hi_notify = NULL;
 }
 
+static inline struct au_hnotify *au_hn(struct au_hinode *hinode)
+{
+	return hinode->hi_notify;
+}
+
 #else
 static inline
 int au_hn_alloc(struct au_hinode *hinode __maybe_unused,
@@ -497,6 +545,11 @@
 	return -EOPNOTSUPP;
 }
 
+static inline struct au_hnotify *au_hn(struct au_hinode *hinode)
+{
+	return NULL;
+}
+
 AuStubVoid(au_hn_free, struct au_hinode *hinode __maybe_unused)
 AuStubVoid(au_hn_ctl, struct au_hinode *hinode __maybe_unused,
 	   int do_set __maybe_unused)
diff -ru --new-file linux-3.x-orig/fs/aufs/ioctl.c linux-3.x/fs/aufs/ioctl.c
--- linux-3.x-orig/fs/aufs/ioctl.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/ioctl.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,49 +22,86 @@
  * assist the pathconf(3) wrapper library.
  */
 
-#include <linux/file.h>
 #include "aufs.h"
 
-static int au_wbr_fd(struct path *path)
+static int au_wbr_fd(struct path *path, struct aufs_wbr_fd __user *arg)
 {
 	int err, fd;
 	aufs_bindex_t wbi, bindex, bend;
 	struct file *h_file;
 	struct super_block *sb;
 	struct dentry *root;
-	struct au_branch *wbr;
+	struct au_branch *br;
+	struct aufs_wbr_fd wbrfd = {
+		.oflags	= au_dir_roflags,
+		.brid	= -1
+	};
+	const int valid = O_RDONLY | O_NONBLOCK | O_LARGEFILE | O_DIRECTORY
+		| O_NOATIME | O_CLOEXEC;
+
+	AuDebugOn(wbrfd.oflags & ~valid);
+
+	if (arg) {
+		err = copy_from_user(&wbrfd, arg, sizeof(wbrfd));
+		if (unlikely(err)) {
+			err = -EFAULT;
+			goto out;
+		}
+
+		err = -EINVAL;
+		AuDbg("wbrfd{0%o, %d}\n", wbrfd.oflags, wbrfd.brid);
+		wbrfd.oflags |= au_dir_roflags;
+		AuDbg("0%o\n", wbrfd.oflags);
+		if (unlikely(wbrfd.oflags & ~valid))
+			goto out;
+	}
 
-	err = get_unused_fd();
-	if (unlikely(err < 0))
+	fd = get_unused_fd();
+	err = fd;
+	if (unlikely(fd < 0))
 		goto out;
-	fd = err;
 
+	h_file = ERR_PTR(-EINVAL);
 	wbi = 0;
+	br = NULL;
 	sb = path->dentry->d_sb;
 	root = sb->s_root;
 	aufs_read_lock(root, AuLock_IR);
-	wbr = au_sbr(sb, wbi);
-	if (!(path->mnt->mnt_flags & MNT_READONLY)
-	    && !au_br_writable(wbr->br_perm)) {
-		bend = au_sbend(sb);
-		for (bindex = 1; bindex <= bend; bindex++) {
-			wbr = au_sbr(sb, bindex);
-			if (au_br_writable(wbr->br_perm)) {
+	bend = au_sbend(sb);
+	if (wbrfd.brid >= 0) {
+		wbi = au_br_index(sb, wbrfd.brid);
+		if (unlikely(wbi < 0 || wbi > bend))
+			goto out_unlock;
+	}
+
+	h_file = ERR_PTR(-ENOENT);
+	br = au_sbr(sb, wbi);
+	if (!au_br_writable(br->br_perm)) {
+		if (arg)
+			goto out_unlock;
+
+		bindex = wbi + 1;
+		wbi = -1;
+		for (; bindex <= bend; bindex++) {
+			br = au_sbr(sb, bindex);
+			if (au_br_writable(br->br_perm)) {
 				wbi = bindex;
+				br = au_sbr(sb, wbi);
 				break;
 			}
 		}
-		wbr = au_sbr(sb, wbi);
 	}
 	AuDbg("wbi %d\n", wbi);
-	h_file = au_h_open(root, wbi, O_RDONLY | O_DIRECTORY | O_LARGEFILE,
-			   NULL);
+	if (wbi >= 0)
+		h_file = au_h_open(root, wbi, wbrfd.oflags, NULL);
+
+out_unlock:
 	aufs_read_unlock(root, AuLock_IR);
 	err = PTR_ERR(h_file);
 	if (IS_ERR(h_file))
 		goto out_fd;
 
-	atomic_dec(&wbr->br_count); /* cf. au_h_open() */
+	atomic_dec(&br->br_count); /* cf. au_h_open() */
 	fd_install(fd, h_file);
 	err = fd;
 	goto out; /* success */
@@ -72,6 +109,7 @@
 out_fd:
 	put_unused_fd(fd);
 out:
+	AuTraceErr(err);
 	return err;
 }
 
@@ -88,7 +126,7 @@
 		break;
 
 	case AUFS_CTL_WBR_FD:
-		err = au_wbr_fd(&file->f_path);
+		err = au_wbr_fd(&file->f_path, (void __user *)arg);
 		break;
 
 	case AUFS_CTL_IBUSY:
@@ -111,7 +149,7 @@
 
 	switch (cmd) {
 	case AUFS_CTL_WBR_FD:
-		err = au_wbr_fd(&file->f_path);
+		err = au_wbr_fd(&file->f_path, (void __user *)arg);
 		break;
 
 	default:
diff -ru --new-file linux-3.x-orig/fs/aufs/i_op_add.c linux-3.x/fs/aufs/i_op_add.c
--- linux-3.x-orig/fs/aufs/i_op_add.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/i_op_add.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -190,7 +190,7 @@
 	if (dt) {
 		struct path tmp = {
 			.dentry	= h_parent,
-			.mnt	= br->br_mnt
+			.mnt	= au_br_mnt(br)
 		};
 		au_dtime_store(dt, au_pinned_parent(pin), &tmp);
 	}
@@ -234,46 +234,54 @@
 	int err;
 	aufs_bindex_t bstart;
 	unsigned char created;
-	struct au_dtime dt;
-	struct au_pin pin;
-	struct path h_path;
 	struct dentry *wh_dentry, *parent;
 	struct inode *h_dir;
-	struct au_wr_dir_args wr_dir_args = {
-		.force_btgt	= -1,
-		.flags		= AuWrDir_ADD_ENTRY
-	};
+	/* to reuduce stack size */
+	struct {
+		struct au_dtime dt;
+		struct au_pin pin;
+		struct path h_path;
+		struct au_wr_dir_args wr_dir_args;
+	} *a;
 
 	AuDbg("%.*s\n", AuDLNPair(dentry));
 	IMustLock(dir);
 
+	err = -ENOMEM;
+	a = kmalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+	a->wr_dir_args.force_btgt = -1;
+	a->wr_dir_args.flags = AuWrDir_ADD_ENTRY;
+
 	parent = dentry->d_parent; /* dir inode is locked */
 	err = aufs_read_lock(dentry, AuLock_DW | AuLock_GEN);
 	if (unlikely(err))
-		goto out;
+		goto out_free;
 	err = au_d_may_add(dentry);
 	if (unlikely(err))
 		goto out_unlock;
 	di_write_lock_parent(parent);
-	wh_dentry = lock_hdir_lkup_wh(dentry, &dt, /*src_dentry*/NULL, &pin,
-				      &wr_dir_args);
+	wh_dentry = lock_hdir_lkup_wh(dentry, &a->dt, /*src_dentry*/NULL,
+				      &a->pin, &a->wr_dir_args);
 	err = PTR_ERR(wh_dentry);
 	if (IS_ERR(wh_dentry))
 		goto out_parent;
 
 	bstart = au_dbstart(dentry);
-	h_path.dentry = au_h_dptr(dentry, bstart);
-	h_path.mnt = au_sbr_mnt(dentry->d_sb, bstart);
-	h_dir = au_pinned_h_dir(&pin);
+	a->h_path.dentry = au_h_dptr(dentry, bstart);
+	a->h_path.mnt = au_sbr_mnt(dentry->d_sb, bstart);
+	h_dir = au_pinned_h_dir(&a->pin);
 	switch (arg->type) {
 	case Creat:
-		err = vfsub_create(h_dir, &h_path, arg->u.c.mode);
+		err = vfsub_create(h_dir, &a->h_path, arg->u.c.mode);
 		break;
 	case Symlink:
-		err = vfsub_symlink(h_dir, &h_path, arg->u.s.symname);
+		err = vfsub_symlink(h_dir, &a->h_path, arg->u.s.symname);
 		break;
 	case Mknod:
-		err = vfsub_mknod(h_dir, &h_path, arg->u.m.mode, arg->u.m.dev);
+		err = vfsub_mknod(h_dir, &a->h_path, arg->u.m.mode,
+				  arg->u.m.dev);
 		break;
 	default:
 		BUG();
@@ -283,18 +291,18 @@
 		err = epilog(dir, bstart, wh_dentry, dentry);
 
 	/* revert */
-	if (unlikely(created && err && h_path.dentry->d_inode)) {
+	if (unlikely(created && err && a->h_path.dentry->d_inode)) {
 		int rerr;
-		rerr = vfsub_unlink(h_dir, &h_path, /*force*/0);
+		rerr = vfsub_unlink(h_dir, &a->h_path, /*force*/0);
 		if (rerr) {
 			AuIOErr("%.*s revert failure(%d, %d)\n",
 				AuDLNPair(dentry), err, rerr);
 			err = -EIO;
 		}
-		au_dtime_revert(&dt);
+		au_dtime_revert(&a->dt);
 	}
 
-	au_unpin(&pin);
+	au_unpin(&a->pin);
 	dput(wh_dentry);
 
 out_parent:
@@ -305,6 +313,8 @@
 		d_drop(dentry);
 	}
 	aufs_read_unlock(dentry, AuLock_DW);
+out_free:
+	kfree(a);
 out:
 	return err;
 }
@@ -357,8 +367,14 @@
 {
 	int err;
 	struct dentry *h_src_dentry;
-	struct mutex *h_mtx;
-	struct file *h_file;
+	struct au_cp_generic cpg = {
+		.dentry	= src_dentry,
+		.bdst	= a->bdst,
+		.bsrc	= a->bsrc,
+		.len	= -1,
+		.pin	= &a->pin,
+		.flags	= AuCpup_DTIME | AuCpup_HOPEN /* | AuCpup_KEEPLINO */
+	};
 
 	di_read_lock_parent(a->src_parent, AuLock_IR);
 	err = au_test_and_cpup_dirs(src_dentry, a->bdst);
@@ -366,22 +382,13 @@
 		goto out;
 
 	h_src_dentry = au_h_dptr(src_dentry, a->bsrc);
-	h_mtx = &h_src_dentry->d_inode->i_mutex;
 	err = au_pin(&a->pin, src_dentry, a->bdst,
 		     au_opt_udba(src_dentry->d_sb),
 		     AuPin_DI_LOCKED | AuPin_MNT_WRITE);
 	if (unlikely(err))
 		goto out;
-	mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
-	h_file = au_h_open_pre(src_dentry, a->bsrc);
-	if (IS_ERR(h_file)) {
-		err = PTR_ERR(h_file);
-		h_file = NULL;
-	} else
-		err = au_sio_cpup_simple(src_dentry, a->bdst, a->bsrc,
-					 AuCpup_DTIME /* | AuCpup_KEEPLINO */);
-	mutex_unlock(h_mtx);
-	au_h_open_post(src_dentry, a->bsrc, h_file);
+
+	err = au_sio_cpup_simple(&cpg);
 	au_unpin(&a->pin);
 
 out:
@@ -389,12 +396,14 @@
 	return err;
 }
 
-static int au_cpup_or_link(struct dentry *src_dentry, struct au_link_args *a)
+static int au_cpup_or_link(struct dentry *src_dentry, struct dentry *dentry,
+			   struct au_link_args *a)
 {
 	int err;
 	unsigned char plink;
-	struct inode *h_inode, *inode;
+	aufs_bindex_t bend;
 	struct dentry *h_src_dentry;
+	struct inode *h_inode, *inode;
 	struct super_block *sb;
 	struct file *h_file;
 
@@ -406,22 +415,38 @@
 		h_inode = au_h_iptr(inode, a->bdst);
 	if (!h_inode || !h_inode->i_nlink) {
 		/* copyup src_dentry as the name of dentry. */
-		au_set_dbstart(src_dentry, a->bdst);
-		au_set_h_dptr(src_dentry, a->bdst, dget(a->h_path.dentry));
-		h_inode = au_h_dptr(src_dentry, a->bsrc)->d_inode;
-		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
-		h_file = au_h_open_pre(src_dentry, a->bsrc);
-		if (IS_ERR(h_file)) {
+		bend = au_dbend(dentry);
+		if (bend < a->bsrc)
+			au_set_dbend(dentry, a->bsrc);
+		au_set_h_dptr(dentry, a->bsrc,
+			      dget(au_h_dptr(src_dentry, a->bsrc)));
+		dget(a->h_path.dentry);
+		au_set_h_dptr(dentry, a->bdst, NULL);
+		dentry->d_inode = src_dentry->d_inode; /* tmp */
+		h_file = au_h_open_pre(dentry, a->bsrc);
+		if (IS_ERR(h_file))
 			err = PTR_ERR(h_file);
-			h_file = NULL;
-		} else
-			err = au_sio_cpup_single(src_dentry, a->bdst, a->bsrc,
-						 -1, AuCpup_KEEPLINO,
-						 a->parent);
-		mutex_unlock(&h_inode->i_mutex);
-		au_h_open_post(src_dentry, a->bsrc, h_file);
-		au_set_h_dptr(src_dentry, a->bdst, NULL);
-		au_set_dbstart(src_dentry, a->bsrc);
+		else {
+			struct au_cp_generic cpg = {
+				.dentry	= dentry,
+				.bdst	= a->bdst,
+				.bsrc	= -1,
+				.len	= -1,
+				.pin	= &a->pin,
+				.flags	= AuCpup_KEEPLINO
+			};
+			err = au_sio_cpup_simple(&cpg);
+			au_h_open_post(dentry, a->bsrc, h_file);
+			if (!err) {
+				dput(a->h_path.dentry);
+				a->h_path.dentry = au_h_dptr(dentry, a->bdst);
+			} else
+				au_set_h_dptr(dentry, a->bdst,
+					      a->h_path.dentry);
+		}
+		dentry->d_inode = NULL; /* restore */
+		au_set_h_dptr(dentry, a->bsrc, NULL);
+		au_set_dbend(dentry, bend);
 	} else {
 		/* the inode of src_dentry already exists on a.bdst branch */
 		h_src_dentry = d_find_alias(h_inode);
@@ -520,7 +545,7 @@
 	if (au_opt_test(au_mntflags(sb), PLINK)) {
 		if (a->bdst < a->bsrc
 		    /* && h_src_dentry->d_sb != a->h_path.dentry->d_sb */)
-			err = au_cpup_or_link(src_dentry, a);
+			err = au_cpup_or_link(src_dentry, dentry, a);
 		else
 			err = vfsub_link(h_src_dentry, au_pinned_h_dir(&a->pin),
 					 &a->h_path);
@@ -599,6 +624,7 @@
 out_kfree:
 	kfree(a);
 out:
+	AuTraceErr(err);
 	return err;
 }
 
diff -ru --new-file linux-3.x-orig/fs/aufs/i_op.c linux-3.x/fs/aufs/i_op.c
--- linux-3.x-orig/fs/aufs/i_op.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/i_op.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,13 +22,11 @@
 
 #include <linux/device_cgroup.h>
 #include <linux/fs_stack.h>
-#include <linux/mm.h>
 #include <linux/namei.h>
 #include <linux/security.h>
-#include <linux/uaccess.h>
 #include "aufs.h"
 
-static int h_permission(struct inode *h_inode, int mask, unsigned int flags,
+static int h_permission(struct inode *h_inode, int mask,
 			struct vfsmount *h_mnt, int brperm)
 {
 	int err;
@@ -52,11 +50,10 @@
 		&& write_mask && !(mask & MAY_READ))
 	    || !h_inode->i_op->permission) {
 		/* AuLabel(generic_permission); */
-		err = generic_permission(h_inode, mask, flags,
-					 h_inode->i_op->check_acl);
+		err = generic_permission(h_inode, mask);
 	} else {
 		/* AuLabel(h_inode->permission); */
-		err = h_inode->i_op->permission(h_inode, mask, flags);
+		err = h_inode->i_op->permission(h_inode, mask);
 		AuTraceErr(err);
 	}
 
@@ -82,7 +79,7 @@
 	return err;
 }
 
-static int aufs_permission(struct inode *inode, int mask, unsigned int flags)
+static int aufs_permission(struct inode *inode, int mask)
 {
 	int err;
 	aufs_bindex_t bindex, bend;
@@ -93,7 +90,7 @@
 	struct au_branch *br;
 
 	/* todo: support rcu-walk? */
-	if (flags & IPERM_FLAG_RCU)
+	if (mask & MAY_NOT_BLOCK)
 		return -ECHILD;
 
 	sb = inode->i_sb;
@@ -116,8 +113,7 @@
 		err = 0;
 		bindex = au_ibstart(inode);
 		br = au_sbr(sb, bindex);
-		err = h_permission(h_inode, mask, flags, br->br_mnt,
-				   br->br_perm);
+		err = h_permission(h_inode, mask, au_br_mnt(br), br->br_perm);
 		if (write_mask
 		    && !err
 		    && !special_file(h_inode->i_mode)) {
@@ -143,7 +139,7 @@
 				break;
 
 			br = au_sbr(sb, bindex);
-			err = h_permission(h_inode, mask, flags, br->br_mnt,
+			err = h_permission(h_inode, mask, au_br_mnt(br),
 					   br->br_perm);
 		}
 	}
@@ -166,20 +162,27 @@
 
 	IMustLock(dir);
 
+	/* todo: support rcu-walk? */
+	ret = ERR_PTR(-ECHILD);
+	if (nd && (nd->flags & LOOKUP_RCU))
+		goto out;
+
+	ret = ERR_PTR(-ENAMETOOLONG);
+	if (unlikely(dentry->d_name.len > AUFS_MAX_NAMELEN))
+		goto out;
+
 	sb = dir->i_sb;
 	err = si_read_lock(sb, AuLock_FLUSH | AuLock_NOPLM);
 	ret = ERR_PTR(err);
 	if (unlikely(err))
 		goto out;
 
-	ret = ERR_PTR(-ENAMETOOLONG);
-	if (unlikely(dentry->d_name.len > AUFS_MAX_NAMELEN))
-		goto out_si;
 	err = au_di_init(dentry);
 	ret = ERR_PTR(err);
 	if (unlikely(err))
 		goto out_si;
 
+	inode = NULL;
 	npositive = 0; /* suppress a warning */
 	parent = dentry->d_parent; /* dir inode is locked */
 	di_read_lock_parent(parent, AuLock_IR);
@@ -196,22 +199,43 @@
 	if (unlikely(err < 0))
 		goto out_unlock;
 
-	inode = NULL;
 	if (npositive) {
 		inode = au_new_inode(dentry, /*must_new*/0);
 		ret = (void *)inode;
 	}
-	if (IS_ERR(inode))
+	if (IS_ERR(inode)) {
+		inode = NULL;
 		goto out_unlock;
+	}
 
 	ret = d_splice_alias(inode, dentry);
+#if 0
+	if (unlikely(d_need_lookup(dentry))) {
+		spin_lock(&dentry->d_lock);
+		dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
+		spin_unlock(&dentry->d_lock);
+	} else
+#endif
 	if (unlikely(IS_ERR(ret) && inode)) {
 		ii_write_unlock(inode);
 		iput(inode);
+		inode = NULL;
 	}
 
 out_unlock:
 	di_write_unlock(dentry);
+	if (inode) {
+		/* verbose coding for lock class name */
+		if (unlikely(S_ISLNK(inode->i_mode)))
+			au_rw_class(&au_di(dentry)->di_rwsem,
+				    au_lc_key + AuLcSymlink_DIINFO);
+		else if (unlikely(S_ISDIR(inode->i_mode)))
+			au_rw_class(&au_di(dentry)->di_rwsem,
+				    au_lc_key + AuLcDir_DIINFO);
+		else /* likely */
+			au_rw_class(&au_di(dentry)->di_rwsem,
+				    au_lc_key + AuLcNonDir_DIINFO);
+	}
 out_si:
 	si_read_unlock(sb);
 out:
@@ -235,16 +259,19 @@
 
 	err = 0;
 	if (!au_h_dptr(parent, bcpup)) {
-		if (bstart < bcpup)
+		if (bstart > bcpup)
+			err = au_cpup_dirs(dentry, bcpup);
+		else if (bstart < bcpup)
 			err = au_cpdown_dirs(dentry, bcpup);
 		else
-			err = au_cpup_dirs(dentry, bcpup);
+			BUG();
 	}
 	if (!err && add_entry) {
 		h_parent = au_h_dptr(parent, bcpup);
 		h_dir = h_parent->d_inode;
 		mutex_lock_nested(&h_dir->i_mutex, AuLsc_I_PARENT);
-		err = au_lkup_neg(dentry, bcpup);
+		err = au_lkup_neg(dentry, bcpup,
+				  au_ftest_wrdir(add_entry, TMP_WHENTRY));
 		/* todo: no unlock here */
 		mutex_unlock(&h_dir->i_mutex);
 
@@ -274,9 +301,11 @@
 	      struct au_wr_dir_args *args)
 {
 	int err;
+	unsigned int flags;
 	aufs_bindex_t bcpup, bstart, src_bstart;
-	const unsigned char add_entry = !!au_ftest_wrdir(args->flags,
-							 ADD_ENTRY);
+	const unsigned char add_entry
+		= au_ftest_wrdir(args->flags, ADD_ENTRY)
+		| au_ftest_wrdir(args->flags, TMP_WHENTRY);
 	struct super_block *sb;
 	struct dentry *parent;
 	struct au_sbinfo *sbinfo;
@@ -292,8 +321,10 @@
 			if (src_bstart < bstart)
 				bcpup = src_bstart;
 		} else if (add_entry) {
-			err = AuWbrCreate(sbinfo, dentry,
-					  au_ftest_wrdir(args->flags, ISDIR));
+			flags = 0;
+			if (au_ftest_wrdir(args->flags, ISDIR))
+				au_fset_wbr(flags, DIR);
+			err = AuWbrCreate(sbinfo, dentry, flags);
 			bcpup = err;
 		}
 
@@ -340,6 +371,85 @@
 
 /* ---------------------------------------------------------------------- */
 
+void au_pin_hdir_unlock(struct au_pin *p)
+{
+	if (p->hdir)
+		au_hn_imtx_unlock(p->hdir);
+}
+
+static int au_pin_hdir_lock(struct au_pin *p)
+{
+	int err;
+
+	err = 0;
+	if (!p->hdir)
+		goto out;
+
+	/* even if an error happens later, keep this lock */
+	au_hn_imtx_lock_nested(p->hdir, p->lsc_hi);
+
+	err = -EBUSY;
+	if (unlikely(p->hdir->hi_inode != p->h_parent->d_inode))
+		goto out;
+
+	err = 0;
+	if (p->h_dentry)
+		err = au_h_verify(p->h_dentry, p->udba, p->hdir->hi_inode,
+				  p->h_parent, p->br);
+
+out:
+	return err;
+}
+
+int au_pin_hdir_relock(struct au_pin *p)
+{
+	int err, i;
+	struct inode *h_i;
+	struct dentry *h_d[] = {
+		p->h_dentry,
+		p->h_parent
+	};
+
+	err = au_pin_hdir_lock(p);
+	if (unlikely(err))
+		goto out;
+
+	for (i = 0; !err && i < sizeof(h_d)/sizeof(*h_d); i++) {
+		if (!h_d[i])
+			continue;
+		h_i = h_d[i]->d_inode;
+		if (h_i)
+			err = !h_i->i_nlink;
+	}
+
+out:
+	return err;
+}
+
+void au_pin_hdir_set_owner(struct au_pin *p, struct task_struct *task)
+{
+#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
+	p->hdir->hi_inode->i_mutex.owner = task;
+#endif
+}
+
+void au_pin_hdir_acquire_nest(struct au_pin *p)
+{
+	if (p->hdir) {
+		mutex_acquire_nest(&p->hdir->hi_inode->i_mutex.dep_map,
+				   p->lsc_hi, 0, NULL, _RET_IP_);
+		au_pin_hdir_set_owner(p, current);
+	}
+}
+
+void au_pin_hdir_release(struct au_pin *p)
+{
+	if (p->hdir) {
+		au_pin_hdir_set_owner(p, p->task);
+		mutex_release(&p->hdir->hi_inode->i_mutex.dep_map, 1, _RET_IP_);
+	}
+}
+
 struct dentry *au_pinned_h_parent(struct au_pin *pin)
 {
 	if (pin && pin->parent)
@@ -354,7 +464,7 @@
 	if (!p->hdir)
 		return;
 
-	au_hn_imtx_unlock(p->hdir);
+	au_pin_hdir_unlock(p);
 	if (!au_ftest_pin(p->flags, DI_LOCKED))
 		di_read_unlock(p->parent, AuLock_IR);
 	iput(p->hdir->hi_inode);
@@ -362,22 +472,21 @@
 	p->parent = NULL;
 	p->hdir = NULL;
 	p->h_mnt = NULL;
+	/* do not clear p->task */
 }
 
 int au_do_pin(struct au_pin *p)
 {
 	int err;
 	struct super_block *sb;
-	struct dentry *h_dentry, *h_parent;
-	struct au_branch *br;
 	struct inode *h_dir;
 
 	err = 0;
 	sb = p->dentry->d_sb;
-	br = au_sbr(sb, p->bindex);
+	p->br = au_sbr(sb, p->bindex);
 	if (IS_ROOT(p->dentry)) {
 		if (au_ftest_pin(p->flags, MNT_WRITE)) {
-			p->h_mnt = br->br_mnt;
+			p->h_mnt = au_br_mnt(p->br);
 			err = mnt_want_write(p->h_mnt);
 			if (unlikely(err)) {
 				au_fclr_pin(p->flags, MNT_WRITE);
@@ -387,16 +496,16 @@
 		goto out;
 	}
 
-	h_dentry = NULL;
+	p->h_dentry = NULL;
 	if (p->bindex <= au_dbend(p->dentry))
-		h_dentry = au_h_dptr(p->dentry, p->bindex);
+		p->h_dentry = au_h_dptr(p->dentry, p->bindex);
 
 	p->parent = dget_parent(p->dentry);
 	if (!au_ftest_pin(p->flags, DI_LOCKED))
 		di_read_lock(p->parent, AuLock_IR, p->lsc_di);
 
 	h_dir = NULL;
-	h_parent = au_h_dptr(p->parent, p->bindex);
+	p->h_parent = au_h_dptr(p->parent, p->bindex);
 	p->hdir = au_hi(p->parent->d_inode, p->bindex);
 	if (p->hdir)
 		h_dir = p->hdir->hi_inode;
@@ -406,7 +515,7 @@
 	 * if DI_LOCKED is not set, then p->parent may be different
 	 * and h_parent can be NULL.
 	 */
-	if (unlikely(!p->hdir || !h_dir || !h_parent)) {
+	if (unlikely(!p->hdir || !h_dir || !p->h_parent)) {
 		err = -EBUSY;
 		if (!au_ftest_pin(p->flags, DI_LOCKED))
 			di_read_unlock(p->parent, AuLock_IR);
@@ -416,22 +525,12 @@
 	}
 
 	au_igrab(h_dir);
-	au_hn_imtx_lock_nested(p->hdir, p->lsc_hi);
-
-	if (unlikely(p->hdir->hi_inode != h_parent->d_inode)) {
-		err = -EBUSY;
+	err = au_pin_hdir_lock(p);
+	if (unlikely(err))
 		goto out_unpin;
-	}
-	if (h_dentry) {
-		err = au_h_verify(h_dentry, p->udba, h_dir, h_parent, br);
-		if (unlikely(err)) {
-			au_fclr_pin(p->flags, MNT_WRITE);
-			goto out_unpin;
-		}
-	}
 
 	if (au_ftest_pin(p->flags, MNT_WRITE)) {
-		p->h_mnt = br->br_mnt;
+		p->h_mnt = au_br_mnt(p->br);
 		err = mnt_want_write(p->h_mnt);
 		if (unlikely(err)) {
 			au_fclr_pin(p->flags, MNT_WRITE);
@@ -463,6 +562,11 @@
 	p->parent = NULL;
 	p->hdir = NULL;
 	p->h_mnt = NULL;
+
+	p->h_dentry = NULL;
+	p->h_parent = NULL;
+	p->br = NULL;
+	p->task = current;
 }
 
 int au_pin(struct au_pin *pin, struct dentry *dentry, aufs_bindex_t bindex,
@@ -528,7 +632,6 @@
 	aufs_bindex_t bstart, ibstart;
 	struct dentry *hi_wh, *parent;
 	struct inode *inode;
-	struct file *h_file;
 	struct au_wr_dir_args wr_dir_args = {
 		.force_btgt	= -1,
 		.flags		= 0
@@ -568,13 +671,20 @@
 	sz = -1;
 	if ((ia->ia_valid & ATTR_SIZE) && ia->ia_size < i_size_read(a->h_inode))
 		sz = ia->ia_size;
+	mutex_unlock(&a->h_inode->i_mutex);
 
-	h_file = NULL;
 	hi_wh = NULL;
 	if (au_ftest_icpup(a->flags, DID_CPUP) && d_unlinked(dentry)) {
 		hi_wh = au_hi_wh(inode, a->btgt);
 		if (!hi_wh) {
-			err = au_sio_cpup_wh(dentry, a->btgt, sz, /*file*/NULL);
+			struct au_cp_generic cpg = {
+				.dentry	= dentry,
+				.bdst	= a->btgt,
+				.bsrc	= -1,
+				.len	= sz,
+				.pin	= &a->pin
+			};
+			err = au_sio_cpup_wh(&cpg, /*file*/NULL);
 			if (unlikely(err))
 				goto out_unlock;
 			hi_wh = au_hi_wh(inode, a->btgt);
@@ -592,13 +702,15 @@
 		goto out; /* success */
 
 	if (!d_unhashed(dentry)) {
-		h_file = au_h_open_pre(dentry, bstart);
-		if (IS_ERR(h_file)) {
-			err = PTR_ERR(h_file);
-			h_file = NULL;
-		} else
-			err = au_sio_cpup_simple(dentry, a->btgt, sz,
-						 AuCpup_DTIME);
+		struct au_cp_generic cpg = {
+			.dentry	= dentry,
+			.bdst	= a->btgt,
+			.bsrc	= bstart,
+			.len	= sz,
+			.pin	= &a->pin,
+			.flags	= AuCpup_DTIME | AuCpup_HOPEN
+		};
+		err = au_sio_cpup_simple(&cpg);
 		if (!err)
 			a->h_path.dentry = au_h_dptr(dentry, a->btgt);
 	} else if (!hi_wh)
@@ -607,14 +719,9 @@
 		a->h_path.dentry = hi_wh; /* do not dget here */
 
 out_unlock:
-	mutex_unlock(&a->h_inode->i_mutex);
-	au_h_open_post(dentry, bstart, h_file);
 	a->h_inode = a->h_path.dentry->d_inode;
-	if (!err) {
-		mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
+	if (!err)
 		goto out; /* success */
-	}
-
 	au_unpin(&a->pin);
 out_parent:
 	if (parent) {
@@ -622,6 +729,8 @@
 		dput(parent);
 	}
 out:
+	if (!err)
+		mutex_lock_nested(&a->h_inode->i_mutex, AuLsc_I_CHILD);
 	return err;
 }
 
@@ -738,6 +847,8 @@
 static void au_refresh_iattr(struct inode *inode, struct kstat *st,
 			     unsigned int nlink)
 {
+	unsigned int n;
+
 	inode->i_mode = st->mode;
 	inode->i_uid = st->uid;
 	inode->i_gid = st->gid;
@@ -747,8 +858,11 @@
 
 	au_cpup_attr_nlink(inode, /*force*/0);
 	if (S_ISDIR(inode->i_mode)) {
-		inode->i_nlink -= nlink;
-		inode->i_nlink += st->nlink;
+		n = inode->i_nlink;
+		n -= nlink;
+		n += st->nlink;
+		smp_mb();
+		set_nlink(inode, n);
 	}
 
 	spin_lock(&inode->i_lock);
diff -ru --new-file linux-3.x-orig/fs/aufs/i_op_del.c linux-3.x/fs/aufs/i_op_del.c
--- linux-3.x-orig/fs/aufs/i_op_del.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/i_op_del.c	2014-12-23 17:23:09.043087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -300,17 +300,25 @@
 {
 	int err;
 	aufs_bindex_t bwh, bindex, bstart;
-	struct au_dtime dt;
-	struct au_pin pin;
-	struct path h_path;
 	struct inode *inode, *h_dir;
 	struct dentry *parent, *wh_dentry;
+	/* to reuduce stack size */
+	struct {
+		struct au_dtime dt;
+		struct au_pin pin;
+		struct path h_path;
+	} *a;
 
 	IMustLock(dir);
 
+	err = -ENOMEM;
+	a = kmalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
+		goto out;
+
 	err = aufs_read_lock(dentry, AuLock_DW | AuLock_GEN);
 	if (unlikely(err))
-		goto out;
+		goto out_free;
 	err = au_d_hashed_positive(dentry);
 	if (unlikely(err))
 		goto out_unlock;
@@ -325,17 +333,18 @@
 	bindex = -1;
 	parent = dentry->d_parent; /* dir inode is locked */
 	di_write_lock_parent(parent);
-	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/0, &bindex, &dt, &pin);
+	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/0, &bindex, &a->dt,
+					&a->pin);
 	err = PTR_ERR(wh_dentry);
 	if (IS_ERR(wh_dentry))
 		goto out_parent;
 
-	h_path.mnt = au_sbr_mnt(dentry->d_sb, bstart);
-	h_path.dentry = au_h_dptr(dentry, bstart);
-	dget(h_path.dentry);
+	a->h_path.mnt = au_sbr_mnt(dentry->d_sb, bstart);
+	a->h_path.dentry = au_h_dptr(dentry, bstart);
+	dget(a->h_path.dentry);
 	if (bindex == bstart) {
-		h_dir = au_pinned_h_dir(&pin);
-		err = vfsub_unlink(h_dir, &h_path, /*force*/0);
+		h_dir = au_pinned_h_dir(&a->pin);
+		err = vfsub_unlink(h_dir, &a->h_path, /*force*/0);
 	} else {
 		/* dir inode is locked */
 		h_dir = wh_dentry->d_parent->d_inode;
@@ -349,8 +358,9 @@
 
 		/* update target timestamps */
 		if (bindex == bstart) {
-			vfsub_update_h_iattr(&h_path, /*did*/NULL); /*ignore*/
-			inode->i_ctime = h_path.dentry->d_inode->i_ctime;
+			vfsub_update_h_iattr(&a->h_path, /*did*/NULL);
+			/*ignore*/
+			inode->i_ctime = a->h_path.dentry->d_inode->i_ctime;
 		} else
 			/* todo: this timestamp may be reverted later */
 			inode->i_ctime = h_dir->i_ctime;
@@ -361,19 +371,22 @@
 	if (wh_dentry) {
 		int rerr;
 
-		rerr = do_revert(err, dir, bindex, bwh, wh_dentry, dentry, &dt);
+		rerr = do_revert(err, dir, bindex, bwh, wh_dentry, dentry,
+				 &a->dt);
 		if (rerr)
 			err = rerr;
 	}
 
 out_unpin:
-	au_unpin(&pin);
+	au_unpin(&a->pin);
 	dput(wh_dentry);
-	dput(h_path.dentry);
+	dput(a->h_path.dentry);
 out_parent:
 	di_write_unlock(parent);
 out_unlock:
 	aufs_read_unlock(dentry, AuLock_DW);
+out_free:
+	kfree(a);
 out:
 	return err;
 }
@@ -382,24 +395,29 @@
 {
 	int err, rmdir_later;
 	aufs_bindex_t bwh, bindex, bstart;
-	struct au_dtime dt;
-	struct au_pin pin;
 	struct inode *inode;
 	struct dentry *parent, *wh_dentry, *h_dentry;
 	struct au_whtmp_rmdir *args;
+	/* to reuduce stack size */
+	struct {
+		struct au_dtime dt;
+		struct au_pin pin;
+	} *a;
 
 	IMustLock(dir);
 
-	err = aufs_read_lock(dentry, AuLock_DW | AuLock_FLUSH | AuLock_GEN);
-	if (unlikely(err))
+	err = -ENOMEM;
+	a = kmalloc(sizeof(*a), GFP_NOFS);
+	if (unlikely(!a))
 		goto out;
 
-	/* VFS already unhashes it */
-	inode = dentry->d_inode;
-	err = -ENOENT;
-	if (unlikely(!inode || !inode->i_nlink
-		     || IS_DEADDIR(inode)))
+	err = aufs_read_lock(dentry, AuLock_DW | AuLock_FLUSH | AuLock_GEN);
+	if (unlikely(err))
+		goto out_free;
+	err = au_alive_dir(dentry);
+	if (unlikely(err))
 		goto out_unlock;
+	inode = dentry->d_inode;
 	IMustLock(inode);
 	err = -ENOTDIR;
 	if (unlikely(!S_ISDIR(inode->i_mode)))
@@ -419,7 +437,8 @@
 	bstart = au_dbstart(dentry);
 	bwh = au_dbwh(dentry);
 	bindex = -1;
-	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/1, &bindex, &dt, &pin);
+	wh_dentry = lock_hdir_create_wh(dentry, /*isdir*/1, &bindex, &a->dt,
+					&a->pin);
 	err = PTR_ERR(wh_dentry);
 	if (IS_ERR(wh_dentry))
 		goto out_parent;
@@ -460,13 +479,14 @@
 	if (wh_dentry) {
 		int rerr;
 
-		rerr = do_revert(err, dir, bindex, bwh, wh_dentry, dentry, &dt);
+		rerr = do_revert(err, dir, bindex, bwh, wh_dentry, dentry,
+				 &a->dt);
 		if (rerr)
 			err = rerr;
 	}
 
 out_unpin:
-	au_unpin(&pin);
+	au_unpin(&a->pin);
 	dput(wh_dentry);
 	dput(h_dentry);
 out_parent:
@@ -475,6 +495,8 @@
 		au_whtmp_rmdir_free(args);
 out_unlock:
 	aufs_read_unlock(dentry, AuLock_DW);
+out_free:
+	kfree(a);
 out:
 	AuTraceErr(err);
 	return err;
diff -ru --new-file linux-3.x-orig/fs/aufs/i_op_ren.c linux-3.x/fs/aufs/i_op_ren.c
--- linux-3.x-orig/fs/aufs/i_op_ren.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/i_op_ren.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -208,32 +208,9 @@
 		AuDebugOn(au_dbstart(d) != a->btgt);
 		err = vfsub_rename(a->src_h_dir, au_h_dptr(d, a->btgt),
 				   a->dst_h_dir, &a->h_path);
-	} else {
-		struct mutex *h_mtx = &a->src_h_dentry->d_inode->i_mutex;
-		struct file *h_file;
+	} else
+		BUG();
 
-		au_fset_ren(a->flags, CPUP);
-		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
-		au_set_dbstart(d, a->btgt);
-		au_set_h_dptr(d, a->btgt, dget(a->dst_h_dentry));
-		h_file = au_h_open_pre(d, a->src_bstart);
-		if (IS_ERR(h_file)) {
-			err = PTR_ERR(h_file);
-			h_file = NULL;
-		} else
-			err = au_sio_cpup_single(d, a->btgt, a->src_bstart, -1,
-						 !AuCpup_DTIME, a->dst_parent);
-		mutex_unlock(h_mtx);
-		au_h_open_post(d, a->src_bstart, h_file);
-		if (!err) {
-			d = a->dst_dentry;
-			au_set_h_dptr(d, a->btgt, NULL);
-			au_update_dbstart(d);
-		} else {
-			au_set_h_dptr(d, a->btgt, NULL);
-			au_set_dbstart(d, a->src_bstart);
-		}
-	}
 	if (!err && a->h_dst)
 		/* it will be set to dinfo later */
 		dget(a->h_dst);
@@ -254,8 +231,8 @@
 	    || au_test_fs_remote(a->h_dst->d_sb)) {
 		err = au_whtmp_rmdir(dir, a->btgt, a->h_dst, &a->whlist);
 		if (unlikely(err))
-			pr_warning("failed removing whtmp dir %.*s (%d), "
-				   "ignored.\n", AuDLNPair(a->h_dst), err);
+			pr_warn("failed removing whtmp dir %.*s (%d), "
+				"ignored.\n", AuDLNPair(a->h_dst), err);
 	} else {
 		au_nhash_wh_free(&a->thargs->whlist);
 		a->thargs->whlist = a->whlist;
@@ -334,31 +311,13 @@
 
 		d = a->dst_dentry;
 		au_set_h_dptr(d, a->btgt, NULL);
-		err = au_lkup_neg(d, a->btgt);
+		err = au_lkup_neg(d, a->btgt, /*wh*/0);
 		if (unlikely(err))
 			goto out_whtmp;
 		a->dst_h_dentry = au_h_dptr(d, a->btgt);
 	}
 
-	/* cpup src */
-	if (a->dst_h_dentry->d_inode && a->src_bstart != a->btgt) {
-		struct mutex *h_mtx = &a->src_h_dentry->d_inode->i_mutex;
-		struct file *h_file;
-
-		mutex_lock_nested(h_mtx, AuLsc_I_CHILD);
-		AuDebugOn(au_dbstart(a->src_dentry) != a->src_bstart);
-		h_file = au_h_open_pre(a->src_dentry, a->src_bstart);
-		if (IS_ERR(h_file)) {
-			err = PTR_ERR(h_file);
-			h_file = NULL;
-		} else
-			err = au_sio_cpup_simple(a->src_dentry, a->btgt, -1,
-						 !AuCpup_DTIME);
-		mutex_unlock(h_mtx);
-		au_h_open_post(a->src_dentry, a->src_bstart, h_file);
-		if (unlikely(err))
-			goto out_whtmp;
-	}
+	BUG_ON(a->dst_h_dentry->d_inode && a->src_bstart != a->btgt);
 
 	/* rename by vfs_rename or cpup */
 	d = a->dst_dentry;
@@ -614,7 +573,7 @@
 
 	sb = a->dst_dentry->d_sb;
 	if (au_ftest_ren(a->flags, MNT_WRITE))
-		mnt_drop_write(a->br->br_mnt);
+		mnt_drop_write(au_br_mnt(a->br));
 	vfsub_unlock_rename(a->src_h_parent, a->src_hdir,
 			    a->dst_h_parent, a->dst_hdir);
 }
@@ -644,7 +603,7 @@
 				  a->dst_h_parent->d_inode, a->dst_h_parent,
 				  a->br);
 	if (!err) {
-		err = mnt_want_write(a->br->br_mnt);
+		err = mnt_want_write(au_br_mnt(a->br));
 		if (unlikely(err))
 			goto out_unlock;
 		au_fset_ren(a->flags, MNT_WRITE);
@@ -907,6 +866,15 @@
 	} else if (unlikely(d_unhashed(a->dst_dentry)))
 		goto out_unlock;
 
+	/*
+	 * is it possible?
+	 * yes, it happend (in linux-3.3-rcN) but I don't know why.
+	 * there may exist a problem somewhere else.
+	 */
+	err = -EINVAL;
+	if (unlikely(a->dst_parent->d_inode == a->src_dentry->d_inode))
+		goto out_unlock;
+
 	au_fset_ren(a->flags, ISSAMEDIR); /* temporary */
 	di_write_lock_parent(a->dst_parent);
 
@@ -915,7 +883,7 @@
 	if (unlikely(err < 0))
 		goto out_parent;
 	a->br = au_sbr(a->dst_dentry->d_sb, a->btgt);
-	a->h_path.mnt = a->br->br_mnt;
+	a->h_path.mnt = au_br_mnt(a->br);
 
 	/* are they available to be renamed */
 	err = au_ren_may_dir(a);
@@ -953,9 +921,37 @@
 	if (err)
 		au_fset_ren(a->flags, WHSRC);
 
+	/* cpup src */
+	if (a->src_bstart != a->btgt) {
+		struct au_pin pin;
+
+		err = au_pin(&pin, a->src_dentry, a->btgt,
+			     au_opt_udba(a->src_dentry->d_sb),
+			     AuPin_DI_LOCKED | AuPin_MNT_WRITE);
+		if (!err) {
+			struct au_cp_generic cpg = {
+				.dentry	= a->src_dentry,
+				.bdst	= a->btgt,
+				.bsrc	= a->src_bstart,
+				.len	= -1,
+				.pin	= &pin,
+				.flags	= AuCpup_DTIME | AuCpup_HOPEN
+			};
+			AuDebugOn(au_dbstart(a->src_dentry) != a->src_bstart);
+			err = au_sio_cpup_simple(&cpg);
+			au_unpin(&pin);
+		}
+		if (unlikely(err))
+			goto out_children;
+		a->src_bstart = a->btgt;
+		a->src_h_dentry = au_h_dptr(a->src_dentry, a->btgt);
+		au_fset_ren(a->flags, WHSRC);
+	}
+
 	/* lock them all */
 	err = au_ren_lock(a);
 	if (unlikely(err))
+		/* leave the copied-up one */
 		goto out_children;
 
 	if (!au_opt_test(au_mntflags(a->dst_dir->i_sb), UDBA_NONE))
diff -ru --new-file linux-3.x-orig/fs/aufs/Kconfig linux-3.x/fs/aufs/Kconfig
--- linux-3.x-orig/fs/aufs/Kconfig	2014-12-11 11:27:34.000000000 +0000
+++ linux-3.x/fs/aufs/Kconfig	2014-12-23 17:23:09.027087000 +0000
@@ -1,5 +1,5 @@
 config AUFS_FS
-	bool "Aufs (Advanced multi layered unification filesystem) support"
+	tristate "Aufs (Advanced multi layered unification filesystem) support"
 	depends on EXPERIMENTAL
 	help
 	Aufs is a stackable unification filesystem such as Unionfs,
@@ -72,7 +72,7 @@
 
 config AUFS_EXPORT
 	bool "NFS-exportable aufs"
-	depends on EXPORTFS = y
+	depends on EXPORTFS
 	help
 	If you want to export your mounted aufs via NFS, then enable this
 	option. There are several requirements for this configuration.
@@ -100,29 +100,6 @@
 	shows better performance in most cases.
 	See detail in aufs.5.
 
-config AUFS_PROC_MAP
-	bool "support for /proc/maps and lsof(1)"
-	depends on PROC_FS
-	help
-	When you issue mmap(2) in aufs, it is actually a direct mmap(2)
-	call to the file on the branch fs since the file in aufs is
-	purely virtual. And the file path printed in /proc/maps (and
-	others) will be the path on the branch fs. In most cases, it
-	does no harm. But some utilities like lsof(1) may confuse since
-	the utility or user may expect the file path in aufs to be
-	printed.
-	To address this issue, aufs provides a patch which introduces a
-	new member called vm_prfile into struct vm_are_struct. The patch
-	is meaningless without enabling this configuration since nobody
-	sets the new vm_prfile member.
-	If you don't apply the patch, then enabling this configuration
-	will cause a compile error.
-	This approach is fragile since if someone else make some changes
-	around vm_file, then vm_prfile may not work anymore. As a
-	workaround such case, aufs provides this configuration. If you
-	disable it, then lsof(1) may produce incorrect result but the
-	problem will be gone even if the aufs patch is applied (I hope).
-
 config AUFS_SP_IATTR
 	bool "Respect the attributes (mtime/ctime mainly) of special files"
 	help
diff -ru --new-file linux-3.x-orig/fs/aufs/loop.c linux-3.x/fs/aufs/loop.c
--- linux-3.x-orig/fs/aufs/loop.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/loop.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -51,13 +51,85 @@
 {
 	int ret;
 	struct task_struct *tsk = current;
+	char c, comm[sizeof(tsk->comm)];
 
 	ret = 0;
 	if (tsk->flags & PF_KTHREAD) {
-		const char c = tsk->comm[4];
+		get_task_comm(comm, tsk);
+		c = comm[4];
 		ret = ('0' <= c && c <= '9'
-		       && !strncmp(tsk->comm, "loop", 4));
+		       && !strncmp(comm, "loop", 4));
 	}
 
 	return ret;
 }
+
+/* ---------------------------------------------------------------------- */
+
+#define au_warn_loopback_step	16
+static int au_warn_loopback_nelem = au_warn_loopback_step;
+static unsigned long *au_warn_loopback_array;
+
+void au_warn_loopback(struct super_block *h_sb)
+{
+	int i, new_nelem;
+	unsigned long *a, magic;
+	static DEFINE_SPINLOCK(spin);
+
+	magic = h_sb->s_magic;
+	spin_lock(&spin);
+	a = au_warn_loopback_array;
+	for (i = 0; i < au_warn_loopback_nelem && *a; i++)
+		if (a[i] == magic) {
+			spin_unlock(&spin);
+			return;
+		}
+
+	/* h_sb is new to us, print it */
+	if (i < au_warn_loopback_nelem) {
+		a[i] = magic;
+		goto pr;
+	}
+
+	/* expand the array */
+	new_nelem = au_warn_loopback_nelem + au_warn_loopback_step;
+	a = au_kzrealloc(au_warn_loopback_array,
+			 au_warn_loopback_nelem * sizeof(unsigned long),
+			 new_nelem * sizeof(unsigned long), GFP_ATOMIC);
+	if (a) {
+		au_warn_loopback_nelem = new_nelem;
+		au_warn_loopback_array = a;
+		a[i] = magic;
+		goto pr;
+	}
+
+	spin_unlock(&spin);
+	AuWarn1("realloc failed, ignored\n");
+	return;
+
+pr:
+	spin_unlock(&spin);
+	pr_warn("you may want to try another patch for loopback file "
+		"on %s(0x%lx) branch\n", au_sbtype(h_sb), magic);
+}
+
+int au_loopback_init(void)
+{
+	int err;
+	struct super_block *sb __maybe_unused;
+
+	AuDebugOn(sizeof(sb->s_magic) != sizeof(unsigned long));
+
+	err = 0;
+	au_warn_loopback_array = kcalloc(au_warn_loopback_step,
+					 sizeof(unsigned long), GFP_NOFS);
+	if (unlikely(!au_warn_loopback_array))
+		err = -ENOMEM;
+
+	return err;
+}
+
+void au_loopback_fin(void)
+{
+	kfree(au_warn_loopback_array);
+}
diff -ru --new-file linux-3.x-orig/fs/aufs/loop.h linux-3.x/fs/aufs/loop.h
--- linux-3.x-orig/fs/aufs/loop.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/loop.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,10 +32,18 @@
 /* loop.c */
 int au_test_loopback_overlap(struct super_block *sb, struct dentry *h_adding);
 int au_test_loopback_kthread(void);
+void au_warn_loopback(struct super_block *h_sb);
+
+int au_loopback_init(void);
+void au_loopback_fin(void);
 #else
 AuStubInt0(au_test_loopback_overlap, struct super_block *sb,
 	   struct dentry *h_adding)
 AuStubInt0(au_test_loopback_kthread, void)
+AuStubVoid(au_warn_loopback, struct super_block *h_sb)
+
+AuStubInt0(au_loopback_init, void)
+AuStubVoid(au_loopback_fin, void)
 #endif /* BLK_DEV_LOOP */
 
 #endif /* __KERNEL__ */
diff -ru --new-file linux-3.x-orig/fs/aufs/Makefile linux-3.x/fs/aufs/Makefile
--- linux-3.x-orig/fs/aufs/Makefile	2014-12-11 11:27:34.000000000 +0000
+++ linux-3.x/fs/aufs/Makefile	2014-12-23 17:23:09.027087000 +0000
@@ -1,11 +1,19 @@
 
-include ${srctree}/${src}/magic.mk
+include ${src}/magic.mk
+ifeq (${CONFIG_AUFS_FS},m)
+include ${src}/conf.mk
+endif
+-include ${src}/priv_def.mk
 
 # cf. include/linux/kernel.h
 # enable pr_debug
 ccflags-y += -DDEBUG
-# sparse doesn't allow spaces
-ccflags-y += -D'pr_fmt(fmt)=AUFS_NAME"\040%s:%d:%s[%d]:\040"fmt,__func__,__LINE__,current->comm,current->pid'
+# sparse requires the full pathname
+ifdef M
+ccflags-y += -include ${M}/../../include/linux/aufs_type.h
+else
+ccflags-y += -include ${srctree}/include/linux/aufs_type.h
+endif
 
 obj-$(CONFIG_AUFS_FS) += aufs.o
 aufs-y := module.o sbinfo.o super.o branch.o xino.o sysaufs.o opts.o \
diff -ru --new-file linux-3.x-orig/fs/aufs/module.c linux-3.x/fs/aufs/module.c
--- linux-3.x-orig/fs/aufs/module.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/module.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -65,8 +65,9 @@
 {
 	int i;
 
-	/* including AuCache_HNOTIFY */
-	for (i = 0; i < AuCache_Last; i++)
+	/* excluding AuCache_HNOTIFY */
+	BUILD_BUG_ON(AuCache_HNOTIFY + 1 != AuCache_Last);
+	for (i = 0; i < AuCache_HNOTIFY; i++)
 		if (au_cachep[i]) {
 			kmem_cache_destroy(au_cachep[i]);
 			au_cachep[i] = NULL;
@@ -78,9 +79,15 @@
 int au_dir_roflags;
 
 #ifdef CONFIG_AUFS_SBILIST
+/*
+ * iterate_supers_type() doesn't protect us from
+ * remounting (branch management)
+ */
 struct au_splhead au_sbilist;
 #endif
 
+struct lock_class_key au_lc_key[AuLcKey_Last];
+
 /*
  * functions for module interface.
  */
@@ -134,9 +141,12 @@
 	err = au_wkq_init();
 	if (unlikely(err))
 		goto out_procfs;
-	err = au_hnotify_init();
+	err = au_loopback_init();
 	if (unlikely(err))
 		goto out_wkq;
+	err = au_hnotify_init();
+	if (unlikely(err))
+		goto out_loopback;
 	err = au_sysrq_init();
 	if (unlikely(err))
 		goto out_hin;
@@ -156,6 +166,8 @@
 	au_sysrq_fin();
 out_hin:
 	au_hnotify_fin();
+out_loopback:
+	au_loopback_fin();
 out_wkq:
 	au_wkq_fin();
 out_procfs:
@@ -173,6 +185,7 @@
 	au_cache_fin();
 	au_sysrq_fin();
 	au_hnotify_fin();
+	au_loopback_fin();
 	au_wkq_fin();
 	au_procfs_fin();
 	sysaufs_fin();
diff -ru --new-file linux-3.x-orig/fs/aufs/module.h linux-3.x/fs/aufs/module.h
--- linux-3.x-orig/fs/aufs/module.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/module.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,6 +37,22 @@
 
 extern int au_dir_roflags;
 
+enum {
+	AuLcNonDir_FIINFO,
+	AuLcNonDir_DIINFO,
+	AuLcNonDir_IIINFO,
+
+	AuLcDir_FIINFO,
+	AuLcDir_DIINFO,
+	AuLcDir_IIINFO,
+
+	AuLcSymlink_DIINFO,
+	AuLcSymlink_IIINFO,
+
+	AuLcKey_Last
+};
+extern struct lock_class_key au_lc_key[AuLcKey_Last];
+
 void *au_kzrealloc(void *p, unsigned int nused, unsigned int new_sz, gfp_t gfp);
 int au_seq_path(struct seq_file *seq, struct path *path);
 
@@ -58,9 +74,7 @@
 	AuCache_FINFO,
 	AuCache_VDIR,
 	AuCache_DEHSTR,
-#ifdef CONFIG_AUFS_HNOTIFY
-	AuCache_HNOTIFY,
-#endif
+	AuCache_HNOTIFY, /* must be last */
 	AuCache_Last
 };
 
diff -ru --new-file linux-3.x-orig/fs/aufs/opts.c linux-3.x/fs/aufs/opts.c
--- linux-3.x-orig/fs/aufs/opts.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/opts.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,8 +20,6 @@
  * mount options/flags
  */
 
-#include <linux/file.h>
-#include <linux/jiffies.h>
 #include <linux/namei.h>
 #include <linux/types.h> /* a distribution requires */
 #include <linux/parser.h>
@@ -181,31 +179,147 @@
 
 /* ---------------------------------------------------------------------- */
 
-static match_table_t brperms = {
+static match_table_t brperm = {
 	{AuBrPerm_RO, AUFS_BRPERM_RO},
 	{AuBrPerm_RR, AUFS_BRPERM_RR},
 	{AuBrPerm_RW, AUFS_BRPERM_RW},
+	{0, NULL}
+};
 
-	{AuBrPerm_ROWH, AUFS_BRPERM_ROWH},
-	{AuBrPerm_RRWH, AUFS_BRPERM_RRWH},
-	{AuBrPerm_RWNoLinkWH, AUFS_BRPERM_RWNLWH},
-
-	{AuBrPerm_ROWH, "nfsro"},
-	{AuBrPerm_RO, NULL}
+static match_table_t brattr = {
+	{AuBrAttr_UNPIN, AUFS_BRATTR_UNPIN},
+	{AuBrRAttr_WH, AUFS_BRRATTR_WH},
+	{AuBrWAttr_NoLinkWH, AUFS_BRWATTR_NLWH},
+	{0, NULL}
 };
 
+#define AuBrStr_LONGEST	AUFS_BRPERM_RW \
+	"+" AUFS_BRATTR_UNPIN \
+	"+" AUFS_BRWATTR_NLWH
+
+static int br_attr_val(char *str, match_table_t table, substring_t args[])
+{
+	int attr, v;
+	char *p;
+
+	attr = 0;
+	do {
+		p = strchr(str, '+');
+		if (p)
+			*p = 0;
+		v = match_token(str, table, args);
+		if (v)
+			attr |= v;
+		else {
+			if (p)
+				*p = '+';
+			pr_warn("ignored branch attribute %s\n", str);
+			break;
+		}
+		if (p)
+			str = p + 1;
+	} while (p);
+
+	return attr;
+}
+
 static int noinline_for_stack br_perm_val(char *perm)
 {
 	int val;
+	char *p, *q;
 	substring_t args[MAX_OPT_ARGS];
 
-	val = match_token(perm, brperms, args);
+	p = strchr(perm, '+');
+	if (p)
+		*p = 0;
+	val = match_token(perm, brperm, args);
+	if (!val) {
+		if (p)
+			*p = '+';
+		pr_warn("ignored branch permission %s\n", perm);
+		val = AuBrPerm_RO;
+		goto out;
+	}
+	if (!p)
+		goto out;
+
+	p++;
+	while (1) {
+		q = strchr(p, '+');
+		if (q)
+			*q = 0;
+		val |= br_attr_val(p, brattr, args);
+		if (q) {
+			*q = '+';
+			p = q + 1;
+		} else
+			break;
+	}
+	switch (val & AuBrPerm_Mask) {
+	case AuBrPerm_RO:
+	case AuBrPerm_RR:
+		if (unlikely(val & AuBrWAttr_NoLinkWH)) {
+			pr_warn("ignored branch attribute %s\n",
+				AUFS_BRWATTR_NLWH);
+			val &= ~AuBrWAttr_NoLinkWH;
+		}
+		break;
+	case AuBrPerm_RW:
+		if (unlikely(val & AuBrRAttr_WH)) {
+			pr_warn("ignored branch attribute %s\n",
+				AUFS_BRRATTR_WH);
+			val &= ~AuBrRAttr_WH;
+		}
+		break;
+	}
+
+out:
 	return val;
 }
 
-const char *au_optstr_br_perm(int brperm)
+/* Caller should free the return value */
+char *au_optstr_br_perm(int brperm)
 {
-	return au_parser_pattern(brperm, (void *)brperms);
+	char *p, a[sizeof(AuBrStr_LONGEST)];
+	int sz;
+
+#define SetPerm(str) do {			\
+		sz = sizeof(str);		\
+		memcpy(a, str, sz);		\
+		p = a + sz - 1;			\
+	} while (0)
+
+#define AppendAttr(flag, str) do {			\
+		if (brperm & flag) {		\
+			sz = sizeof(str);	\
+			*p++ = '+';		\
+			memcpy(p, str, sz);	\
+			p += sz - 1;		\
+		}				\
+	} while (0)
+
+	switch (brperm & AuBrPerm_Mask) {
+	case AuBrPerm_RO:
+		SetPerm(AUFS_BRPERM_RO);
+		break;
+	case AuBrPerm_RR:
+		SetPerm(AUFS_BRPERM_RR);
+		break;
+	case AuBrPerm_RW:
+		SetPerm(AUFS_BRPERM_RW);
+		break;
+	default:
+		AuDebugOn(1);
+	}
+
+	AppendAttr(AuBrAttr_UNPIN, AUFS_BRATTR_UNPIN);
+	AppendAttr(AuBrRAttr_WH, AUFS_BRRATTR_WH);
+	AppendAttr(AuBrWAttr_NoLinkWH, AUFS_BRWATTR_NLWH);
+
+	AuDebugOn(strlen(a) >= sizeof(a));
+	return kstrdup(a, GFP_NOFS);
+#undef SetPerm
+#undef AppendAttr
 }
 
 /* ---------------------------------------------------------------------- */
@@ -250,6 +364,8 @@
 	{AuWbrCreate_MFSRRV, "mfsrr:%d:%d"},
 	{AuWbrCreate_PMFS, "pmfs"},
 	{AuWbrCreate_PMFSV, "pmfs:%d"},
+	{AuWbrCreate_PMFSRR, "pmfsrr:%d"},
+	{AuWbrCreate_PMFSRRV, "pmfsrr:%d:%d"},
 
 	{-1, NULL}
 };
@@ -257,7 +373,7 @@
 /*
  * cf. linux/lib/parser.c and cmdline.c
  * gave up calling memparse() since it uses simple_strtoull() instead of
- * strict_...().
+ * kstrto...().
  */
 static int noinline_for_stack
 au_match_ull(substring_t *s, unsigned long long *result)
@@ -271,7 +387,7 @@
 	if (len + 1 <= sizeof(a)) {
 		memcpy(a, s->from, len);
 		a[len] = '\0';
-		err = strict_strtoull(a, 0, result);
+		err = kstrtoull(a, 0, result);
 	}
 	return err;
 }
@@ -319,6 +435,7 @@
 	create->wbr_create = err;
 	switch (err) {
 	case AuWbrCreate_MFSRRV:
+	case AuWbrCreate_PMFSRRV:
 		e = au_wbr_mfs_wmark(&args[0], str, create);
 		if (!e)
 			e = au_wbr_mfs_sec(&args[1], str, create);
@@ -326,6 +443,7 @@
 			err = e;
 		break;
 	case AuWbrCreate_MFSRR:
+	case AuWbrCreate_PMFSRR:
 		e = au_wbr_mfs_wmark(&args[0], str, create);
 		if (unlikely(e)) {
 			err = e;
@@ -542,6 +660,7 @@
 					  u.create->mfsrr_watermark);
 				break;
 			case AuWbrCreate_MFSRRV:
+			case AuWbrCreate_PMFSRRV:
 				AuDbg("%llu watermark, %d sec\n",
 					  u.create->mfsrr_watermark,
 					  u.create->mfs_second);
@@ -596,7 +715,7 @@
 	char *p;
 
 	add->bindex = bindex;
-	add->perm = AuBrPerm_Last;
+	add->perm = AuBrPerm_RO;
 	add->pathname = opt_str;
 	p = strchr(opt_str, '=');
 	if (p) {
@@ -1029,7 +1148,7 @@
 			break;
 
 		case Opt_ignore:
-			pr_warning("ignored %s\n", opt_str);
+			pr_warn("ignored %s\n", opt_str);
 			/*FALLTHROUGH*/
 		case Opt_ignore_silent:
 			skipped = 1;
@@ -1081,6 +1200,8 @@
 	switch (create->wbr_create) {
 	case AuWbrCreate_MFSRRV:
 	case AuWbrCreate_MFSRR:
+	case AuWbrCreate_PMFSRR:
+	case AuWbrCreate_PMFSRRV:
 		sbinfo->si_wbr_mfs.mfsrr_watermark = create->mfsrr_watermark;
 		/*FALLTHROUGH*/
 	case AuWbrCreate_MFS:
@@ -1365,14 +1486,14 @@
 
 	if (!(sb_flags & MS_RDONLY)) {
 		if (unlikely(!au_br_writable(au_sbr_perm(sb, 0))))
-			pr_warning("first branch should be rw\n");
+			pr_warn("first branch should be rw\n");
 		if (unlikely(au_opt_test(sbinfo->si_mntflags, SHWH)))
-			pr_warning("shwh should be used with ro\n");
+			pr_warn("shwh should be used with ro\n");
 	}
 
 	if (au_opt_test((sbinfo->si_mntflags | pending), UDBA_HNOTIFY)
 	    && !au_opt_test(sbinfo->si_mntflags, XINO))
-		pr_warning("udba=*notify requires xino\n");
+		pr_warn("udba=*notify requires xino\n");
 
 	err = 0;
 	root = sb->s_root;
@@ -1389,19 +1510,13 @@
 		if (wbr)
 			wbr_wh_read_lock(wbr);
 
-		switch (br->br_perm) {
-		case AuBrPerm_RO:
-		case AuBrPerm_ROWH:
-		case AuBrPerm_RR:
-		case AuBrPerm_RRWH:
+		if (!au_br_writable(br->br_perm)) {
 			do_free = !!wbr;
 			skip = (!wbr
 				|| (!wbr->wbr_whbase
 				    && !wbr->wbr_plink
 				    && !wbr->wbr_orph));
-			break;
-
-		case AuBrPerm_RWNoLinkWH:
+		} else if (!au_br_wh_linkable(br->br_perm)) {
 			/* skip = (!br->br_whbase && !br->br_orph); */
 			skip = (!wbr || !wbr->wbr_whbase);
 			if (skip && wbr) {
@@ -1410,9 +1525,7 @@
 				else
 					skip = !wbr->wbr_plink;
 			}
-			break;
-
-		case AuBrPerm_RW:
+		} else {
 			/* skip = (br->br_whbase && br->br_ohph); */
 			skip = (wbr && wbr->wbr_whbase);
 			if (skip) {
@@ -1421,10 +1534,6 @@
 				else
 					skip = !wbr->wbr_plink;
 			}
-			break;
-
-		default:
-			BUG();
 		}
 		if (wbr)
 			wbr_wh_read_unlock(wbr);
@@ -1436,7 +1545,7 @@
 		au_hn_imtx_lock_nested(hdir, AuLsc_I_PARENT);
 		if (wbr)
 			wbr_wh_write_lock(wbr);
-		err = au_wh_init(au_h_dptr(root, bindex), br, sb);
+		err = au_wh_init(br, sb);
 		if (wbr)
 			wbr_wh_write_unlock(wbr);
 		au_hn_imtx_unlock(hdir);
diff -ru --new-file linux-3.x-orig/fs/aufs/opts.h linux-3.x/fs/aufs/opts.h
--- linux-3.x-orig/fs/aufs/opts.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/opts.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
 #ifdef __KERNEL__
 
 #include <linux/path.h>
-#include <linux/aufs_type.h>
 
 struct file;
 struct super_block;
@@ -103,6 +102,8 @@
 	AuWbrCreate_MFSRRV,	/* mfs then rr with seconds */
 	AuWbrCreate_PMFS,	/* parent and mfs */
 	AuWbrCreate_PMFSV,	/* parent and mfs with seconds */
+	AuWbrCreate_PMFSRR,	/* parent, mfs and round-robin */
+	AuWbrCreate_PMFSRRV,	/* plus seconds */
 
 	AuWbrCreate_Def = AuWbrCreate_TDP
 };
@@ -190,7 +191,7 @@
 
 /* ---------------------------------------------------------------------- */
 
-const char *au_optstr_br_perm(int brperm);
+char *au_optstr_br_perm(int brperm);
 const char *au_optstr_udba(int udba);
 const char *au_optstr_wbr_copyup(int wbr_copyup);
 const char *au_optstr_wbr_create(int wbr_create);
diff -ru --new-file linux-3.x-orig/fs/aufs/plink.c linux-3.x/fs/aufs/plink.c
--- linux-3.x-orig/fs/aufs/plink.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/plink.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -119,19 +119,13 @@
 
 /* ---------------------------------------------------------------------- */
 
-struct pseudo_link {
-	union {
-		struct list_head list;
-		struct rcu_head rcu;
-	};
-	struct inode *inode;
-};
-
 #ifdef CONFIG_AUFS_DEBUG
 void au_plink_list(struct super_block *sb)
 {
+	int i;
 	struct au_sbinfo *sbinfo;
-	struct list_head *plink_list;
+	struct hlist_head *plink_hlist;
+	struct hlist_node *pos;
 	struct pseudo_link *plink;
 
 	SiMustAnyLock(sb);
@@ -140,20 +134,23 @@
 	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
 	AuDebugOn(au_plink_maint(sb, AuLock_NOPLM));
 
-	plink_list = &sbinfo->si_plink.head;
-	rcu_read_lock();
-	list_for_each_entry_rcu(plink, plink_list, list)
-		AuDbg("%lu\n", plink->inode->i_ino);
-	rcu_read_unlock();
+	for (i = 0; i < AuPlink_NHASH; i++) {
+		plink_hlist = &sbinfo->si_plink[i].head;
+		rcu_read_lock();
+		hlist_for_each_entry_rcu(plink, pos, plink_hlist, hlist)
+			AuDbg("%lu\n", plink->inode->i_ino);
+		rcu_read_unlock();
+	}
 }
 #endif
 
 /* is the inode pseudo-linked? */
 int au_plink_test(struct inode *inode)
 {
-	int found;
+	int found, i;
 	struct au_sbinfo *sbinfo;
-	struct list_head *plink_list;
+	struct hlist_head *plink_hlist;
+	struct hlist_node *pos;
 	struct pseudo_link *plink;
 
 	sbinfo = au_sbi(inode->i_sb);
@@ -162,9 +159,10 @@
 	AuDebugOn(au_plink_maint(inode->i_sb, AuLock_NOPLM));
 
 	found = 0;
-	plink_list = &sbinfo->si_plink.head;
+	i = au_plink_hash(inode->i_ino);
+	plink_hlist = &sbinfo->si_plink[i].head;
 	rcu_read_lock();
-	list_for_each_entry_rcu(plink, plink_list, list)
+	hlist_for_each_entry_rcu(plink, pos, plink_hlist, hlist)
 		if (plink->inode == inode) {
 			found = 1;
 			break;
@@ -262,7 +260,7 @@
 {
 	int err;
 	struct path h_path = {
-		.mnt = br->br_mnt
+		.mnt = au_br_mnt(br)
 	};
 	struct inode *h_dir;
 
@@ -347,7 +345,7 @@
 static void do_put_plink(struct pseudo_link *plink, int do_del)
 {
 	if (do_del)
-		list_del(&plink->list);
+		hlist_del(&plink->hlist);
 	iput(plink->inode);
 	kfree(plink);
 }
@@ -370,30 +368,24 @@
 {
 	struct super_block *sb;
 	struct au_sbinfo *sbinfo;
-	struct list_head *plink_list;
+	struct hlist_head *plink_hlist;
+	struct hlist_node *pos;
 	struct pseudo_link *plink, *tmp;
-	int found, err, cnt;
+	struct au_sphlhead *sphl;
+	int found, err, cnt, i;
 
 	sb = inode->i_sb;
 	sbinfo = au_sbi(sb);
 	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
 	AuDebugOn(au_plink_maint(sb, AuLock_NOPLM));
 
-	cnt = 0;
-	found = 0;
-	plink_list = &sbinfo->si_plink.head;
-	rcu_read_lock();
-	list_for_each_entry_rcu(plink, plink_list, list) {
-		cnt++;
-		if (plink->inode == inode) {
-			found = 1;
-			break;
-		}
-	}
-	rcu_read_unlock();
+	found = au_plink_test(inode);
 	if (found)
 		return;
 
+	i = au_plink_hash(inode->i_ino);
+	sphl = sbinfo->si_plink + i;
+	plink_hlist = &sphl->head;
 	tmp = kmalloc(sizeof(*plink), GFP_NOFS);
 	if (tmp)
 		tmp->inode = au_igrab(inode);
@@ -402,20 +394,22 @@
 		goto out;
 	}
 
-	spin_lock(&sbinfo->si_plink.spin);
-	list_for_each_entry(plink, plink_list, list) {
+	spin_lock(&sphl->spin);
+	hlist_for_each_entry(plink, pos, plink_hlist, hlist) {
 		if (plink->inode == inode) {
 			found = 1;
 			break;
 		}
 	}
 	if (!found)
-		list_add_rcu(&tmp->list, plink_list);
-	spin_unlock(&sbinfo->si_plink.spin);
+		hlist_add_head_rcu(&tmp->hlist, plink_hlist);
+	spin_unlock(&sphl->spin);
 	if (!found) {
-		cnt++;
-		WARN_ONCE(cnt > AUFS_PLINK_WARN,
-			  "unexpectedly many pseudo links, %d\n", cnt);
+		cnt = au_sphl_count(sphl);
+#define msg "unexpectedly unblanced or too many pseudo-links"
+		if (cnt > AUFS_PLINK_WARN)
+			AuWarn1(msg ", %d\n", cnt);
+#undef msg
 		err = whplink(h_dentry, inode, bindex, au_sbr(sb, bindex));
 	} else {
 		do_put_plink(tmp, 0);
@@ -424,9 +418,9 @@
 
 out:
 	if (unlikely(err)) {
-		pr_warning("err %d, damaged pseudo link.\n", err);
+		pr_warn("err %d, damaged pseudo link.\n", err);
 		if (tmp) {
-			au_spl_del_rcu(&tmp->list, &sbinfo->si_plink);
+			au_sphl_del_rcu(&tmp->hlist, sphl);
 			call_rcu(&tmp->rcu, do_put_plink_rcu);
 		}
 	}
@@ -435,9 +429,11 @@
 /* free all plinks */
 void au_plink_put(struct super_block *sb, int verbose)
 {
+	int i, warned;
 	struct au_sbinfo *sbinfo;
-	struct list_head *plink_list;
-	struct pseudo_link *plink, *tmp;
+	struct hlist_head *plink_hlist;
+	struct hlist_node *pos, *tmp;
+	struct pseudo_link *plink;
 
 	SiMustWriteLock(sb);
 
@@ -445,12 +441,18 @@
 	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
 	AuDebugOn(au_plink_maint(sb, AuLock_NOPLM));
 
-	plink_list = &sbinfo->si_plink.head;
 	/* no spin_lock since sbinfo is write-locked */
-	WARN(verbose && !list_empty(plink_list), "pseudo-link is not flushed");
-	list_for_each_entry_safe(plink, tmp, plink_list, list)
-		do_put_plink(plink, 0);
-	INIT_LIST_HEAD(plink_list);
+	warned = 0;
+	for (i = 0; i < AuPlink_NHASH; i++) {
+		plink_hlist = &sbinfo->si_plink[i].head;
+		if (!warned && verbose && !hlist_empty(plink_hlist)) {
+			pr_warn("pseudo-link is not flushed");
+			warned = 1;
+		}
+		hlist_for_each_entry_safe(plink, pos, tmp, plink_hlist, hlist)
+			do_put_plink(plink, 0);
+		INIT_HLIST_HEAD(plink_hlist);
+	}
 }
 
 void au_plink_clean(struct super_block *sb, int verbose)
@@ -464,15 +466,44 @@
 	aufs_write_unlock(root);
 }
 
+static int au_plink_do_half_refresh(struct inode *inode, aufs_bindex_t br_id)
+{
+	int do_put;
+	aufs_bindex_t bstart, bend, bindex;
+
+	do_put = 0;
+	bstart = au_ibstart(inode);
+	bend = au_ibend(inode);
+	if (bstart >= 0) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			if (!au_h_iptr(inode, bindex)
+			    || au_ii_br_id(inode, bindex) != br_id)
+				continue;
+			au_set_h_iptr(inode, bindex, NULL, 0);
+			do_put = 1;
+			break;
+		}
+		if (do_put)
+			for (bindex = bstart; bindex <= bend; bindex++)
+				if (au_h_iptr(inode, bindex)) {
+					do_put = 0;
+					break;
+				}
+	} else
+		do_put = 1;
+
+	return do_put;
+}
+
 /* free the plinks on a branch specified by @br_id */
 void au_plink_half_refresh(struct super_block *sb, aufs_bindex_t br_id)
 {
 	struct au_sbinfo *sbinfo;
-	struct list_head *plink_list;
-	struct pseudo_link *plink, *tmp;
+	struct hlist_head *plink_hlist;
+	struct hlist_node *pos, *tmp;
+	struct pseudo_link *plink;
 	struct inode *inode;
-	aufs_bindex_t bstart, bend, bindex;
-	unsigned char do_put;
+	int i, do_put;
 
 	SiMustWriteLock(sb);
 
@@ -480,36 +511,17 @@
 	AuDebugOn(!au_opt_test(au_mntflags(sb), PLINK));
 	AuDebugOn(au_plink_maint(sb, AuLock_NOPLM));
 
-	plink_list = &sbinfo->si_plink.head;
 	/* no spin_lock since sbinfo is write-locked */
-	list_for_each_entry_safe(plink, tmp, plink_list, list) {
-		do_put = 0;
-		inode = au_igrab(plink->inode);
-		ii_write_lock_child(inode);
-		bstart = au_ibstart(inode);
-		bend = au_ibend(inode);
-		if (bstart >= 0) {
-			for (bindex = bstart; bindex <= bend; bindex++) {
-				if (!au_h_iptr(inode, bindex)
-				    || au_ii_br_id(inode, bindex) != br_id)
-					continue;
-				au_set_h_iptr(inode, bindex, NULL, 0);
-				do_put = 1;
-				break;
-			}
-		} else
-			do_put_plink(plink, 1);
-
-		if (do_put) {
-			for (bindex = bstart; bindex <= bend; bindex++)
-				if (au_h_iptr(inode, bindex)) {
-					do_put = 0;
-					break;
-				}
+	for (i = 0; i < AuPlink_NHASH; i++) {
+		plink_hlist = &sbinfo->si_plink[i].head;
+		hlist_for_each_entry_safe(plink, pos, tmp, plink_hlist, hlist) {
+			inode = au_igrab(plink->inode);
+			ii_write_lock_child(inode);
+			do_put = au_plink_do_half_refresh(inode, br_id);
 			if (do_put)
 				do_put_plink(plink, 1);
+			ii_write_unlock(inode);
+			iput(inode);
 		}
-		ii_write_unlock(inode);
-		iput(inode);
 	}
 }
diff -ru --new-file linux-3.x-orig/fs/aufs/poll.c linux-3.x/fs/aufs/poll.c
--- linux-3.x-orig/fs/aufs/poll.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/poll.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -ru --new-file linux-3.x-orig/fs/aufs/procfs.c linux-3.x/fs/aufs/procfs.c
--- linux-3.x-orig/fs/aufs/procfs.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/procfs.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Junjiro R. Okajima
+ * Copyright (C) 2010-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -56,6 +56,7 @@
 		goto out;
 
 	sb = NULL;
+	/* don't use au_sbilist_lock() here */
 	spin_lock(&au_sbilist.spin);
 	list_for_each_entry(sbinfo, &au_sbilist.head, si_list)
 		if (id == sysaufs_si_id(sbinfo)) {
@@ -113,7 +114,7 @@
 	} else if (unlikely(strncmp("si=", buf, 3)))
 		goto out;
 
-	err = strict_strtoul(buf + 3, 16, &id);
+	err = kstrtoul(buf + 3, 16, &id);
 	if (unlikely(err))
 		goto out;
 
diff -ru --new-file linux-3.x-orig/fs/aufs/rdu.c linux-3.x/fs/aufs/rdu.c
--- linux-3.x-orig/fs/aufs/rdu.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/rdu.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -23,8 +23,6 @@
 #include <linux/compat.h>
 #include <linux/fs_stack.h>
 #include <linux/security.h>
-#include <linux/uaccess.h>
-#include <linux/aufs_type.h>
 #include "aufs.h"
 
 /* bits for struct aufs_rdu.flags */
@@ -66,6 +64,7 @@
 		if (unlikely(nlen > AUFS_MAX_NAMELEN))
 			ent.type = DT_UNKNOWN;
 
+		/* unnecessary to support mmap_sem since this is a dir */
 		err = -EFAULT;
 		if (copy_to_user(arg->ent.e, &ent, sizeof(ent)))
 			goto out;
@@ -239,6 +238,7 @@
 	sb = file->f_dentry->d_sb;
 	si_read_lock(sb, AuLock_FLUSH);
 	while (nent-- > 0) {
+		/* unnecessary to support mmap_sem since this is a dir */
 		err = copy_from_user(&ent, u->e, sizeof(ent));
 		if (!err)
 			err = !access_ok(VERIFY_WRITE, &u->e->ino, sizeof(ino));
diff -ru --new-file linux-3.x-orig/fs/aufs/rwsem.h linux-3.x/fs/aufs/rwsem.h
--- linux-3.x-orig/fs/aufs/rwsem.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/rwsem.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,7 +25,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/rwsem.h>
 #include "debug.h"
 
 struct au_rwsem {
diff -ru --new-file linux-3.x-orig/fs/aufs/sbinfo.c linux-3.x/fs/aufs/sbinfo.c
--- linux-3.x-orig/fs/aufs/sbinfo.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/sbinfo.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,7 +20,6 @@
  * superblock private data
  */
 
-#include <linux/jiffies.h>
 #include "aufs.h"
 
 /*
@@ -28,11 +27,13 @@
  */
 void au_si_free(struct kobject *kobj)
 {
+	int i;
 	struct au_sbinfo *sbinfo;
 	char *locked __maybe_unused; /* debug only */
 
 	sbinfo = container_of(kobj, struct au_sbinfo, si_kobj);
-	AuDebugOn(!list_empty(&sbinfo->si_plink.head));
+	for (i = 0; i < AuPlink_NHASH; i++)
+		AuDebugOn(!hlist_empty(&sbinfo->si_plink[i].head));
 	AuDebugOn(atomic_read(&sbinfo->si_nowait.nw_len));
 
 	au_rw_write_lock(&sbinfo->si_rwsem);
@@ -54,7 +55,7 @@
 
 int au_si_alloc(struct super_block *sb)
 {
-	int err;
+	int err, i;
 	struct au_sbinfo *sbinfo;
 	static struct lock_class_key aufs_si;
 
@@ -90,6 +91,7 @@
 	atomic_long_set(&sbinfo->si_nfiles, 0);
 
 	sbinfo->si_bend = -1;
+	sbinfo->si_last_br_id = AUFS_BRANCH_MAX / 2;
 
 	sbinfo->si_wbr_copyup = AuWbrCopyup_Def;
 	sbinfo->si_wbr_create = AuWbrCreate_Def;
@@ -98,6 +100,9 @@
 
 	sbinfo->si_mntflags = au_opts_plink(AuOpt_Def);
 
+	sbinfo->si_xino_jiffy = jiffies;
+	sbinfo->si_xino_expire
+		= msecs_to_jiffies(AUFS_XINO_DEF_SEC * MSEC_PER_SEC);
 	mutex_init(&sbinfo->si_xib_mtx);
 	sbinfo->si_xino_brid = -1;
 	/* leave si_xib_last_pindex and si_xib_next_bit */
@@ -107,7 +112,8 @@
 	sbinfo->si_rdhash = AUFS_RDHASH_DEF;
 	sbinfo->si_dirwh = AUFS_DIRWH_DEF;
 
-	au_spl_init(&sbinfo->si_plink);
+	for (i = 0; i < AuPlink_NHASH; i++)
+		au_sphl_init(sbinfo->si_plink + i);
 	init_waitqueue_head(&sbinfo->si_plink_wq);
 	spin_lock_init(&sbinfo->si_plink_maint_lock);
 
@@ -158,7 +164,7 @@
 
 	gen = ++au_sbi(sb)->si_generation;
 	au_update_digen(sb->s_root);
-	au_update_iigen(sb->s_root->d_inode);
+	au_update_iigen(sb->s_root->d_inode, /*half*/0);
 	sb->s_root->d_inode->i_version++;
 	return gen;
 }
diff -ru --new-file linux-3.x-orig/fs/aufs/spl.h linux-3.x/fs/aufs/spl.h
--- linux-3.x-orig/fs/aufs/spl.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/spl.h	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,10 +25,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <linux/rculist.h>
-
 struct au_splhead {
 	spinlock_t		spin;
 	struct list_head	head;
@@ -62,5 +58,55 @@
 	spin_unlock(&spl->spin);
 }
 
+/* ---------------------------------------------------------------------- */
+
+struct au_sphlhead {
+	spinlock_t		spin;
+	struct hlist_head	head;
+};
+
+static inline void au_sphl_init(struct au_sphlhead *sphl)
+{
+	spin_lock_init(&sphl->spin);
+	INIT_HLIST_HEAD(&sphl->head);
+}
+
+static inline void au_sphl_add(struct hlist_node *hlist,
+			       struct au_sphlhead *sphl)
+{
+	spin_lock(&sphl->spin);
+	hlist_add_head(hlist, &sphl->head);
+	spin_unlock(&sphl->spin);
+}
+
+static inline void au_sphl_del(struct hlist_node *hlist,
+			       struct au_sphlhead *sphl)
+{
+	spin_lock(&sphl->spin);
+	hlist_del(hlist);
+	spin_unlock(&sphl->spin);
+}
+
+static inline void au_sphl_del_rcu(struct hlist_node *hlist,
+				   struct au_sphlhead *sphl)
+{
+	spin_lock(&sphl->spin);
+	hlist_del_rcu(hlist);
+	spin_unlock(&sphl->spin);
+}
+
+static inline unsigned long au_sphl_count(struct au_sphlhead *sphl)
+{
+	unsigned long cnt;
+	struct hlist_node *pos;
+
+	cnt = 0;
+	spin_lock(&sphl->spin);
+	hlist_for_each(pos, &sphl->head)
+		cnt++;
+	spin_unlock(&sphl->spin);
+	return cnt;
+}
+
 #endif /* __KERNEL__ */
 #endif /* __AUFS_SPL_H__ */
diff -ru --new-file linux-3.x-orig/fs/aufs/super.c linux-3.x/fs/aufs/super.c
--- linux-3.x-orig/fs/aufs/super.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/super.c	2014-12-23 17:23:09.051087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,8 +20,7 @@
  * mount and super_block operations
  */
 
-#include <linux/buffer_head.h>
-#include <linux/jiffies.h>
+#include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/statfs.h>
@@ -98,18 +97,26 @@
 	struct path path;
 	struct au_hdentry *hdp;
 	struct au_branch *br;
+	char *perm;
 
 	err = 0;
 	bend = au_sbend(sb);
 	hdp = au_di(sb->s_root)->di_hdentry;
 	for (bindex = 0; !err && bindex <= bend; bindex++) {
 		br = au_sbr(sb, bindex);
-		path.mnt = br->br_mnt;
+		path.mnt = au_br_mnt(br);
 		path.dentry = hdp[bindex].hd_dentry;
 		err = au_seq_path(seq, &path);
-		if (err > 0)
-			err = seq_printf(seq, "=%s",
-					 au_optstr_br_perm(br->br_perm));
+		if (err > 0) {
+			perm = au_optstr_br_perm(br->br_perm);
+			if (perm) {
+				err = seq_printf(seq, "=%s", perm);
+				kfree(perm);
+				if (err == -1)
+					err = -E2BIG;
+			} else
+				err = -ENOMEM;
+		}
 		if (!err && bindex != bend)
 			err = seq_putc(seq, ':');
 	}
@@ -124,14 +131,14 @@
 
 	AuRwMustAnyLock(&sbinfo->si_rwsem);
 
-	seq_printf(m, ",create=");
+	seq_puts(m, ",create=");
 	pat = au_optstr_wbr_create(v);
 	switch (v) {
 	case AuWbrCreate_TDP:
 	case AuWbrCreate_RR:
 	case AuWbrCreate_MFS:
 	case AuWbrCreate_PMFS:
-		seq_printf(m, pat);
+		seq_puts(m, pat);
 		break;
 	case AuWbrCreate_MFSV:
 		seq_printf(m, /*pat*/"mfs:%lu",
@@ -153,6 +160,16 @@
 			   jiffies_to_msecs(sbinfo->si_wbr_mfs.mfs_expire)
 			   / MSEC_PER_SEC);
 		break;
+	case AuWbrCreate_PMFSRR:
+		seq_printf(m, /*pat*/"pmfsrr:%llu",
+			   sbinfo->si_wbr_mfs.mfsrr_watermark);
+		break;
+	case AuWbrCreate_PMFSRRV:
+		seq_printf(m, /*pat*/"pmfsrr:%llu:%lu",
+			   sbinfo->si_wbr_mfs.mfsrr_watermark,
+			   jiffies_to_msecs(sbinfo->si_wbr_mfs.mfs_expire)
+			   / MSEC_PER_SEC);
+		break;
 	}
 }
 
@@ -298,7 +315,18 @@
 
 	old = a;
 	a += b;
-	if (old < a)
+	if (old <= a)
+		return a;
+	return ULLONG_MAX;
+}
+
+static u64 au_mul_till_max(u64 a, long mul)
+{
+	u64 old;
+
+	old = a;
+	a *= mul;
+	if (old <= a)
 		return a;
 	return ULLONG_MAX;
 }
@@ -306,25 +334,26 @@
 static int au_statfs_sum(struct super_block *sb, struct kstatfs *buf)
 {
 	int err;
+	long bsize, factor;
 	u64 blocks, bfree, bavail, files, ffree;
 	aufs_bindex_t bend, bindex, i;
 	unsigned char shared;
 	struct path h_path;
 	struct super_block *h_sb;
 
+	err = 0;
+	bsize = LONG_MAX;
+	files = 0;
+	ffree = 0;
 	blocks = 0;
 	bfree = 0;
 	bavail = 0;
-	files = 0;
-	ffree = 0;
-
-	err = 0;
 	bend = au_sbend(sb);
-	for (bindex = bend; bindex >= 0; bindex--) {
+	for (bindex = 0; bindex <= bend; bindex++) {
 		h_path.mnt = au_sbr_mnt(sb, bindex);
 		h_sb = h_path.mnt->mnt_sb;
 		shared = 0;
-		for (i = bindex + 1; !shared && i <= bend; i++)
+		for (i = 0; !shared && i < bindex; i++)
 			shared = (au_sbr_sb(sb, i) == h_sb);
 		if (shared)
 			continue;
@@ -335,18 +364,36 @@
 		if (unlikely(err))
 			goto out;
 
-		blocks = au_add_till_max(blocks, buf->f_blocks);
-		bfree = au_add_till_max(bfree, buf->f_bfree);
-		bavail = au_add_till_max(bavail, buf->f_bavail);
+		if (bsize > buf->f_bsize) {
+			/*
+			 * we will reduce bsize, so we have to expand blocks
+			 * etc. to match them again
+			 */
+			factor = (bsize / buf->f_bsize);
+			blocks = au_mul_till_max(blocks, factor);
+			bfree = au_mul_till_max(bfree, factor);
+			bavail = au_mul_till_max(bavail, factor);
+			bsize = buf->f_bsize;
+		}
+
+		factor = (buf->f_bsize / bsize);
+		blocks = au_add_till_max(blocks,
+				au_mul_till_max(buf->f_blocks, factor));
+		bfree = au_add_till_max(bfree,
+				au_mul_till_max(buf->f_bfree, factor));
+		bavail = au_add_till_max(bavail,
+				au_mul_till_max(buf->f_bavail, factor));
 		files = au_add_till_max(files, buf->f_files);
 		ffree = au_add_till_max(ffree, buf->f_ffree);
 	}
 
+	buf->f_bsize = bsize;
 	buf->f_blocks = blocks;
 	buf->f_bfree = bfree;
 	buf->f_bavail = bavail;
 	buf->f_files = files;
 	buf->f_ffree = ffree;
+	buf->f_frsize = 0;
 
 out:
 	return err;
@@ -382,6 +429,36 @@
 
 /* ---------------------------------------------------------------------- */
 
+static int aufs_sync_fs(struct super_block *sb, int wait)
+{
+	int err, e;
+	aufs_bindex_t bend, bindex;
+	struct au_branch *br;
+	struct super_block *h_sb;
+
+	err = 0;
+	si_noflush_read_lock(sb);
+	bend = au_sbend(sb);
+	for (bindex = 0; bindex <= bend; bindex++) {
+		br = au_sbr(sb, bindex);
+		if (!au_br_writable(br->br_perm))
+			continue;
+
+		h_sb = au_sbr_sb(sb, bindex);
+		if (h_sb->s_op->sync_fs) {
+			e = h_sb->s_op->sync_fs(h_sb, wait);
+			if (unlikely(e && !err))
+				err = e;
+			/* go on even if an error happens */
+		}
+	}
+	si_read_unlock(sb);
+
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
 /* final actions when unmounting a file system */
 static void aufs_put_super(struct super_block *sb)
 {
@@ -592,7 +669,7 @@
 	sigen = au_sigen(sb);
 	for (ull = 0; ull < max; ull++) {
 		inode = array[ull];
-		if (au_iigen(inode) != sigen) {
+		if (au_iigen(inode, NULL) != sigen) {
 			ii_write_lock_child(inode);
 			e = au_refresh_hinode_self(inode);
 			ii_write_unlock(inode);
@@ -745,6 +822,7 @@
 	.show_options	= aufs_show_options,
 	.statfs		= aufs_statfs,
 	.put_super	= aufs_put_super,
+	.sync_fs	= aufs_sync_fs,
 	.remount_fs	= aufs_remount_fs
 };
 
@@ -765,7 +843,7 @@
 	inode->i_op = &aufs_dir_iop;
 	inode->i_fop = &aufs_dir_fop;
 	inode->i_mode = S_IFDIR;
-	inode->i_nlink = 2;
+	set_nlink(inode, 2);
 	unlock_new_inode(inode);
 
 	root = d_alloc_root(inode);
@@ -912,6 +990,7 @@
 		if (au_opt_test(sbinfo->si_mntflags, PLINK))
 			au_plink_put(sb, /*verbose*/1);
 		au_xino_clr(sb);
+		sbinfo->si_sb = NULL;
 		aufs_write_unlock(sb->s_root);
 		au_nwt_flush(&sbinfo->si_nowait);
 	}
diff -ru --new-file linux-3.x-orig/fs/aufs/super.h linux-3.x/fs/aufs/super.h
--- linux-3.x-orig/fs/aufs/super.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/super.h	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
 #ifdef __KERNEL__
 
 #include <linux/fs.h>
-#include <linux/aufs_type.h>
 #include "rwsem.h"
 #include "spl.h"
 #include "wkq.h"
@@ -40,8 +39,15 @@
 	int (*copyup)(struct dentry *dentry);
 };
 
+#define AuWbr_DIR	1		/* target is a dir */
+#define AuWbr_PARENT	(1 << 1)	/* always require a parent */
+
+#define au_ftest_wbr(flags, name)	((flags) & AuWbr_##name)
+#define au_fset_wbr(flags, name)	{ (flags) |= AuWbr_##name; }
+#define au_fclr_wbr(flags, name)	{ (flags) &= ~AuWbr_##name; }
+
 struct au_wbr_create_operations {
-	int (*create)(struct dentry *dentry, int isdir);
+	int (*create)(struct dentry *dentry, unsigned int flags);
 	int (*init)(struct super_block *sb);
 	int (*fin)(struct super_block *sb);
 };
@@ -56,6 +62,20 @@
 	unsigned long long	mfsrr_watermark;
 };
 
+struct pseudo_link {
+	union {
+		struct hlist_node hlist;
+		struct rcu_head rcu;
+	};
+	struct inode *inode;
+};
+
+#define AuPlink_NHASH 100
+static inline int au_plink_hash(ino_t ino)
+{
+	return ino % AuPlink_NHASH;
+}
+
 struct au_branch;
 struct au_sbinfo {
 	/* nowait tasks in the system-wide workqueue */
@@ -117,6 +137,8 @@
 	unsigned long		si_xib_last_pindex;
 	int			si_xib_next_bit;
 	aufs_bindex_t		si_xino_brid;
+	unsigned long		si_xino_jiffy;
+	unsigned long		si_xino_expire;
 	/* reserved for future use */
 	/* unsigned long long	si_xib_limit; */	/* Max xib file size */
 
@@ -146,7 +168,7 @@
 	/* int			si_rendir; */
 
 	/* pseudo_link list */
-	struct au_splhead	si_plink;
+	struct au_sphlhead	si_plink[AuPlink_NHASH];
 	wait_queue_head_t	si_plink_wq;
 	spinlock_t		si_plink_maint_lock;
 	pid_t			si_plink_maint_pid;
@@ -159,7 +181,9 @@
 	 */
 	struct kobject		si_kobj;
 #ifdef CONFIG_DEBUG_FS
-	struct dentry		 *si_dbgaufs, *si_dbgaufs_xib;
+	struct dentry		 *si_dbgaufs;
+	struct dentry		 *si_dbgaufs_plink;
+	struct dentry		 *si_dbgaufs_xib;
 #ifdef CONFIG_AUFS_EXPORT
 	struct dentry		 *si_dbgaufs_xigen;
 #endif
@@ -267,16 +291,8 @@
 /* ---------------------------------------------------------------------- */
 
 #ifdef CONFIG_AUFS_EXPORT
+int au_test_nfsd(void);
 void au_export_init(struct super_block *sb);
-
-static inline int au_test_nfsd(void)
-{
-	struct task_struct *tsk = current;
-
-	return (tsk->flags & PF_KTHREAD)
-		&& !strcmp(tsk->comm, "nfsd");
-}
-
 void au_xigen_inc(struct inode *inode);
 int au_xigen_new(struct inode *inode);
 int au_xigen_set(struct super_block *sb, struct file *base);
@@ -289,8 +305,8 @@
 	return -ESTALE;
 }
 #else
-AuStubVoid(au_export_init, struct super_block *sb)
 AuStubInt0(au_test_nfsd, void)
+AuStubVoid(au_export_init, struct super_block *sb)
 AuStubVoid(au_xigen_inc, struct inode *inode)
 AuStubInt0(au_xigen_new, struct inode *inode)
 AuStubInt0(au_xigen_set, struct super_block *sb, struct file *base)
@@ -321,10 +337,30 @@
 {
 	au_spl_del(&au_sbi(sb)->si_list, &au_sbilist);
 }
+
+#ifdef CONFIG_AUFS_MAGIC_SYSRQ
+static inline void au_sbilist_lock(void)
+{
+	spin_lock(&au_sbilist.spin);
+}
+
+static inline void au_sbilist_unlock(void)
+{
+	spin_unlock(&au_sbilist.spin);
+}
+#define AuGFP_SBILIST	GFP_ATOMIC
+#else
+AuStubVoid(au_sbilist_lock, void)
+AuStubVoid(au_sbilist_unlock, void)
+#define AuGFP_SBILIST	GFP_NOFS
+#endif /* CONFIG_AUFS_MAGIC_SYSRQ */
 #else
 AuStubVoid(au_sbilist_init, void)
 AuStubVoid(au_sbilist_add, struct super_block*)
 AuStubVoid(au_sbilist_del, struct super_block*)
+AuStubVoid(au_sbilist_lock, void)
+AuStubVoid(au_sbilist_unlock, void)
+#define AuGFP_SBILIST	GFP_NOFS
 #endif
 
 /* ---------------------------------------------------------------------- */
@@ -338,6 +374,7 @@
 	/* AuRwMustWriteLock(&sbinfo->si_rwsem); */
 #ifdef CONFIG_DEBUG_FS
 	sbinfo->si_dbgaufs = NULL;
+	sbinfo->si_dbgaufs_plink = NULL;
 	sbinfo->si_dbgaufs_xib = NULL;
 #ifdef CONFIG_AUFS_EXPORT
 	sbinfo->si_dbgaufs_xigen = NULL;
diff -ru --new-file linux-3.x-orig/fs/aufs/sysaufs.c linux-3.x/fs/aufs/sysaufs.c
--- linux-3.x-orig/fs/aufs/sysaufs.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/sysaufs.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,9 +21,7 @@
  * they are necessary regardless sysfs is disabled.
  */
 
-#include <linux/fs.h>
 #include <linux/random.h>
-#include <linux/sysfs.h>
 #include "aufs.h"
 
 unsigned long sysaufs_si_mask;
diff -ru --new-file linux-3.x-orig/fs/aufs/sysaufs.h linux-3.x/fs/aufs/sysaufs.h
--- linux-3.x-orig/fs/aufs/sysaufs.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/sysaufs.h	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,7 +26,6 @@
 #ifdef __KERNEL__
 
 #include <linux/sysfs.h>
-#include <linux/aufs_type.h>
 #include "module.h"
 
 struct super_block;
diff -ru --new-file linux-3.x-orig/fs/aufs/sysfs.c linux-3.x/fs/aufs/sysfs.c
--- linux-3.x-orig/fs/aufs/sysfs.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/sysfs.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,13 +20,33 @@
  * sysfs interface
  */
 
-#include <linux/fs.h>
-#include <linux/module.h>
 #include <linux/seq_file.h>
-#include <linux/sysfs.h>
 #include "aufs.h"
 
+#ifdef CONFIG_AUFS_FS_MODULE
+/* this entry violates the "one line per file" policy of sysfs */
+static ssize_t config_show(struct kobject *kobj, struct kobj_attribute *attr,
+			   char *buf)
+{
+	ssize_t err;
+	static char *conf =
+/* this file is generated at compiling */
+#include "conf.str"
+		;
+
+	err = snprintf(buf, PAGE_SIZE, conf);
+	if (unlikely(err >= PAGE_SIZE))
+		err = -EFBIG;
+	return err;
+}
+
+static struct kobj_attribute au_config_attr = __ATTR_RO(config);
+#endif
+
 static struct attribute *au_attr[] = {
+#ifdef CONFIG_AUFS_FS_MODULE
+	&au_config_attr.attr,
+#endif
 	NULL,	/* need to NULL terminate the list of attributes */
 };
 
@@ -58,23 +78,45 @@
  * unlinked.
  */
 static int sysaufs_si_br(struct seq_file *seq, struct super_block *sb,
-			 aufs_bindex_t bindex)
+			 aufs_bindex_t bindex, int idx)
 {
+	int err;
 	struct path path;
 	struct dentry *root;
 	struct au_branch *br;
+	char *perm;
 
 	AuDbg("b%d\n", bindex);
 
+	err = 0;
 	root = sb->s_root;
 	di_read_lock_parent(root, !AuLock_IR);
 	br = au_sbr(sb, bindex);
-	path.mnt = br->br_mnt;
-	path.dentry = au_h_dptr(root, bindex);
-	au_seq_path(seq, &path);
-	di_read_unlock(root, !AuLock_IR);
-	seq_printf(seq, "=%s\n", au_optstr_br_perm(br->br_perm));
-	return 0;
+
+	switch (idx) {
+	case AuBrSysfs_BR:
+		path.mnt = au_br_mnt(br);
+		path.dentry = au_h_dptr(root, bindex);
+		au_seq_path(seq, &path);
+		di_read_unlock(root, !AuLock_IR);
+		perm = au_optstr_br_perm(br->br_perm);
+		if (perm) {
+			err = seq_printf(seq, "=%s\n", perm);
+			kfree(perm);
+			if (err == -1)
+				err = -E2BIG;
+		} else
+			err = -ENOMEM;
+		break;
+	case AuBrSysfs_BRID:
+		err = seq_printf(seq, "%d\n", br->br_id);
+		di_read_unlock(root, !AuLock_IR);
+		if (err == -1)
+			err = -E2BIG;
+		break;
+	}
+
+	return err;
 }
 
 /* ---------------------------------------------------------------------- */
@@ -95,13 +137,15 @@
 	return seq;
 }
 
-#define SysaufsBr_PREFIX "br"
+#define SysaufsBr_PREFIX	"br"
+#define SysaufsBrid_PREFIX	"brid"
 
 /* todo: file size may exceed PAGE_SIZE */
 ssize_t sysaufs_si_show(struct kobject *kobj, struct attribute *attr,
 			char *buf)
 {
 	ssize_t err;
+	int idx;
 	long l;
 	aufs_bindex_t bend;
 	struct au_sbinfo *sbinfo;
@@ -143,19 +187,25 @@
 		cattr++;
 	}
 
-	bend = au_sbend(sb);
-	if (!strncmp(name, SysaufsBr_PREFIX, sizeof(SysaufsBr_PREFIX) - 1)) {
+	if (!strncmp(name, SysaufsBrid_PREFIX,
+		     sizeof(SysaufsBrid_PREFIX) - 1)) {
+		idx = AuBrSysfs_BRID;
+		name += sizeof(SysaufsBrid_PREFIX) - 1;
+	} else if (!strncmp(name, SysaufsBr_PREFIX,
+			    sizeof(SysaufsBr_PREFIX) - 1)) {
+		idx = AuBrSysfs_BR;
 		name += sizeof(SysaufsBr_PREFIX) - 1;
-		err = strict_strtol(name, 10, &l);
-		if (!err) {
-			if (l <= bend)
-				err = sysaufs_si_br(seq, sb, (aufs_bindex_t)l);
-			else
-				err = -ENOENT;
-		}
-		goto out_seq;
+	} else
+		  BUG();
+
+	err = kstrtol(name, 10, &l);
+	if (!err) {
+		bend = au_sbend(sb);
+		if (l <= bend)
+			err = sysaufs_si_br(seq, sb, (aufs_bindex_t)l, idx);
+		else
+			err = -ENOENT;
 	}
-	BUG();
 
 out_seq:
 	if (!err) {
@@ -175,17 +225,26 @@
 
 void sysaufs_br_init(struct au_branch *br)
 {
-	struct attribute *attr = &br->br_attr;
-
-	sysfs_attr_init(attr);
-	attr->name = br->br_name;
-	attr->mode = S_IRUGO;
+	int i;
+	struct au_brsysfs *br_sysfs;
+	struct attribute *attr;
+
+	br_sysfs = br->br_sysfs;
+	for (i = 0; i < ARRAY_SIZE(br->br_sysfs); i++) {
+		attr = &br_sysfs->attr;
+		sysfs_attr_init(attr);
+		attr->name = br_sysfs->name;
+		attr->mode = S_IRUGO;
+		br_sysfs++;
+	}
 }
 
 void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)
 {
 	struct au_branch *br;
 	struct kobject *kobj;
+	struct au_brsysfs *br_sysfs;
+	int i;
 	aufs_bindex_t bend;
 
 	dbgaufs_brs_del(sb, bindex);
@@ -197,16 +256,21 @@
 	bend = au_sbend(sb);
 	for (; bindex <= bend; bindex++) {
 		br = au_sbr(sb, bindex);
-		sysfs_remove_file(kobj, &br->br_attr);
+		br_sysfs = br->br_sysfs;
+		for (i = 0; i < ARRAY_SIZE(br->br_sysfs); i++) {
+			sysfs_remove_file(kobj, &br_sysfs->attr);
+			br_sysfs++;
+		}
 	}
 }
 
 void sysaufs_brs_add(struct super_block *sb, aufs_bindex_t bindex)
 {
-	int err;
+	int err, i;
 	aufs_bindex_t bend;
 	struct kobject *kobj;
 	struct au_branch *br;
+	struct au_brsysfs *br_sysfs;
 
 	dbgaufs_brs_add(sb, bindex);
 
@@ -217,11 +281,17 @@
 	bend = au_sbend(sb);
 	for (; bindex <= bend; bindex++) {
 		br = au_sbr(sb, bindex);
-		snprintf(br->br_name, sizeof(br->br_name), SysaufsBr_PREFIX
-			 "%d", bindex);
-		err = sysfs_create_file(kobj, &br->br_attr);
-		if (unlikely(err))
-			pr_warning("failed %s under sysfs(%d)\n",
-				   br->br_name, err);
+		br_sysfs = br->br_sysfs;
+		snprintf(br_sysfs[AuBrSysfs_BR].name, sizeof(br_sysfs->name),
+			 SysaufsBr_PREFIX "%d", bindex);
+		snprintf(br_sysfs[AuBrSysfs_BRID].name, sizeof(br_sysfs->name),
+			 SysaufsBrid_PREFIX "%d", bindex);
+		for (i = 0; i < ARRAY_SIZE(br->br_sysfs); i++) {
+			err = sysfs_create_file(kobj, &br_sysfs->attr);
+			if (unlikely(err))
+				pr_warn("failed %s under sysfs(%d)\n",
+					br_sysfs->name, err);
+			br_sysfs++;
+		}
 	}
 }
diff -ru --new-file linux-3.x-orig/fs/aufs/sysrq.c linux-3.x/fs/aufs/sysrq.c
--- linux-3.x-orig/fs/aufs/sysrq.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/sysrq.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,9 +20,6 @@
  * magic sysrq hanlder
  */
 
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
 /* #include <linux/sysrq.h> */
 #include <linux/writeback.h>
 #include "aufs.h"
@@ -38,16 +35,18 @@
 	plevel = au_plevel;
 	au_plevel = KERN_WARNING;
 
-	sbinfo = au_sbi(sb);
 	/* since we define pr_fmt, call printk directly */
+#define pr(str) printk(KERN_WARNING AUFS_NAME ": " str)
+
+	sbinfo = au_sbi(sb);
 	printk(KERN_WARNING "si=%lx\n", sysaufs_si_id(sbinfo));
-	printk(KERN_WARNING AUFS_NAME ": superblock\n");
+	pr("superblock\n");
 	au_dpri_sb(sb);
 
 #if 0
-	printk(KERN_WARNING AUFS_NAME ": root dentry\n");
+	pr("root dentry\n");
 	au_dpri_dentry(sb->s_root);
-	printk(KERN_WARNING AUFS_NAME ": root inode\n");
+	pr("root inode\n");
 	au_dpri_inode(sb->s_root->d_inode);
 #endif
 
@@ -75,7 +74,7 @@
 #if 1
 	{
 		struct inode *i;
-		printk(KERN_WARNING AUFS_NAME ": isolated inode\n");
+		pr("isolated inode\n");
 		spin_lock(&inode_sb_list_lock);
 		list_for_each_entry(i, &sb->s_inodes, i_sb_list) {
 			spin_lock(&i->i_lock);
@@ -86,7 +85,7 @@
 		spin_unlock(&inode_sb_list_lock);
 	}
 #endif
-	printk(KERN_WARNING AUFS_NAME ": files\n");
+	pr("files\n");
 	lg_global_lock(files_lglock);
 	do_file_list_for_each_entry(sb, file) {
 		umode_t mode;
@@ -95,8 +94,9 @@
 			au_dpri_file(file);
 	} while_file_list_for_each_entry;
 	lg_global_unlock(files_lglock);
-	printk(KERN_WARNING AUFS_NAME ": done\n");
+	pr("done\n");
 
+#undef pr
 	au_plevel = plevel;
 }
 
@@ -112,10 +112,10 @@
 	struct au_sbinfo *sbinfo;
 
 	lockdep_off();
-	spin_lock(&au_sbilist.spin);
+	au_sbilist_lock();
 	list_for_each_entry(sbinfo, &au_sbilist.head, si_list)
 		sysrq_sb(sbinfo->si_sb);
-	spin_unlock(&au_sbilist.spin);
+	au_sbilist_unlock();
 	lockdep_on();
 }
 
diff -ru --new-file linux-3.x-orig/fs/aufs/vdir.c linux-3.x/fs/aufs/vdir.c
--- linux-3.x-orig/fs/aufs/vdir.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/vdir.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,7 +20,6 @@
  * virtual or vertical directory
  */
 
-#include <linux/hash.h>
 #include "aufs.h"
 
 static unsigned int calc_size(int nlen)
diff -ru --new-file linux-3.x-orig/fs/aufs/vfsub.c linux-3.x/fs/aufs/vfsub.c
--- linux-3.x-orig/fs/aufs/vfsub.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/vfsub.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,12 +20,10 @@
  * sub-routines for VFS
  */
 
-#include <linux/file.h>
 #include <linux/ima.h>
 #include <linux/namei.h>
 #include <linux/security.h>
 #include <linux/splice.h>
-#include <linux/uaccess.h>
 #include "aufs.h"
 
 int vfsub_update_h_iattr(struct path *h_path, int *did)
@@ -453,6 +451,7 @@
 
 /* ---------------------------------------------------------------------- */
 
+/* todo: support mmap_sem? */
 ssize_t vfsub_read_u(struct file *file, char __user *ubuf, size_t count,
 		     loff_t *ppos)
 {
@@ -575,6 +574,24 @@
 	return err;
 }
 
+int vfsub_fsync(struct file *file, struct path *path, int datasync)
+{
+	int err;
+
+	/* file can be NULL */
+	lockdep_off();
+	err = vfs_fsync(file, datasync);
+	lockdep_on();
+	if (!err) {
+		if (!path) {
+			AuDebugOn(!file);
+			path = &file->f_path;
+		}
+		vfsub_update_h_iattr(path, /*did*/NULL); /*ignore*/
+	}
+	return err;
+}
+
 /* cf. open.c:do_sys_truncate() and do_sys_ftruncate() */
 int vfsub_trunc(struct path *h_path, loff_t length, unsigned int attr,
 		struct file *h_file)
diff -ru --new-file linux-3.x-orig/fs/aufs/vfsub.h linux-3.x/fs/aufs/vfsub.h
--- linux-3.x-orig/fs/aufs/vfsub.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/vfsub.h	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -178,6 +178,7 @@
 		       loff_t *ppos, size_t len, unsigned int flags);
 int vfsub_trunc(struct path *h_path, loff_t length, unsigned int attr,
 		struct file *h_file);
+int vfsub_fsync(struct file *file, struct path *path, int datasync);
 
 /* ---------------------------------------------------------------------- */
 
diff -ru --new-file linux-3.x-orig/fs/aufs/wbr_policy.c linux-3.x/fs/aufs/wbr_policy.c
--- linux-3.x-orig/fs/aufs/wbr_policy.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/wbr_policy.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,7 +37,7 @@
 	ia.ia_uid = h_isrc->i_uid;
 	ia.ia_gid = h_isrc->i_gid;
 	sbits = !!(ia.ia_mode & (S_ISUID | S_ISGID));
-	au_cpup_attr_flags(h_path->dentry->d_inode, h_isrc);
+	au_cpup_attr_flags(h_path->dentry->d_inode, h_isrc->i_flags);
 	err = vfsub_sio_notify_change(h_path, &ia);
 
 	/* is this nfs only? */
@@ -60,13 +60,8 @@
 #define au_fclr_cpdown(flags, name) \
 	do { (flags) &= ~AuCpdown_##name; } while (0)
 
-struct au_cpdown_dir_args {
-	struct dentry *parent;
-	unsigned int flags;
-};
-
 static int au_cpdown_dir_opq(struct dentry *dentry, aufs_bindex_t bdst,
-			     struct au_cpdown_dir_args *a)
+			     unsigned int *flags)
 {
 	int err;
 	struct dentry *opq_dentry;
@@ -76,7 +71,7 @@
 	if (IS_ERR(opq_dentry))
 		goto out;
 	dput(opq_dentry);
-	au_fset_cpdown(a->flags, DIROPQ);
+	au_fset_cpdown(*flags, DIROPQ);
 
 out:
 	return err;
@@ -97,7 +92,7 @@
 
 	err = 0;
 	if (h_path.dentry->d_inode) {
-		h_path.mnt = br->br_mnt;
+		h_path.mnt = au_br_mnt(br);
 		err = au_wh_unlink_dentry(au_h_iptr(dir, bdst), &h_path,
 					  dentry);
 	}
@@ -108,6 +103,7 @@
 }
 
 static int au_cpdown_dir(struct dentry *dentry, aufs_bindex_t bdst,
+			 struct au_pin *pin,
 			 struct dentry *h_parent, void *arg)
 {
 	int err, rerr;
@@ -115,7 +111,7 @@
 	struct path h_path;
 	struct dentry *parent;
 	struct inode *h_dir, *h_inode, *inode, *dir;
-	struct au_cpdown_dir_args *args = arg;
+	unsigned int *flags = arg;
 
 	bstart = au_dbstart(dentry);
 	/* dentry is di-locked */
@@ -125,7 +121,7 @@
 	AuDebugOn(h_dir != au_h_iptr(dir, bdst));
 	IMustLock(h_dir);
 
-	err = au_lkup_neg(dentry, bdst);
+	err = au_lkup_neg(dentry, bdst, /*wh*/0);
 	if (unlikely(err < 0))
 		goto out;
 	h_path.dentry = au_h_dptr(dentry, bdst);
@@ -134,19 +130,19 @@
 			      S_IRWXU | S_IRUGO | S_IXUGO);
 	if (unlikely(err))
 		goto out_put;
-	au_fset_cpdown(args->flags, MADE_DIR);
+	au_fset_cpdown(*flags, MADE_DIR);
 
 	bopq = au_dbdiropq(dentry);
-	au_fclr_cpdown(args->flags, WHED);
-	au_fclr_cpdown(args->flags, DIROPQ);
+	au_fclr_cpdown(*flags, WHED);
+	au_fclr_cpdown(*flags, DIROPQ);
 	if (au_dbwh(dentry) == bdst)
-		au_fset_cpdown(args->flags, WHED);
-	if (!au_ftest_cpdown(args->flags, PARENT_OPQ) && bopq <= bdst)
-		au_fset_cpdown(args->flags, PARENT_OPQ);
+		au_fset_cpdown(*flags, WHED);
+	if (!au_ftest_cpdown(*flags, PARENT_OPQ) && bopq <= bdst)
+		au_fset_cpdown(*flags, PARENT_OPQ);
 	h_inode = h_path.dentry->d_inode;
 	mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
-	if (au_ftest_cpdown(args->flags, WHED)) {
-		err = au_cpdown_dir_opq(dentry, bdst, args);
+	if (au_ftest_cpdown(*flags, WHED)) {
+		err = au_cpdown_dir_opq(dentry, bdst, flags);
 		if (unlikely(err)) {
 			mutex_unlock(&h_inode->i_mutex);
 			goto out_dir;
@@ -158,7 +154,7 @@
 	if (unlikely(err))
 		goto out_opq;
 
-	if (au_ftest_cpdown(args->flags, WHED)) {
+	if (au_ftest_cpdown(*flags, WHED)) {
 		err = au_cpdown_dir_wh(dentry, h_parent, dir, bdst);
 		if (unlikely(err))
 			goto out_opq;
@@ -173,7 +169,7 @@
 
 	/* revert */
 out_opq:
-	if (au_ftest_cpdown(args->flags, DIROPQ)) {
+	if (au_ftest_cpdown(*flags, DIROPQ)) {
 		mutex_lock_nested(&h_inode->i_mutex, AuLsc_I_CHILD);
 		rerr = au_diropq_remove(dentry, bdst);
 		mutex_unlock(&h_inode->i_mutex);
@@ -185,7 +181,7 @@
 		}
 	}
 out_dir:
-	if (au_ftest_cpdown(args->flags, MADE_DIR)) {
+	if (au_ftest_cpdown(*flags, MADE_DIR)) {
 		rerr = vfsub_sio_rmdir(au_h_iptr(dir, bdst), &h_path);
 		if (unlikely(rerr)) {
 			AuIOErr("failed removing %.*s b%d (%d)\n",
@@ -205,13 +201,10 @@
 int au_cpdown_dirs(struct dentry *dentry, aufs_bindex_t bdst)
 {
 	int err;
-	struct au_cpdown_dir_args args = {
-		.parent	= dget_parent(dentry),
-		.flags	= 0
-	};
+	unsigned int flags;
 
-	err = au_cp_dirs(dentry, bdst, au_cpdown_dir, &args);
-	dput(args.parent);
+	flags = 0;
+	err = au_cp_dirs(dentry, bdst, au_cpdown_dir, &flags);
 
 	return err;
 }
@@ -267,7 +260,8 @@
 }
 
 /* top down parent */
-static int au_wbr_create_tdp(struct dentry *dentry, int isdir __maybe_unused)
+static int au_wbr_create_tdp(struct dentry *dentry,
+			     unsigned int flags __maybe_unused)
 {
 	int err;
 	aufs_bindex_t bstart, bindex;
@@ -356,7 +350,7 @@
 	return err;
 }
 
-static int au_wbr_create_rr(struct dentry *dentry, int isdir)
+static int au_wbr_create_rr(struct dentry *dentry, unsigned int flags)
 {
 	int err, nbr;
 	unsigned int u;
@@ -373,7 +367,7 @@
 	bend = au_sbend(sb);
 	nbr = bend + 1;
 	for (bindex = 0; bindex <= bend; bindex++) {
-		if (!isdir) {
+		if (!au_ftest_wbr(flags, DIR)) {
 			err = atomic_dec_return(next) + 1;
 			/* modulo for 0 is meaningless */
 			if (unlikely(!err))
@@ -400,11 +394,12 @@
 /* ---------------------------------------------------------------------- */
 
 /* most free space */
-static void au_mfs(struct dentry *dentry)
+static void au_mfs(struct dentry *dentry, struct dentry *parent)
 {
 	struct super_block *sb;
 	struct au_branch *br;
 	struct au_wbr_mfs *mfs;
+	struct dentry *h_parent;
 	aufs_bindex_t bindex, bend;
 	int err;
 	unsigned long long b, bavail;
@@ -424,14 +419,26 @@
 	MtxMustLock(&mfs->mfs_lock);
 	mfs->mfs_bindex = -EROFS;
 	mfs->mfsrr_bytes = 0;
-	bend = au_sbend(sb);
-	for (bindex = 0; bindex <= bend; bindex++) {
+	if (!parent) {
+		bindex = 0;
+		bend = au_sbend(sb);
+	} else {
+		bindex = au_dbstart(parent);
+		bend = au_dbtaildir(parent);
+	}
+
+	for (; bindex <= bend; bindex++) {
+		if (parent) {
+			h_parent = au_h_dptr(parent, bindex);
+			if (!h_parent || !h_parent->d_inode)
+				continue;
+		}
 		br = au_sbr(sb, bindex);
 		if (au_br_rdonly(br))
 			continue;
 
 		/* sb->s_root for NFS is unreliable */
-		h_path.mnt = br->br_mnt;
+		h_path.mnt = au_br_mnt(br);
 		h_path.dentry = h_path.mnt->mnt_root;
 		err = vfs_statfs(&h_path, st);
 		if (unlikely(err)) {
@@ -456,9 +463,10 @@
 	kfree(st);
 }
 
-static int au_wbr_create_mfs(struct dentry *dentry, int isdir __maybe_unused)
+static int au_wbr_create_mfs(struct dentry *dentry, unsigned int flags)
 {
 	int err;
+	struct dentry *parent;
 	struct super_block *sb;
 	struct au_wbr_mfs *mfs;
 
@@ -467,14 +475,18 @@
 		goto out;
 
 	sb = dentry->d_sb;
+	parent = NULL;
+	if (au_ftest_wbr(flags, PARENT))
+		parent = dget_parent(dentry);
 	mfs = &au_sbi(sb)->si_wbr_mfs;
 	mutex_lock(&mfs->mfs_lock);
 	if (time_after(jiffies, mfs->mfs_jiffy + mfs->mfs_expire)
 	    || mfs->mfs_bindex < 0
 	    || au_br_rdonly(au_sbr(sb, mfs->mfs_bindex)))
-		au_mfs(dentry);
+		au_mfs(dentry, parent);
 	mutex_unlock(&mfs->mfs_lock);
 	err = mfs->mfs_bindex;
+	dput(parent);
 
 	if (err >= 0)
 		err = au_wbr_nonopq(dentry, err);
@@ -505,17 +517,17 @@
 /* ---------------------------------------------------------------------- */
 
 /* most free space and then round robin */
-static int au_wbr_create_mfsrr(struct dentry *dentry, int isdir)
+static int au_wbr_create_mfsrr(struct dentry *dentry, unsigned int flags)
 {
 	int err;
 	struct au_wbr_mfs *mfs;
 
-	err = au_wbr_create_mfs(dentry, isdir);
+	err = au_wbr_create_mfs(dentry, flags);
 	if (err >= 0) {
 		mfs = &au_sbi(dentry->d_sb)->si_wbr_mfs;
 		mutex_lock(&mfs->mfs_lock);
 		if (mfs->mfsrr_bytes < mfs->mfsrr_watermark)
-			err = au_wbr_create_rr(dentry, isdir);
+			err = au_wbr_create_rr(dentry, flags);
 		mutex_unlock(&mfs->mfs_lock);
 	}
 
@@ -536,7 +548,7 @@
 /* ---------------------------------------------------------------------- */
 
 /* top down parent and most free space */
-static int au_wbr_create_pmfs(struct dentry *dentry, int isdir)
+static int au_wbr_create_pmfs(struct dentry *dentry, unsigned int flags)
 {
 	int err, e2;
 	unsigned long long b;
@@ -545,7 +557,7 @@
 	struct dentry *parent, *h_parent;
 	struct au_branch *br;
 
-	err = au_wbr_create_tdp(dentry, isdir);
+	err = au_wbr_create_tdp(dentry, flags);
 	if (unlikely(err < 0))
 		goto out;
 	parent = dget_parent(dentry);
@@ -554,7 +566,7 @@
 	if (bstart == bend)
 		goto out_parent; /* success */
 
-	e2 = au_wbr_create_mfs(dentry, isdir);
+	e2 = au_wbr_create_mfs(dentry, flags);
 	if (e2 < 0)
 		goto out_parent; /* success */
 
@@ -589,12 +601,46 @@
 
 /* ---------------------------------------------------------------------- */
 
+/*
+ * - top down parent
+ * - most free space with parent
+ * - most free space round-robin regardless parent
+ */
+static int au_wbr_create_pmfsrr(struct dentry *dentry, unsigned int flags)
+{
+	int err;
+	unsigned long long watermark;
+	struct super_block *sb;
+	struct au_branch *br;
+	struct au_wbr_mfs *mfs;
+
+	err = au_wbr_create_pmfs(dentry, flags | AuWbr_PARENT);
+	if (unlikely(err < 0))
+		goto out;
+
+	sb = dentry->d_sb;
+	br = au_sbr(sb, err);
+	mfs = &au_sbi(sb)->si_wbr_mfs;
+	mutex_lock(&mfs->mfs_lock);
+	watermark = mfs->mfsrr_watermark;
+	mutex_unlock(&mfs->mfs_lock);
+	if (br->br_wbr->wbr_bytes < watermark)
+		/* regardless the parent dir */
+		err = au_wbr_create_mfsrr(dentry, flags);
+
+out:
+	AuDbg("b%d\n", err);
+	return err;
+}
+
+/* ---------------------------------------------------------------------- */
+
 /* policies for copyup */
 
 /* top down parent */
 static int au_wbr_copyup_tdp(struct dentry *dentry)
 {
-	return au_wbr_create_tdp(dentry, /*isdir, anything is ok*/0);
+	return au_wbr_create_tdp(dentry, /*flags, anything is ok*/0);
 }
 
 /* bottom up parent */
@@ -696,5 +742,15 @@
 		.create	= au_wbr_create_pmfs,
 		.init	= au_wbr_create_init_mfs,
 		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_PMFSRR] = {
+		.create	= au_wbr_create_pmfsrr,
+		.init	= au_wbr_create_init_mfsrr,
+		.fin	= au_wbr_create_fin_mfs
+	},
+	[AuWbrCreate_PMFSRRV] = {
+		.create	= au_wbr_create_pmfsrr,
+		.init	= au_wbr_create_init_mfsrr,
+		.fin	= au_wbr_create_fin_mfs
 	}
 };
diff -ru --new-file linux-3.x-orig/fs/aufs/whout.c linux-3.x/fs/aufs/whout.c
--- linux-3.x-orig/fs/aufs/whout.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/whout.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,7 +20,6 @@
  * whiteout for logical deletion and opaque directory
  */
 
-#include <linux/fs.h>
 #include "aufs.h"
 
 #define WH_MASK			S_IRUGO
@@ -157,7 +156,7 @@
 			goto out_name;
 		dput(dentry);
 	}
-	/* pr_warning("could not get random name\n"); */
+	/* pr_warn("could not get random name\n"); */
 	dentry = ERR_PTR(-EEXIST);
 	AuDbg("%.*s\n", AuLNPair(&qs));
 	BUG();
@@ -177,7 +176,7 @@
 {
 	int err;
 	struct path h_path = {
-		.mnt = br->br_mnt
+		.mnt = au_br_mnt(br)
 	};
 	struct inode *h_dir;
 	struct dentry *h_parent;
@@ -236,7 +235,7 @@
 {
 	int err;
 	struct path h_path = {
-		.mnt = br->br_mnt
+		.mnt = au_br_mnt(br)
 	};
 
 	err = 0;
@@ -275,8 +274,8 @@
 		mnt_drop_write(whpath->mnt);
 	}
 	if (unlikely(err))
-		pr_warning("failed removing %.*s (%d), ignored.\n",
-			   AuDLNPair(whpath->dentry), err);
+		pr_warn("failed removing %.*s (%d), ignored.\n",
+			AuDLNPair(whpath->dentry), err);
 }
 
 static int test_linkable(struct dentry *h_root)
@@ -437,16 +436,14 @@
 /*
  * initialize the whiteout base file/dir for @br.
  */
-int au_wh_init(struct dentry *h_root, struct au_branch *br,
-	       struct super_block *sb)
+int au_wh_init(struct au_branch *br, struct super_block *sb)
 {
 	int err, i;
 	const unsigned char do_plink
 		= !!au_opt_test(au_mntflags(sb), PLINK);
-	struct path path = {
-		.mnt = br->br_mnt
-	};
 	struct inode *h_dir;
+	struct path path = br->br_path;
+	struct dentry *h_root = path.dentry;
 	struct au_wbr *wbr = br->br_wbr;
 	static const struct qstr base_name[] = {
 		[AuBrWh_BASE] = {
@@ -502,33 +499,21 @@
 		}
 
 	err = 0;
-	switch (br->br_perm) {
-	case AuBrPerm_RO:
-	case AuBrPerm_ROWH:
-	case AuBrPerm_RR:
-	case AuBrPerm_RRWH:
+	if (!au_br_writable(br->br_perm)) {
 		h_dir = h_root->d_inode;
 		au_wh_init_ro(h_dir, base, &path);
-		break;
-
-	case AuBrPerm_RWNoLinkWH:
+	} else if (!au_br_wh_linkable(br->br_perm)) {
 		err = au_wh_init_rw_nolink(h_root, wbr, do_plink, base, &path);
 		if (err > 0)
 			goto out;
 		else if (err)
 			goto out_err;
-		break;
-
-	case AuBrPerm_RW:
+	} else {
 		err = au_wh_init_rw(h_root, wbr, do_plink, base, &path);
 		if (err > 0)
 			goto out;
 		else if (err)
 			goto out_err;
-		break;
-
-	default:
-		BUG();
 	}
 	goto out; /* success */
 
@@ -578,28 +563,29 @@
 	dir = a->sb->s_root->d_inode;
 	hdir = au_hi(dir, bindex);
 	h_root = au_h_dptr(a->sb->s_root, bindex);
+	AuDebugOn(h_root != au_br_dentry(a->br));
 
 	au_hn_imtx_lock_nested(hdir, AuLsc_I_PARENT);
 	wbr_wh_write_lock(wbr);
 	err = au_h_verify(wbr->wbr_whbase, au_opt_udba(a->sb), hdir->hi_inode,
 			  h_root, a->br);
 	if (!err) {
-		err = mnt_want_write(a->br->br_mnt);
+		h_path.mnt = au_br_mnt(a->br);
+		err = mnt_want_write(h_path.mnt);
 		if (!err) {
 			h_path.dentry = wbr->wbr_whbase;
-			h_path.mnt = a->br->br_mnt;
 			err = vfsub_unlink(hdir->hi_inode, &h_path, /*force*/0);
-			mnt_drop_write(a->br->br_mnt);
+			mnt_drop_write(h_path.mnt);
 		}
 	} else {
-		pr_warning("%.*s is moved, ignored\n",
-			   AuDLNPair(wbr->wbr_whbase));
+		pr_warn("%.*s is moved, ignored\n",
+			AuDLNPair(wbr->wbr_whbase));
 		err = 0;
 	}
 	dput(wbr->wbr_whbase);
 	wbr->wbr_whbase = NULL;
 	if (!err)
-		err = au_wh_init(h_root, a->br, a->sb);
+		err = au_wh_init(a->br, a->sb);
 	wbr_wh_write_unlock(wbr);
 	au_hn_imtx_unlock(hdir);
 	di_read_unlock(a->sb->s_root, AuLock_IR);
@@ -634,7 +620,7 @@
 		arg->sb = sb;
 		arg->br = br;
 		atomic_inc(&br->br_count);
-		wkq_err = au_wkq_nowait(reinit_br_wh, arg, sb);
+		wkq_err = au_wkq_nowait(reinit_br_wh, arg, sb, /*flags*/0);
 		if (unlikely(wkq_err)) {
 			atomic_dec(&br->br_wbr->wbr_wh_running);
 			atomic_dec(&br->br_count);
@@ -670,7 +656,7 @@
 	IMustLock(h_dir);
 
 	br = au_sbr(sb, bindex);
-	h_path.mnt = br->br_mnt;
+	h_path.mnt = au_br_mnt(br);
 	wbr = br->br_wbr;
 	wbr_wh_read_lock(wbr);
 	if (wbr->wbr_whbase) {
@@ -719,7 +705,7 @@
 	} else {
 		struct path tmp = {
 			.dentry = opq_dentry,
-			.mnt	= br->br_mnt
+			.mnt	= au_br_mnt(br)
 		};
 		err = do_unlink_wh(au_h_iptr(dentry->d_inode, bindex), &tmp);
 		if (!err)
@@ -971,7 +957,7 @@
 
 	if (!err) {
 		h_tmp.dentry = wh_dentry;
-		h_tmp.mnt = br->br_mnt;
+		h_tmp.mnt = au_br_mnt(br);
 		err = vfsub_rmdir(h_dir, &h_tmp);
 	}
 
@@ -984,8 +970,8 @@
 		return 0; /* success */
 	}
 
-	pr_warning("failed removing %.*s(%d), ignored\n",
-		   AuDLNPair(wh_dentry), err);
+	pr_warn("failed removing %.*s(%d), ignored\n",
+		AuDLNPair(wh_dentry), err);
 	return err;
 }
 
@@ -998,6 +984,7 @@
 	struct dentry *h_parent;
 	struct inode *h_dir;
 	struct au_hinode *hdir;
+	struct vfsmount *h_mnt;
 
 	/* rmdir by nfsd may cause deadlock with this i_mutex */
 	/* mutex_lock(&a->dir->i_mutex); */
@@ -1019,11 +1006,12 @@
 	err = au_h_verify(a->wh_dentry, au_opt_udba(sb), h_dir, h_parent,
 			  a->br);
 	if (!err) {
-		err = mnt_want_write(a->br->br_mnt);
+		h_mnt = au_br_mnt(a->br);
+		err = mnt_want_write(h_mnt);
 		if (!err) {
 			err = au_whtmp_rmdir(a->dir, bindex, a->wh_dentry,
 					     &a->whlist);
-			mnt_drop_write(a->br->br_mnt);
+			mnt_drop_write(h_mnt);
 		}
 	}
 	au_hn_imtx_unlock(hdir);
@@ -1053,10 +1041,10 @@
 	args->br = au_sbr(sb, bindex);
 	atomic_inc(&args->br->br_count);
 	args->wh_dentry = dget(wh_dentry);
-	wkq_err = au_wkq_nowait(call_rmdir_whtmp, args, sb);
+	wkq_err = au_wkq_nowait(call_rmdir_whtmp, args, sb, /*flags*/0);
 	if (unlikely(wkq_err)) {
-		pr_warning("rmdir error %.*s (%d), ignored\n",
-			   AuDLNPair(wh_dentry), wkq_err);
+		pr_warn("rmdir error %.*s (%d), ignored\n",
+			AuDLNPair(wh_dentry), wkq_err);
 		au_whtmp_rmdir_free(args);
 	}
 }
diff -ru --new-file linux-3.x-orig/fs/aufs/whout.h linux-3.x/fs/aufs/whout.h
--- linux-3.x-orig/fs/aufs/whout.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/whout.h	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,7 +25,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/aufs_type.h>
 #include "dir.h"
 
 /* whout.c */
@@ -39,8 +38,7 @@
 int au_whtmp_ren(struct dentry *h_dentry, struct au_branch *br);
 int au_wh_unlink_dentry(struct inode *h_dir, struct path *h_path,
 			struct dentry *dentry);
-int au_wh_init(struct dentry *h_parent, struct au_branch *br,
-	       struct super_block *sb);
+int au_wh_init(struct au_branch *br, struct super_block *sb);
 
 /* diropq flags */
 #define AuDiropq_CREATE	1
diff -ru --new-file linux-3.x-orig/fs/aufs/wkq.c linux-3.x/fs/aufs/wkq.c
--- linux-3.x-orig/fs/aufs/wkq.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/wkq.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,23 +24,9 @@
 #include <linux/module.h>
 #include "aufs.h"
 
-/* internal workqueue named AUFS_WKQ_NAME and AUFS_WKQ_PRE_NAME */
-enum {
-	AuWkq_INORMAL,
-	AuWkq_IPRE
-};
+/* internal workqueue named AUFS_WKQ_NAME */
 
-static struct {
-	char *name;
-	struct workqueue_struct *wkq;
-} au_wkq[] = {
-	[AuWkq_INORMAL] = {
-		.name = AUFS_WKQ_NAME
-	},
-	[AuWkq_IPRE] = {
-		.name = AUFS_WKQ_PRE_NAME
-	}
-};
+static struct workqueue_struct *au_wkq;
 
 struct au_wkinfo {
 	struct work_struct wk;
@@ -68,7 +54,7 @@
 		complete(wkinfo->comp);
 	else {
 		kobject_put(wkinfo->kobj);
-		module_put(THIS_MODULE);
+		module_put(THIS_MODULE); /* todo: ?? */
 		kfree(wkinfo);
 	}
 }
@@ -76,7 +62,7 @@
 /*
  * Since struct completion is large, try allocating it dynamically.
  */
-#if defined(CONFIG_4KSTACKS) || defined(AuTest4KSTACKS)
+#if 1 /* defined(CONFIG_4KSTACKS) || defined(AuTest4KSTACKS) */
 #define AuWkqCompDeclare(name)	struct completion *comp = NULL
 
 static int au_wkq_comp_alloc(struct au_wkinfo *wkinfo, struct completion **comp)
@@ -114,17 +100,19 @@
 }
 #endif /* 4KSTACKS */
 
-static void au_wkq_run(struct au_wkinfo *wkinfo, unsigned int flags)
+static void au_wkq_run(struct au_wkinfo *wkinfo)
 {
-	struct workqueue_struct *wkq;
+	if (au_ftest_wkq(wkinfo->flags, NEST)) {
+		if (au_wkq_test()) {
+			AuWarn1("wkq from wkq, due to a dead dir by UDBA?\n");
+			AuDebugOn(au_ftest_wkq(wkinfo->flags, WAIT));
+		}
+	} else
+		au_dbg_verify_kthread();
 
-	au_dbg_verify_kthread();
-	if (flags & AuWkq_WAIT) {
+	if (au_ftest_wkq(wkinfo->flags, WAIT)) {
 		INIT_WORK_ONSTACK(&wkinfo->wk, wkq_func);
-		wkq = au_wkq[AuWkq_INORMAL].wkq;
-		if (flags & AuWkq_PRE)
-			wkq = au_wkq[AuWkq_IPRE].wkq;
-		queue_work(wkq, &wkinfo->wk);
+		queue_work(au_wkq, &wkinfo->wk);
 	} else {
 		INIT_WORK(&wkinfo->wk, wkq_func);
 		schedule_work(&wkinfo->wk);
@@ -149,7 +137,7 @@
 
 	err = au_wkq_comp_alloc(&wkinfo, &comp);
 	if (!err) {
-		au_wkq_run(&wkinfo, flags);
+		au_wkq_run(&wkinfo);
 		/* no timeout, no interrupt */
 		wait_for_completion(wkinfo.comp);
 		au_wkq_comp_free(comp);
@@ -164,7 +152,8 @@
  * Note: dget/dput() in func for aufs dentries are not supported. It will be a
  * problem in a concurrent umounting.
  */
-int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb)
+int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,
+		  unsigned int flags)
 {
 	int err;
 	struct au_wkinfo *wkinfo;
@@ -179,14 +168,14 @@
 	wkinfo = kmalloc(sizeof(*wkinfo), GFP_NOFS);
 	if (wkinfo) {
 		wkinfo->kobj = &au_sbi(sb)->si_kobj;
-		wkinfo->flags = !AuWkq_WAIT;
+		wkinfo->flags = flags & ~AuWkq_WAIT;
 		wkinfo->func = func;
 		wkinfo->args = args;
 		wkinfo->comp = NULL;
 		kobject_get(wkinfo->kobj);
-		__module_get(THIS_MODULE);
+		__module_get(THIS_MODULE); /* todo: ?? */
 
-		au_wkq_run(wkinfo, !AuWkq_WAIT);
+		au_wkq_run(wkinfo);
 	} else {
 		err = -ENOMEM;
 		au_nwt_done(&au_sbi(sb)->si_nowait);
@@ -206,31 +195,20 @@
 
 void au_wkq_fin(void)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(au_wkq); i++)
-		if (au_wkq[i].wkq)
-			destroy_workqueue(au_wkq[i].wkq);
+	destroy_workqueue(au_wkq);
 }
 
 int __init au_wkq_init(void)
 {
-	int err, i;
+	int err;
 
 	err = 0;
-	for (i = 0; !err && i < ARRAY_SIZE(au_wkq); i++) {
-		BUILD_BUG_ON(!WQ_RESCUER);
-		au_wkq[i].wkq = alloc_workqueue(au_wkq[i].name, !WQ_RESCUER,
-						WQ_DFL_ACTIVE);
-		if (IS_ERR(au_wkq[i].wkq))
-			err = PTR_ERR(au_wkq[i].wkq);
-		else if (!au_wkq[i].wkq)
-			err = -ENOMEM;
-		if (unlikely(err))
-			au_wkq[i].wkq = NULL;
-	}
-	if (unlikely(err))
-		au_wkq_fin();
+	BUILD_BUG_ON(!WQ_RESCUER);
+	au_wkq = alloc_workqueue(AUFS_WKQ_NAME, !WQ_RESCUER, WQ_DFL_ACTIVE);
+	if (IS_ERR(au_wkq))
+		err = PTR_ERR(au_wkq);
+	else if (!au_wkq)
+		err = -ENOMEM;
 
 	return err;
 }
diff -ru --new-file linux-3.x-orig/fs/aufs/wkq.h linux-3.x/fs/aufs/wkq.h
--- linux-3.x-orig/fs/aufs/wkq.h	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/wkq.h	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,10 +26,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/aufs_type.h>
-
 struct super_block;
 
 /* ---------------------------------------------------------------------- */
@@ -48,25 +44,31 @@
 
 /* wkq flags */
 #define AuWkq_WAIT	1
-#define AuWkq_PRE	(1 << 1)
+#define AuWkq_NEST	(1 << 1)
 #define au_ftest_wkq(flags, name)	((flags) & AuWkq_##name)
 #define au_fset_wkq(flags, name) \
 	do { (flags) |= AuWkq_##name; } while (0)
 #define au_fclr_wkq(flags, name) \
 	do { (flags) &= ~AuWkq_##name; } while (0)
 
+#ifndef CONFIG_AUFS_HNOTIFY
+#undef AuWkq_NEST
+#define AuWkq_NEST	0
+#endif
+
 /* wkq.c */
 int au_wkq_do_wait(unsigned int flags, au_wkq_func_t func, void *args);
-int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb);
+int au_wkq_nowait(au_wkq_func_t func, void *args, struct super_block *sb,
+		  unsigned int flags);
 void au_nwt_init(struct au_nowait_tasks *nwt);
 int __init au_wkq_init(void);
 void au_wkq_fin(void);
 
 /* ---------------------------------------------------------------------- */
 
-static inline int au_wkq_wait_pre(au_wkq_func_t func, void *args)
+static inline int au_wkq_test(void)
 {
-	return au_wkq_do_wait(AuWkq_WAIT | AuWkq_PRE, func, args);
+	return current->flags & PF_WQ_WORKER;
 }
 
 static inline int au_wkq_wait(au_wkq_func_t func, void *args)
diff -ru --new-file linux-3.x-orig/fs/aufs/xino.c linux-3.x/fs/aufs/xino.c
--- linux-3.x-orig/fs/aufs/xino.c	2014-12-11 11:32:22.000000000 +0000
+++ linux-3.x/fs/aufs/xino.c	2014-12-23 17:23:09.055087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,11 +20,11 @@
  * external inode number translation table and bitmap
  */
 
-#include <linux/file.h>
 #include <linux/seq_file.h>
-#include <linux/uaccess.h>
+#include <linux/statfs.h>
 #include "aufs.h"
 
+/* todo: unnecessary to support mmap_sem since kernel-space? */
 ssize_t xino_fread(au_readf_t func, struct file *file, void *kbuf, size_t size,
 		   loff_t *pos)
 {
@@ -244,38 +244,56 @@
 int au_xino_trunc(struct super_block *sb, aufs_bindex_t bindex)
 {
 	int err;
+	unsigned long jiffy;
+	blkcnt_t blocks;
 	aufs_bindex_t bi, bend;
+	struct kstatfs *st;
 	struct au_branch *br;
 	struct file *new_xino, *file;
 	struct super_block *h_sb;
 	struct au_xino_lock_dir ldir;
 
+	err = -ENOMEM;
+	st = kzalloc(sizeof(*st), GFP_NOFS);
+	if (unlikely(!st))
+		goto out;
+
 	err = -EINVAL;
 	bend = au_sbend(sb);
 	if (unlikely(bindex < 0 || bend < bindex))
-		goto out;
+		goto out_st;
 	br = au_sbr(sb, bindex);
 	file = br->br_xino.xi_file;
 	if (!file)
-		goto out;
+		goto out_st;
+
+	err = vfs_statfs(&file->f_path, st);
+	if (unlikely(err))
+		AuErr1("statfs err %d, ignored\n", err);
+	jiffy = jiffies;
+	blocks = file->f_dentry->d_inode->i_blocks;
+	pr_info("begin truncating xino(b%d), ib%llu, %llu/%llu free blks\n",
+		bindex, (u64)blocks, st->f_bfree, st->f_blocks);
 
 	au_xino_lock_dir(sb, file, &ldir);
 	/* mnt_want_write() is unnecessary here */
 	new_xino = au_xino_create2(file, file);
 	au_xino_unlock_dir(&ldir);
 	err = PTR_ERR(new_xino);
-	if (IS_ERR(new_xino))
-		goto out;
+	if (IS_ERR(new_xino)) {
+		pr_err("err %d, ignored\n", err);
+		goto out_st;
+	}
 	err = 0;
 	fput(file);
 	br->br_xino.xi_file = new_xino;
 
-	h_sb = br->br_mnt->mnt_sb;
+	h_sb = au_br_sb(br);
 	for (bi = 0; bi <= bend; bi++) {
 		if (unlikely(bi == bindex))
 			continue;
 		br = au_sbr(sb, bi);
-		if (br->br_mnt->mnt_sb != h_sb)
+		if (au_br_sb(br) != h_sb)
 			continue;
 
 		fput(br->br_xino.xi_file);
@@ -283,6 +301,18 @@
 		get_file(new_xino);
 	}
 
+	err = vfs_statfs(&new_xino->f_path, st);
+	if (!err) {
+		pr_info("end truncating xino(b%d), ib%llu, %llu/%llu free blks\n",
+			bindex, (u64)new_xino->f_dentry->d_inode->i_blocks,
+			st->f_bfree, st->f_blocks);
+		if (new_xino->f_dentry->d_inode->i_blocks < blocks)
+			au_sbi(sb)->si_xino_jiffy = jiffy;
+	} else
+		AuErr1("statfs err %d, ignored\n", err);
+
+out_st:
+	kfree(st);
 out:
 	return err;
 }
@@ -310,14 +340,9 @@
 	ii_read_lock_parent(dir);
 	bindex = au_br_index(sb, br->br_id);
 	err = au_xino_trunc(sb, bindex);
-	if (!err
-	    && br->br_xino.xi_file->f_dentry->d_inode->i_blocks
-	    >= br->br_xino_upper)
-		br->br_xino_upper += AUFS_XINO_TRUNC_STEP;
-
 	ii_read_unlock(dir);
 	if (unlikely(err))
-		pr_warning("err b%d, (%d)\n", bindex, err);
+		pr_warn("err b%d, (%d)\n", bindex, err);
 	atomic_dec(&br->br_xino_running);
 	atomic_dec(&br->br_count);
 	si_write_unlock(sb);
@@ -325,13 +350,36 @@
 	kfree(args);
 }
 
+static int xino_trunc_test(struct super_block *sb, struct au_branch *br)
+{
+	int err;
+	struct kstatfs st;
+	struct au_sbinfo *sbinfo;
+
+	/* todo: si_xino_expire and the ratio should be customizable */
+	sbinfo = au_sbi(sb);
+	if (time_before(jiffies,
+			sbinfo->si_xino_jiffy + sbinfo->si_xino_expire))
+		return 0;
+
+	/* truncation border */
+	err = vfs_statfs(&br->br_xino.xi_file->f_path, &st);
+	if (unlikely(err)) {
+		AuErr1("statfs err %d, ignored\n", err);
+		return 0;
+	}
+	if (div64_u64(st.f_bfree * 100, st.f_blocks) >= AUFS_XINO_DEF_TRUNC)
+		return 0;
+
+	return 1;
+}
+
 static void xino_try_trunc(struct super_block *sb, struct au_branch *br)
 {
 	struct xino_do_trunc_args *args;
 	int wkq_err;
 
-	if (br->br_xino.xi_file->f_dentry->d_inode->i_blocks
-	    < br->br_xino_upper)
+	if (!xino_trunc_test(sb, br))
 		return;
 
 	if (atomic_inc_return(&br->br_xino_running) > 1)
@@ -347,7 +395,7 @@
 	atomic_inc(&br->br_count);
 	args->sb = sb;
 	args->br = br;
-	wkq_err = au_wkq_nowait(xino_do_trunc, args, sb);
+	wkq_err = au_wkq_nowait(xino_do_trunc, args, sb, /*flags*/0);
 	if (!wkq_err)
 		return; /* success */
 
@@ -409,7 +457,7 @@
 			       h_ino, ino);
 	if (!err) {
 		if (au_opt_test(mnt_flags, TRUNC_XINO)
-		    && au_test_fs_trunc_xino(br->br_mnt->mnt_sb))
+		    && au_test_fs_trunc_xino(au_br_sb(br)))
 			xino_try_trunc(sb, br);
 		return 0; /* success */
 	}
@@ -562,7 +610,7 @@
 		err = au_xino_do_write(xwrite, br->br_xino.xi_file,
 				       h_inode->i_ino, /*ino*/0);
 		if (!err && try_trunc
-		    && au_test_fs_trunc_xino(br->br_mnt->mnt_sb))
+		    && au_test_fs_trunc_xino(au_br_sb(br)))
 			xino_try_trunc(sb, br);
 	}
 }
@@ -769,10 +817,10 @@
 	shared_br = NULL;
 	bend = au_sbend(sb);
 	if (do_test) {
-		tgt_sb = br->br_mnt->mnt_sb;
+		tgt_sb = au_br_sb(br);
 		for (bindex = 0; bindex <= bend; bindex++) {
 			b = au_sbr(sb, bindex);
-			if (tgt_sb == b->br_mnt->mnt_sb) {
+			if (tgt_sb == au_br_sb(b)) {
 				shared_br = b;
 				break;
 			}
@@ -1201,7 +1249,7 @@
 	for (bindex = 0; bindex <= bend; bindex++) {
 		br = au_sbr(sb, bindex);
 		if (au_br_writable(br->br_perm)
-		    && !au_test_fs_bad_xino(br->br_mnt->mnt_sb)) {
+		    && !au_test_fs_bad_xino(au_br_sb(br))) {
 			bwr = bindex;
 			break;
 		}
@@ -1212,7 +1260,7 @@
 		page = __getname_gfp(GFP_NOFS);
 		if (unlikely(!page))
 			goto out;
-		path.mnt = br->br_mnt;
+		path.mnt = au_br_mnt(br);
 		path.dentry = au_h_dptr(sb->s_root, bwr);
 		p = d_path(&path, page, PATH_MAX - sizeof(AUFS_XINO_FNAME));
 		file = (void *)p;
diff -ru --new-file linux-3.x-orig/fs/compat_ioctl.c linux-3.x/fs/compat_ioctl.c
--- linux-3.x-orig/fs/compat_ioctl.c	2014-12-11 11:32:23.000000000 +0000
+++ linux-3.x/fs/compat_ioctl.c	2014-12-23 17:23:09.055087000 +0000
@@ -1760,12 +1760,14 @@
 	 sprintf(buf,"'%c'", (cmd>>_IOC_TYPESHIFT) & _IOC_TYPEMASK);
 	if (!isprint(buf[1]))
 		sprintf(buf, "%02x", buf[1]);
+#ifndef XPENOLOGY
 	compat_printk("ioctl32(%s:%d): Unknown cmd fd(%d) "
 			"cmd(%08x){t:%s;sz:%u} arg(%08x) on %s\n",
 			current->comm, current->pid,
 			(int)fd, (unsigned int)cmd, buf,
 			(cmd >> _IOC_SIZESHIFT) & _IOC_SIZEMASK,
 			(unsigned int)arg, fn);
+#endif
 
 	if (path)
 		free_page((unsigned long)path);
diff -ru --new-file linux-3.x-orig/fs/ext4/dir.c linux-3.x/fs/ext4/dir.c
--- linux-3.x-orig/fs/ext4/dir.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/dir.c	2014-12-23 17:23:09.059087000 +0000
@@ -131,8 +131,8 @@
 	sb = inode->i_sb;
 
 #ifdef SYNO_KERNEL_UNICODE
-	if ((EXT4_SB(inode->i_sb)->s_es->s_syno_hash_magic != cpu_to_le32(SYNO_HASH_MAGIC)) &&
-		EXT4_HAS_COMPAT_FEATURE(inode->i_sb, EXT4_FEATURE_COMPAT_DIR_INDEX) &&
+	if ((EXT4_SB(inode->i_sb)->s_es->s_syno_hash_magic == cpu_to_le32(SYNO_HASH_MAGIC)) &&
+		!EXT4_HAS_COMPAT_FEATURE(inode->i_sb, EXT4_FEATURE_COMPAT_DIR_INDEX) &&
 #else
 	if (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,
 				    EXT4_FEATURE_COMPAT_DIR_INDEX) &&
diff -ru --new-file linux-3.x-orig/fs/ext4/ext4.h linux-3.x/fs/ext4/ext4.h
--- linux-3.x-orig/fs/ext4/ext4.h	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/ext4.h	2014-12-23 17:23:09.059087000 +0000
@@ -957,6 +957,9 @@
 #define EXT4_MOUNT_BLOCK_VALIDITY	0x20000000 /* Block validity checking */
 #define EXT4_MOUNT_DISCARD		0x40000000 /* Issue DISCARD requests */
 #define EXT4_MOUNT_INIT_INODE_TABLE	0x80000000 /* Initialize uninitialized itables */
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#define EXT4_MOUNT_SYNO_ACL		0x00200 /* Synology Access Control Lists */
+#endif
 
 #define EXT4_MOUNT2_EXPLICIT_DELALLOC	0x00000001 /* User explicitly
 						      specified delalloc */
@@ -1969,6 +1972,10 @@
 /* resize.c */
 extern int ext4_group_add(struct super_block *sb,
 				struct ext4_new_group_data *input);
+#ifdef SYNO_KERNEL_UNICODE
+extern int ext4_group_add_no_flex(struct super_block *sb,
+				struct ext4_new_group_data *input);
+#endif
 extern int ext4_group_extend(struct super_block *sb,
 				struct ext4_super_block *es,
 				ext4_fsblk_t n_blocks_count);
diff -ru --new-file linux-3.x-orig/fs/ext4/file.c linux-3.x/fs/ext4/file.c
--- linux-3.x-orig/fs/ext4/file.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/file.c	2014-12-23 17:23:09.059087000 +0000
@@ -29,6 +29,10 @@
 #include "xattr.h"
 #include "acl.h"
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#include "syno_acl.h"
+#endif
+
 /*
  * Called when an inode is released. Note that this is different
  * from ext4_file_open: open gets called at every open, but release
@@ -270,7 +274,12 @@
 	.listxattr	= ext4_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	.syno_acl_get   = ext4_get_syno_acl,
+	.syno_acl_set	= ext4_set_syno_acl,
+#else
 	.get_acl	= ext4_get_acl,
+#endif
 	.fiemap		= ext4_fiemap,
 };
 
diff -ru --new-file linux-3.x-orig/fs/ext4/inode.c linux-3.x/fs/ext4/inode.c
--- linux-3.x-orig/fs/ext4/inode.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/inode.c	2014-12-23 17:23:09.059087000 +0000
@@ -47,6 +47,10 @@
 #include "acl.h"
 #include "truncate.h"
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#include "syno_acl.h"
+#endif
+
 #include <trace/events/ext4.h>
 
 #define MPAGE_DA_EXTENT_TAIL 0x01
@@ -4198,9 +4202,15 @@
 	int orphan = 0;
 	const unsigned int ia_valid = attr->ia_valid;
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	if (!IS_EXT4_SYNOACL(inode)) {
+#endif
 	error = inode_change_ok(inode, attr);
 	if (error)
 		return error;
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	}
+#endif
 
 	if (is_quota_modification(inode, attr))
 		dquot_initialize(inode);
diff -ru --new-file linux-3.x-orig/fs/ext4/ioctl.c linux-3.x/fs/ext4/ioctl.c
--- linux-3.x-orig/fs/ext4/ioctl.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/ioctl.c	2014-12-23 17:23:09.059087000 +0000
@@ -293,7 +293,13 @@
 		if (err)
 			goto group_add_out;
 
-		err = ext4_group_add(sb, &input);
+#ifdef SYNO_KERNEL_UNICODE
+		if (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))
+			err = ext4_group_add_no_flex(sb, &input);
+		else
+#endif
+			err = ext4_group_add(sb, &input);
+
 		if (EXT4_SB(sb)->s_journal) {
 			jbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);
 			err2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal);
diff -ru --new-file linux-3.x-orig/fs/ext4/Kconfig linux-3.x/fs/ext4/Kconfig
--- linux-3.x-orig/fs/ext4/Kconfig	2014-12-11 11:27:34.000000000 +0000
+++ linux-3.x/fs/ext4/Kconfig	2014-12-23 17:23:09.055087000 +0000
@@ -50,6 +50,18 @@
 
 	  You need this for POSIX ACL support on ext4.
 
+config EXT4_FS_SYNO_ACL
+	bool "Ext4 Synology Access Control Lists"
+	depends on EXT4_FS_XATTR
+        depends on !EXT4_FS_POSIX_ACL
+        select FS_SYNO_ACL
+        default n
+	help
+	  Synology Access Control Lists (ACLs) support Windows permissions for users and
+	  groups beyond the owner/group/world scheme.
+
+	  If you don't know what Access Control Lists are, say N
+
 config EXT4_FS_POSIX_ACL
 	bool "Ext4 POSIX Access Control Lists"
 	depends on EXT4_FS_XATTR
diff -ru --new-file linux-3.x-orig/fs/ext4/Makefile linux-3.x/fs/ext4/Makefile
--- linux-3.x-orig/fs/ext4/Makefile	2014-12-11 11:27:34.000000000 +0000
+++ linux-3.x/fs/ext4/Makefile	2014-12-23 17:23:09.055087000 +0000
@@ -11,4 +11,5 @@
 
 ext4-$(CONFIG_EXT4_FS_XATTR)		+= xattr.o xattr_user.o xattr_trusted.o
 ext4-$(CONFIG_EXT4_FS_POSIX_ACL)	+= acl.o
+ext4-$(CONFIG_EXT4_FS_SYNO_ACL)		+= syno_acl.o
 ext4-$(CONFIG_EXT4_FS_SECURITY)		+= xattr_security.o
diff -ru --new-file linux-3.x-orig/fs/ext4/namei.c linux-3.x/fs/ext4/namei.c
--- linux-3.x-orig/fs/ext4/namei.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/namei.c	2014-12-23 17:23:09.067087000 +0000
@@ -44,6 +44,10 @@
 #include "xattr.h"
 #include "acl.h"
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#include "syno_acl.h"
+#endif
+
 #include <trace/events/ext4.h>
 /*
  * define how far ahead to read directories while searching them.
@@ -2808,7 +2812,12 @@
 	.listxattr	= ext4_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	.syno_acl_get   = ext4_get_syno_acl,
+	.syno_acl_set	= ext4_set_syno_acl,
+#else
 	.get_acl	= ext4_get_acl,
+#endif
 	.fiemap         = ext4_fiemap,
 };
 
@@ -2827,5 +2836,7 @@
 	.listxattr	= ext4_listxattr,
 	.removexattr	= generic_removexattr,
 #endif
+#ifndef CONFIG_EXT4_FS_SYNO_ACL
 	.get_acl	= ext4_get_acl,
+#endif
 };
diff -ru --new-file linux-3.x-orig/fs/ext4/resize.c linux-3.x/fs/ext4/resize.c
--- linux-3.x-orig/fs/ext4/resize.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/resize.c	2014-12-23 17:23:09.067087000 +0000
@@ -1376,6 +1376,368 @@
 	return 1;
 }
 
+#ifdef SYNO_KERNEL_UNICODE
+/*
+ * Set up the block and inode bitmaps, and the inode table for the new group.
+ * This doesn't need to be part of the main transaction, since we are only
+ * changing blocks outside the actual filesystem.  We still do journaling to
+ * ensure the recovery is correct in case of a failure just after resize.
+ * If any part of this fails, we simply abort the resize.
+ */
+static int setup_new_group_blocks(struct super_block *sb,
+				  struct ext4_new_group_data *input)
+{
+	struct ext4_sb_info *sbi = EXT4_SB(sb);
+	ext4_fsblk_t start = ext4_group_first_block_no(sb, input->group);
+	int reserved_gdb = ext4_bg_has_super(sb, input->group) ?
+		le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0;
+	unsigned long gdblocks = ext4_bg_num_gdb(sb, input->group);
+	struct buffer_head *bh;
+	handle_t *handle;
+	ext4_fsblk_t block;
+	ext4_grpblk_t bit;
+	int i;
+	int err = 0, err2;
+
+	/* This transaction may be extended/restarted along the way */
+	handle = ext4_journal_start_sb(sb, EXT4_MAX_TRANS_DATA);
+
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+
+	BUG_ON(input->group != sbi->s_groups_count);
+
+	/* Copy all of the GDT blocks into the backup in this group */
+	for (i = 0, bit = 1, block = start + 1;
+	     i < gdblocks; i++, block++, bit++) {
+		struct buffer_head *gdb;
+
+		ext4_debug("update backup group %#04llx (+%d)\n", block, bit);
+		err = extend_or_restart_transaction(handle, 1);
+		if (err)
+			goto exit_journal;
+
+		gdb = sb_getblk(sb, block);
+		if (!gdb) {
+			err = -ENOMEM;
+			goto exit_journal;
+		}
+		if ((err = ext4_journal_get_write_access(handle, gdb))) {
+			brelse(gdb);
+			goto exit_journal;
+		}
+		memcpy(gdb->b_data, sbi->s_group_desc[i]->b_data, gdb->b_size);
+		set_buffer_uptodate(gdb);
+		err = ext4_handle_dirty_metadata(handle, NULL, gdb);
+		if (unlikely(err)) {
+			brelse(gdb);
+			goto exit_journal;
+		}
+		brelse(gdb);
+	}
+
+	/* Zero out all of the reserved backup group descriptor table blocks */
+	ext4_debug("clear inode table blocks %#04llx -> %#04lx\n",
+			block, sbi->s_itb_per_group);
+	err = sb_issue_zeroout(sb, gdblocks + start + 1, reserved_gdb,
+			       GFP_NOFS);
+	if (err)
+		goto exit_journal;
+
+	err = extend_or_restart_transaction(handle, 2);
+	if (err)
+		goto exit_journal;
+
+	bh = bclean(handle, sb, input->block_bitmap);
+	if (IS_ERR(bh)) {
+		err = PTR_ERR(bh);
+		goto exit_journal;
+	}
+
+	if (ext4_bg_has_super(sb, input->group)) {
+		ext4_debug("mark backup group tables %#04llx (+0)\n", start);
+		ext4_set_bits(bh->b_data, 0, gdblocks + reserved_gdb + 1);
+	}
+
+	ext4_debug("mark block bitmap %#04llx (+%llu)\n", input->block_bitmap,
+		   input->block_bitmap - start);
+	ext4_set_bit(input->block_bitmap - start, bh->b_data);
+	ext4_debug("mark inode bitmap %#04llx (+%llu)\n", input->inode_bitmap,
+		   input->inode_bitmap - start);
+	ext4_set_bit(input->inode_bitmap - start, bh->b_data);
+
+	/* Zero out all of the inode table blocks */
+	block = input->inode_table;
+	ext4_debug("clear inode table blocks %#04llx -> %#04lx\n",
+			block, sbi->s_itb_per_group);
+	err = sb_issue_zeroout(sb, block, sbi->s_itb_per_group, GFP_NOFS);
+	if (err)
+		goto exit_bh;
+	ext4_set_bits(bh->b_data, input->inode_table - start,
+		      sbi->s_itb_per_group);
+
+
+	ext4_mark_bitmap_end(input->blocks_count, sb->s_blocksize * 8,
+			     bh->b_data);
+	err = ext4_handle_dirty_metadata(handle, NULL, bh);
+	if (unlikely(err)) {
+		ext4_std_error(sb, err);
+		goto exit_bh;
+	}
+	brelse(bh);
+	/* Mark unused entries in inode bitmap used */
+	ext4_debug("clear inode bitmap %#04llx (+%llu)\n",
+		   input->inode_bitmap, input->inode_bitmap - start);
+	if (IS_ERR(bh = bclean(handle, sb, input->inode_bitmap))) {
+		err = PTR_ERR(bh);
+		goto exit_journal;
+	}
+
+	ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8,
+			     bh->b_data);
+	err = ext4_handle_dirty_metadata(handle, NULL, bh);
+	if (unlikely(err))
+		ext4_std_error(sb, err);
+exit_bh:
+	brelse(bh);
+
+exit_journal:
+	if ((err2 = ext4_journal_stop(handle)) && !err)
+		err = err2;
+
+	return err;
+}
+
+/* Add group descriptor data to an existing or new group descriptor block.
+ * Ensure we handle all possible error conditions _before_ we start modifying
+ * the filesystem, because we cannot abort the transaction and not have it
+ * write the data to disk.
+ *
+ * If we are on a GDT block boundary, we need to get the reserved GDT block.
+ * Otherwise, we may need to add backup GDT blocks for a sparse group.
+ *
+ * We only need to hold the superblock lock while we are actually adding
+ * in the new group's counts to the superblock.  Prior to that we have
+ * not really "added" the group at all.  We re-check that we are still
+ * adding in the last group in case things have changed since verifying.
+ */
+int ext4_group_add_no_flex(struct super_block *sb, struct ext4_new_group_data *input)
+{
+	struct ext4_sb_info *sbi = EXT4_SB(sb);
+	struct ext4_super_block *es = sbi->s_es;
+	int reserved_gdb = ext4_bg_has_super(sb, input->group) ?
+		le16_to_cpu(es->s_reserved_gdt_blocks) : 0;
+	struct buffer_head *primary = NULL;
+	struct ext4_group_desc *gdp;
+	struct inode *inode = NULL;
+	handle_t *handle;
+	int gdb_off, gdb_num;
+	int err, err2;
+
+	gdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);
+	gdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);
+
+	if (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,
+					EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {
+		ext4_warning(sb, "Can't resize non-sparse filesystem further");
+		return -EPERM;
+	}
+
+	if (ext4_blocks_count(es) + input->blocks_count <
+	    ext4_blocks_count(es)) {
+		ext4_warning(sb, "blocks_count overflow");
+		return -EINVAL;
+	}
+
+	if (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <
+	    le32_to_cpu(es->s_inodes_count)) {
+		ext4_warning(sb, "inodes_count overflow");
+		return -EINVAL;
+	}
+
+	if (reserved_gdb || gdb_off == 0) {
+		if (!EXT4_HAS_COMPAT_FEATURE(sb,
+					     EXT4_FEATURE_COMPAT_RESIZE_INODE)
+		    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {
+			ext4_warning(sb,
+				     "No reserved GDT blocks, can't resize");
+			return -EPERM;
+		}
+		inode = ext4_iget(sb, EXT4_RESIZE_INO);
+		if (IS_ERR(inode)) {
+			ext4_warning(sb, "Error opening resize inode");
+			return PTR_ERR(inode);
+		}
+	}
+
+
+	if ((err = verify_group_input(sb, input)))
+		goto exit_put;
+
+	if ((err = setup_new_group_blocks(sb, input)))
+		goto exit_put;
+
+	/*
+	 * We will always be modifying at least the superblock and a GDT
+	 * block.  If we are adding a group past the last current GDT block,
+	 * we will also modify the inode and the dindirect block.  If we
+	 * are adding a group with superblock/GDT backups  we will also
+	 * modify each of the reserved GDT dindirect blocks.
+	 */
+	handle = ext4_journal_start_sb(sb,
+				       ext4_bg_has_super(sb, input->group) ?
+				       3 + reserved_gdb : 4);
+	if (IS_ERR(handle)) {
+		err = PTR_ERR(handle);
+		goto exit_put;
+	}
+
+	if ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))
+		goto exit_journal;
+
+        /*
+         * We will only either add reserved group blocks to a backup group
+         * or remove reserved blocks for the first group in a new group block.
+         * Doing both would be mean more complex code, and sane people don't
+         * use non-sparse filesystems anymore.  This is already checked above.
+         */
+	if (gdb_off) {
+		primary = sbi->s_group_desc[gdb_num];
+		if ((err = ext4_journal_get_write_access(handle, primary)))
+			goto exit_journal;
+
+		if (reserved_gdb && ext4_bg_num_gdb(sb, input->group)) {
+			err = reserve_backup_gdb(handle, inode, input->group);
+			if (err)
+				goto exit_journal;
+		}
+	} else {
+		/*
+		 * Note that we can access new group descriptor block safely
+		 * only if add_new_gdb() succeeds.
+		 */
+		err = add_new_gdb(handle, inode, input->group);
+		if (err)
+			goto exit_journal;
+		primary = sbi->s_group_desc[gdb_num];
+	}
+
+        /*
+         * OK, now we've set up the new group.  Time to make it active.
+         *
+         * so we have to be safe wrt. concurrent accesses the group
+         * data.  So we need to be careful to set all of the relevant
+         * group descriptor data etc. *before* we enable the group.
+         *
+         * The key field here is sbi->s_groups_count: as long as
+         * that retains its old value, nobody is going to access the new
+         * group.
+         *
+         * So first we update all the descriptor metadata for the new
+         * group; then we update the total disk blocks count; then we
+         * update the groups count to enable the group; then finally we
+         * update the free space counts so that the system can start
+         * using the new disk blocks.
+         */
+
+	/* Update group descriptor block for new group */
+	gdp = (struct ext4_group_desc *)((char *)primary->b_data +
+					 gdb_off * EXT4_DESC_SIZE(sb));
+
+	memset(gdp, 0, EXT4_DESC_SIZE(sb));
+	ext4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */
+	ext4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */
+	ext4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */
+	ext4_free_group_clusters_set(sb, gdp, input->free_blocks_count);
+	ext4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));
+	gdp->bg_flags = cpu_to_le16(EXT4_BG_INODE_ZEROED);
+	gdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);
+
+	/*
+	 * We can allocate memory for mb_alloc based on the new group
+	 * descriptor
+	 */
+	err = ext4_mb_add_groupinfo(sb, input->group, gdp);
+	if (err)
+		goto exit_journal;
+
+	/*
+	 * Make the new blocks and inodes valid next.  We do this before
+	 * increasing the group count so that once the group is enabled,
+	 * all of its blocks and inodes are already valid.
+	 *
+	 * We always allocate group-by-group, then block-by-block or
+	 * inode-by-inode within a group, so enabling these
+	 * blocks/inodes before the group is live won't actually let us
+	 * allocate the new space yet.
+	 */
+	ext4_blocks_count_set(es, ext4_blocks_count(es) +
+		input->blocks_count);
+	le32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));
+
+	/*
+	 * We need to protect s_groups_count against other CPUs seeing
+	 * inconsistent state in the superblock.
+	 *
+	 * The precise rules we use are:
+	 *
+	 * * Writers must perform a smp_wmb() after updating all dependent
+	 *   data and before modifying the groups count
+	 *
+	 * * Readers must perform an smp_rmb() after reading the groups count
+	 *   and before reading any dependent data.
+	 *
+	 * NB. These rules can be relaxed when checking the group count
+	 * while freeing data, as we can only allocate from a block
+	 * group after serialising against the group count, and we can
+	 * only then free after serialising in turn against that
+	 * allocation.
+	 */
+	smp_wmb();
+
+	/* Update the global fs size fields */
+	sbi->s_groups_count++;
+
+	err = ext4_handle_dirty_metadata(handle, NULL, primary);
+	if (unlikely(err)) {
+		ext4_std_error(sb, err);
+		goto exit_journal;
+	}
+
+	/* Update the reserved block counts only once the new group is
+	 * active. */
+#ifndef SYNO_KERNEL_UNICODE
+	ext4_r_blocks_count_set(es, ext4_r_blocks_count(es) +
+		input->reserved_blocks);
+#endif
+
+	/* Update the free space counts */
+	percpu_counter_add(&sbi->s_freeclusters_counter,
+			   EXT4_B2C(sbi, input->free_blocks_count));
+	percpu_counter_add(&sbi->s_freeinodes_counter,
+			   EXT4_INODES_PER_GROUP(sb));
+	/*
+	 * Update the fs overhead information
+	 */
+	ext4_calculate_overhead(sb);
+
+	ext4_handle_dirty_super(handle, sb);
+
+exit_journal:
+	if ((err2 = ext4_journal_stop(handle)) && !err)
+		err = err2;
+	if (!err && primary) {
+		update_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,
+			       sizeof(struct ext4_super_block));
+		update_backups(sb, primary->b_blocknr, primary->b_data,
+			       primary->b_size);
+	}
+exit_put:
+	iput(inode);
+	return err;
+} /* ext4_group_add */
+#endif
+
 /* Add group descriptor data to an existing or new group descriptor block.
  * Ensure we handle all possible error conditions _before_ we start modifying
  * the filesystem, because we cannot abort the transaction and not have it
diff -ru --new-file linux-3.x-orig/fs/ext4/super.c linux-3.x/fs/ext4/super.c
--- linux-3.x-orig/fs/ext4/super.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/super.c	2014-12-23 17:23:09.067087000 +0000
@@ -51,6 +51,10 @@
 #include "acl.h"
 #include "mballoc.h"
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#include <linux/syno_acl.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/ext4.h>
 
@@ -1150,7 +1154,10 @@
 		seq_puts(seq, ",nouser_xattr");
 #endif
 
-#if defined(CONFIG_EXT4_FS_POSIX_ACL)
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	if (test_opt(sb, SYNO_ACL))
+		seq_puts(seq, ","SYNO_ACL_MNT_OPT);
+#elif defined(CONFIG_EXT4_FS_POSIX_ACL)
 	if (test_opt(sb, POSIX_ACL) && !(def_mount_opts & EXT4_DEFM_ACL))
 		seq_puts(seq, ",acl");
 	if (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT4_DEFM_ACL))
@@ -1506,6 +1513,9 @@
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
 	Opt_dioread_nolock, Opt_dioread_lock,
 	Opt_discard, Opt_nodiscard, Opt_init_itable, Opt_noinit_itable,
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	Opt_synoacl, Opt_nosynoacl,
+#endif
 };
 
 static const match_table_t tokens = {
@@ -1529,6 +1539,10 @@
 	{Opt_nouser_xattr, "nouser_xattr"},
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	{Opt_synoacl, SYNO_ACL_MNT_OPT},
+	{Opt_nosynoacl, SYNO_ACL_NOT_MNT_OPT},
+#endif
 	{Opt_noload, "noload"},
 	{Opt_noload, "norecovery"},
 	{Opt_nobh, "nobh"},
@@ -1787,7 +1801,14 @@
 			ext4_msg(sb, KERN_ERR, "(no)user_xattr options not supported");
 			break;
 #endif
-#if  defined(CONFIG_EXT4_FS_POSIX_ACL)
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+		case Opt_synoacl:
+			set_opt(sb, SYNO_ACL);
+			break;
+		case Opt_nosynoacl:
+			clear_opt(sb, SYNO_ACL);
+			break;
+#elif defined(CONFIG_EXT4_FS_POSIX_ACL)
 		case Opt_acl:
 			set_opt(sb, POSIX_ACL);
 			break;
@@ -3645,8 +3666,21 @@
 		if (test_opt(sb, DELALLOC))
 			clear_opt(sb, DELALLOC);
 	}
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	if (test_opt(sb, SYNO_ACL)) {
+		int st = SYNOACLModuleStatusGet("synoacl_vfs");
+		if (MODULE_STATE_LIVE != st) {
+			ext4_msg(sb, KERN_ERR, "synoacl module has not been loaded. Unable to mount with synoacl, vfs_mod status=%d", st);
+			clear_opt(sb, SYNO_ACL);
+		} else {
+			sb->s_flags |= MS_SYNOACL;
+			SYNOACLModuleGet("synoacl_vfs");
+		}
+	}
+#else
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);
+#endif
 
 	if (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&
 	    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||
@@ -4843,8 +4877,24 @@
 	if (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)
 		ext4_abort(sb, "Abort forced by user");
 
+	#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	if ((sb->s_flags & MS_SYNOACL) && !test_opt(sb, SYNO_ACL)) {
+		sb->s_flags = sb->s_flags & ~MS_SYNOACL;
+		SYNOACLModulePut("synoacl_vfs");
+	} else if((!(sb->s_flags & MS_SYNOACL)) && test_opt(sb, SYNO_ACL)) {
+		int st = SYNOACLModuleStatusGet("synoacl_vfs");
+		if (MODULE_STATE_LIVE != st) {
+			ext4_msg(sb, KERN_ERR, "synoacl module has not been loaded. Unable to remount with synoacl, vfs_mod status=%d", st);
+			clear_opt(sb, SYNO_ACL);
+		} else {
+			sb->s_flags |= MS_SYNOACL;
+			SYNOACLModuleGet("synoacl_vfs");
+		}
+	}
+#else
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);
+#endif
 
 	es = sbi->s_es;
 
@@ -5314,6 +5364,17 @@
 	return mount_bdev(fs_type, flags, dev_name, data, ext4_fill_super);
 }
 
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+static void ext4_kill_sb(struct super_block *sb)
+{
+	kill_block_super(sb);
+
+	if (MS_SYNOACL & sb->s_flags) {
+		SYNOACLModulePut("synoacl_vfs");
+	}
+}
+#endif
+
 #ifdef SYNO_EXT4_ERROR_FS_REPORT
 void ext4_fill_mount_path(struct super_block *sb, char *szPath)
 {
@@ -5397,7 +5458,11 @@
 	.owner		= THIS_MODULE,
 	.name		= "ext4",
 	.mount          = ext4_mount,
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	.kill_sb	= ext4_kill_sb,
+#else
 	.kill_sb	= kill_block_super,
+#endif
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 
diff -ru --new-file linux-3.x-orig/fs/ext4/xattr.c linux-3.x/fs/ext4/xattr.c
--- linux-3.x-orig/fs/ext4/xattr.c	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/xattr.c	2014-12-23 17:23:09.067087000 +0000
@@ -100,7 +100,10 @@
 
 static const struct xattr_handler *ext4_xattr_handler_map[] = {
 	[EXT4_XATTR_INDEX_USER]		     = &ext4_xattr_user_handler,
-#if defined(CONFIG_EXT4_FS_POSIX_ACL)
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	[EXT4_XATTR_INDEX_SYNO_ACL_ACCESS]  = &ext4_xattr_synoacl_access_handler,
+	[EXT4_XATTR_INDEX_SYNO_ACL_ACCESS_NOPERM]  = &ext4_xattr_synoacl_noperm_access_handler,
+#elif defined(CONFIG_EXT4_FS_POSIX_ACL)
 	[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &ext4_xattr_acl_access_handler,
 	[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &ext4_xattr_acl_default_handler,
 #endif
@@ -116,7 +119,10 @@
 const struct xattr_handler *ext4_xattr_handlers[] = {
 	&ext4_xattr_user_handler,
 	&ext4_xattr_trusted_handler,
-#if defined(CONFIG_EXT4_FS_POSIX_ACL)
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+	&ext4_xattr_synoacl_access_handler,
+	&ext4_xattr_synoacl_noperm_access_handler,
+#elif defined(CONFIG_EXT4_FS_POSIX_ACL)
 	&ext4_xattr_acl_access_handler,
 	&ext4_xattr_acl_default_handler,
 #endif
diff -ru --new-file linux-3.x-orig/fs/ext4/xattr.h linux-3.x/fs/ext4/xattr.h
--- linux-3.x-orig/fs/ext4/xattr.h	2014-12-11 11:32:24.000000000 +0000
+++ linux-3.x/fs/ext4/xattr.h	2014-12-23 17:23:09.067087000 +0000
@@ -21,9 +21,15 @@
 #define EXT4_XATTR_INDEX_TRUSTED		4
 #define	EXT4_XATTR_INDEX_LUSTRE			5
 #define EXT4_XATTR_INDEX_SECURITY	        6
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#define EXT4_XATTR_INDEX_SYNO_ACL_ACCESS	7
+#endif
 #ifdef SYNO_XATTR
 #define EXT4_XATTR_INDEX_SYNO	8
 #endif
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+#define EXT4_XATTR_INDEX_SYNO_ACL_ACCESS_NOPERM	9
+#endif
 
 struct ext4_xattr_header {
 	__le32	h_magic;	/* magic number for identification */
@@ -66,7 +72,12 @@
 		EXT4_I(inode)->i_extra_isize))
 #define IFIRST(hdr) ((struct ext4_xattr_entry *)((hdr)+1))
 
-# ifdef CONFIG_EXT4_FS_XATTR
+#ifdef CONFIG_EXT4_FS_XATTR
+
+#ifdef CONFIG_EXT4_FS_SYNO_ACL
+extern const struct xattr_handler ext4_xattr_synoacl_access_handler;
+extern const struct xattr_handler ext4_xattr_synoacl_noperm_access_handler;
+#endif
 
 #ifdef SYNO_XATTR
 extern struct xattr_handler ext4_xattr_syno_handler;
diff -ru --new-file linux-3.x-orig/fs/proc/nommu.c linux-3.x/fs/proc/nommu.c
--- linux-3.x-orig/fs/proc/nommu.c	2014-12-11 11:32:23.000000000 +0000
+++ linux-3.x/fs/proc/nommu.c	2014-12-23 17:45:56.303087000 +0000
@@ -45,7 +45,9 @@
 	file = region->vm_file;
 
 	if (file) {
-		struct inode *inode = region->vm_file->f_path.dentry->d_inode;
+		struct inode *inode;
+		file = vmr_pr_or_file(region);
+		inode = file->f_path.dentry->d_inode;
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff -ru --new-file linux-3.x-orig/fs/proc/task_mmu.c linux-3.x/fs/proc/task_mmu.c
--- linux-3.x-orig/fs/proc/task_mmu.c	2014-12-11 11:32:23.000000000 +0000
+++ linux-3.x/fs/proc/task_mmu.c	2014-12-23 17:23:09.067087000 +0000
@@ -221,7 +221,9 @@
 	int len;
 
 	if (file) {
-		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+		struct inode *inode;
+		file = vma_pr_or_file(vma);
+		inode = file->f_path.dentry->d_inode;
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -1044,6 +1046,7 @@
 	seq_printf(m, "%08lx %s", vma->vm_start, buffer);
 
 	if (file) {
+		file = vma_pr_or_file(vma);
 		seq_printf(m, " file=");
 		seq_path(m, &file->f_path, "\n\t= ");
 	} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {
diff -ru --new-file linux-3.x-orig/fs/proc/task_nommu.c linux-3.x/fs/proc/task_nommu.c
--- linux-3.x-orig/fs/proc/task_nommu.c	2014-12-11 11:32:23.000000000 +0000
+++ linux-3.x/fs/proc/task_nommu.c	2014-12-23 17:23:09.067087000 +0000
@@ -147,7 +147,9 @@
 	file = vma->vm_file;
 
 	if (file) {
-		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+		struct inode *inode;
+		file = vma_pr_or_file(file);
+		inode = file->f_path.dentry->d_inode;
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff -ru --new-file linux-3.x-orig/include/linux/aufs_type.h linux-3.x/include/linux/aufs_type.h
--- linux-3.x-orig/include/linux/aufs_type.h	2014-12-11 11:32:25.000000000 +0000
+++ linux-3.x/include/linux/aufs_type.h	2014-12-23 17:23:09.067087000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2011 Junjiro R. Okajima
+ * Copyright (C) 2005-2013 Junjiro R. Okajima
  *
  * This program, aufs is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,12 +19,28 @@
 #ifndef __AUFS_TYPE_H__
 #define __AUFS_TYPE_H__
 
-#include <linux/ioctl.h>
-#include <linux/kernel.h>
+#define AUFS_NAME	"aufs"
+
+#ifdef __KERNEL__
+/*
+ * define it before including all other headers.
+ * sched.h may use pr_* macros before defining "current", so define the
+ * no-current version first, and re-define later.
+ */
+#define pr_fmt(fmt)	AUFS_NAME " %s:%d: " fmt, __func__, __LINE__
+#include <linux/sched.h>
+#undef pr_fmt
+#define pr_fmt(fmt) \
+		AUFS_NAME " %s:%d:%.*s[%d]: " fmt, __func__, __LINE__, \
+		(int)sizeof(current->comm), current->comm, current->pid
+#else
+#include <stdint.h>
+#include <sys/types.h>
+#endif /* __KERNEL__ */
+
 #include <linux/limits.h>
-#include <linux/types.h>
 
-#define AUFS_VERSION	"2.1-39"
+#define AUFS_VERSION	"3.2.x-20131104"
 
 /* todo? move this to linux-2.6.19/include/magic.h */
 #define AUFS_SUPER_MAGIC	('a' << 24 | 'u' << 16 | 'f' << 8 | 's')
@@ -32,10 +48,10 @@
 /* ---------------------------------------------------------------------- */
 
 #ifdef CONFIG_AUFS_BRANCH_MAX_127
-typedef __s8 aufs_bindex_t;
+typedef int8_t aufs_bindex_t;
 #define AUFS_BRANCH_MAX 127
 #else
-typedef __s16 aufs_bindex_t;
+typedef int16_t aufs_bindex_t;
 #ifdef CONFIG_AUFS_BRANCH_MAX_511
 #define AUFS_BRANCH_MAX 511
 #elif defined(CONFIG_AUFS_BRANCH_MAX_1023)
@@ -53,7 +69,6 @@
 
 /* ---------------------------------------------------------------------- */
 
-#define AUFS_NAME		"aufs"
 #define AUFS_FSTYPE		AUFS_NAME
 
 #define AUFS_ROOT_INO		2
@@ -62,25 +77,24 @@
 #define AUFS_WH_PFX		".wh."
 #define AUFS_WH_PFX_LEN		((int)sizeof(AUFS_WH_PFX) - 1)
 #define AUFS_WH_TMP_LEN		4
-/* a limit for rmdir/rename a dir */
+/* a limit for rmdir/rename a dir and copyup */
 #define AUFS_MAX_NAMELEN	(NAME_MAX \
 				- AUFS_WH_PFX_LEN * 2	/* doubly whiteouted */\
 				- 1			/* dot */\
 				- AUFS_WH_TMP_LEN)	/* hex */
 #define AUFS_XINO_FNAME		"." AUFS_NAME ".xino"
 #define AUFS_XINO_DEFPATH	"/tmp/" AUFS_XINO_FNAME
-#define AUFS_XINO_TRUNC_INIT	64 /* blocks */
-#define AUFS_XINO_TRUNC_STEP	4  /* blocks */
+#define AUFS_XINO_DEF_SEC	30 /* seconds */
+#define AUFS_XINO_DEF_TRUNC	45 /* percentage */
 #define AUFS_DIRWH_DEF		3
 #define AUFS_RDCACHE_DEF	10 /* seconds */
 #define AUFS_RDCACHE_MAX	3600 /* seconds */
 #define AUFS_RDBLK_DEF		512 /* bytes */
 #define AUFS_RDHASH_DEF		32
 #define AUFS_WKQ_NAME		AUFS_NAME "d"
-#define AUFS_WKQ_PRE_NAME	AUFS_WKQ_NAME "_pre"
 #define AUFS_MFS_DEF_SEC	30 /* seconds */
 #define AUFS_MFS_MAX_SEC	3600 /* seconds */
-#define AUFS_PLINK_WARN		100 /* number of plinks */
+#define AUFS_PLINK_WARN		50 /* number of plinks in a single bucket */
 
 /* pseudo-link maintenace under /proc */
 #define AUFS_PLINK_MAINT_NAME	"plink_maint"
@@ -99,15 +113,13 @@
 #define AUFS_WH_PLINKDIR	AUFS_WH_PFX AUFS_PLINKDIR_NAME
 #define AUFS_WH_ORPHDIR		AUFS_WH_PFX AUFS_ORPHDIR_NAME
 
-/* branch permission */
+/* branch permissions and attributes */
 #define AUFS_BRPERM_RW		"rw"
 #define AUFS_BRPERM_RO		"ro"
 #define AUFS_BRPERM_RR		"rr"
-#define AUFS_BRPERM_WH		"wh"
-#define AUFS_BRPERM_NLWH	"nolwh"
-#define AUFS_BRPERM_ROWH	AUFS_BRPERM_RO "+" AUFS_BRPERM_WH
-#define AUFS_BRPERM_RRWH	AUFS_BRPERM_RR "+" AUFS_BRPERM_WH
-#define AUFS_BRPERM_RWNLWH	AUFS_BRPERM_RW "+" AUFS_BRPERM_NLWH
+#define AUFS_BRRATTR_WH		"wh"
+#define AUFS_BRWATTR_NLWH	"nolwh"
+#define AUFS_BRATTR_UNPIN	"unpin"
 
 /* ---------------------------------------------------------------------- */
 
@@ -133,23 +145,28 @@
 /* borrowed from linux/include/linux/compiler-gcc3.h */
 #ifndef __aligned
 #define __aligned(x)			__attribute__((aligned(x)))
+#endif
+
+#ifdef __KERNEL__
+#ifndef __packed
 #define __packed			__attribute__((packed))
 #endif
+#endif
 
 struct au_rdu_cookie {
-	__u64		h_pos;
-	__s16		bindex;
-	__u8		flags;
-	__u8		pad;
-	__u32		generation;
+	uint64_t	h_pos;
+	int16_t		bindex;
+	uint8_t		flags;
+	uint8_t		pad;
+	uint32_t	generation;
 } __aligned(8);
 
 struct au_rdu_ent {
-	__u64		ino;
-	__s16		bindex;
-	__u8		type;
-	__u8		nlen;
-	__u8		wh;
+	uint64_t	ino;
+	int16_t		bindex;
+	uint8_t		type;
+	uint8_t		nlen;
+	uint8_t		wh;
 	char		name[0];
 } __aligned(8);
 
@@ -157,12 +174,12 @@
 {
 	/* include the terminating NULL */
 	return ALIGN(sizeof(struct au_rdu_ent) + nlen + 1,
-		     sizeof(__u64));
+		     sizeof(uint64_t));
 }
 
 union au_rdu_ent_ul {
 	struct au_rdu_ent __user	*e;
-	__u64				ul;
+	uint64_t			ul;
 };
 
 enum {
@@ -173,34 +190,46 @@
 struct aufs_rdu {
 	/* input */
 	union {
-		__u64		sz;	/* AuCtl_RDU */
-		__u64		nent;	/* AuCtl_RDU_INO */
+		uint64_t	sz;	/* AuCtl_RDU */
+		uint64_t	nent;	/* AuCtl_RDU_INO */
 	};
 	union au_rdu_ent_ul	ent;
-	__u16			verify[AufsCtlRduV_End];
+	uint16_t		verify[AufsCtlRduV_End];
 
 	/* input/output */
-	__u32			blk;
+	uint32_t		blk;
 
 	/* output */
 	union au_rdu_ent_ul	tail;
 	/* number of entries which were added in a single call */
-	__u64			rent;
-	__u8			full;
-	__u8			shwh;
+	uint64_t		rent;
+	uint8_t			full;
+	uint8_t			shwh;
 
 	struct au_rdu_cookie	cookie;
 } __aligned(8);
 
+/* ---------------------------------------------------------------------- */
+
+struct aufs_wbr_fd {
+	uint32_t	oflags;
+	int16_t		brid;
+} __aligned(8);
+
+/* ---------------------------------------------------------------------- */
+
 struct aufs_ibusy {
-	__u64		ino, h_ino;
-	__s16		bindex;
+	uint64_t	ino, h_ino;
+	int16_t		bindex;
 } __aligned(8);
 
+/* ---------------------------------------------------------------------- */
+
 #define AuCtlType		'A'
 #define AUFS_CTL_RDU		_IOWR(AuCtlType, AuCtl_RDU, struct aufs_rdu)
 #define AUFS_CTL_RDU_INO	_IOWR(AuCtlType, AuCtl_RDU_INO, struct aufs_rdu)
-#define AUFS_CTL_WBR_FD		_IO(AuCtlType, AuCtl_WBR_FD)
+#define AUFS_CTL_WBR_FD		_IOW(AuCtlType, AuCtl_WBR_FD, \
+				     struct aufs_wbr_fd)
 #define AUFS_CTL_IBUSY		_IOWR(AuCtlType, AuCtl_IBUSY, struct aufs_ibusy)
 
 #endif /* __AUFS_TYPE_H__ */
diff -ru --new-file linux-3.x-orig/include/linux/mm.h linux-3.x/include/linux/mm.h
--- linux-3.x-orig/include/linux/mm.h	2014-12-11 11:32:25.000000000 +0000
+++ linux-3.x/include/linux/mm.h	2014-12-23 17:23:09.067087000 +0000
@@ -17,6 +17,9 @@
 #include <linux/pfn.h>
 #include <linux/bit_spinlock.h>
 #include <linux/shrinker.h>
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/fs.h>
 
 struct mempolicy;
 struct anon_vma;
@@ -999,6 +1002,84 @@
 }
 #endif
 
+/*
+ * Mainly for aufs which mmap(2) diffrent file and wants to print different path
+ * in /proc/PID/maps.
+ */
+/* #define AUFS_DEBUG_MMAP */
+static inline void aufs_trace(struct file *f, struct file *pr,
+                              const char func[], int line, const char func2[])
+{
+#ifdef AUFS_DEBUG_MMAP
+	if (pr)
+		pr_info("%s:%d: %s, %p\n", func, line, func2,
+			f ? (char *)f->f_dentry->d_name.name : "(null)");
+#endif
+}
+
+static inline struct file *vmr_do_pr_or_file(struct vm_region *region,
+                                             const char func[], int line)
+{
+	struct file *f = region->vm_file, *pr = region->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	return (f && pr) ? pr : f;
+}
+
+static inline void vmr_do_fput(struct vm_region *region,
+                               const char func[], int line)
+{
+	struct file *f = region->vm_file, *pr = region->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	fput(f);
+	if (f && pr)
+		fput(pr);
+}
+
+static inline void vma_do_file_update_time(struct vm_area_struct *vma,
+                                           const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	file_update_time(f);
+	if (f && pr)
+		file_update_time(pr);
+}
+
+static inline struct file *vma_do_pr_or_file(struct vm_area_struct *vma,
+                                             const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	return (f && pr) ? pr : f;
+}
+
+static inline void vma_do_get_file(struct vm_area_struct *vma,
+                                   const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	get_file(f);
+	if (f && pr)
+		get_file(pr);
+}
+
+static inline void vma_do_fput(struct vm_area_struct *vma,
+                               const char func[], int line)
+{
+	struct file *f = vma->vm_file, *pr = vma->vm_prfile;
+	aufs_trace(f, pr, func, line, __func__);
+	fput(f);
+	if (f && pr)
+		fput(pr);
+}
+
+#define vmr_pr_or_file(region)		vmr_do_pr_or_file(region, __func__, __LINE__)
+#define vmr_fput(region)		vmr_do_fput(region, __func__, __LINE__)
+#define vma_file_update_time(vma)	vma_do_file_update_time(vma, __func__, __LINE__)
+#define vma_pr_or_file(vma)		vma_do_pr_or_file(vma, __func__, __LINE__)
+#define vma_get_file(vma)		vma_do_get_file(vma, __func__, __LINE__)
+#define vma_fput(vma)			vma_do_fput(vma, __func__, __LINE__)
+
 extern int make_pages_present(unsigned long addr, unsigned long end);
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
diff -ru --new-file linux-3.x-orig/include/linux/mm_types.h linux-3.x/include/linux/mm_types.h
--- linux-3.x-orig/include/linux/mm_types.h	2014-12-11 11:32:26.000000000 +0000
+++ linux-3.x/include/linux/mm_types.h	2014-12-23 17:23:09.067087000 +0000
@@ -186,6 +186,7 @@
 	unsigned long	vm_top;		/* region allocated to here */
 	unsigned long	vm_pgoff;	/* the offset in vm_file corresponding to vm_start */
 	struct file	*vm_file;	/* the backing file or NULL */
+	struct file	*vm_prfile;	/* the virtual backing file or NULL */
 
 	int		vm_usage;	/* region usage count (access under nommu_region_sem) */
 	bool		vm_icache_flushed : 1; /* true if the icache has been flushed for
@@ -250,6 +251,7 @@
 					   units, *not* PAGE_CACHE_SIZE */
 #endif
 	struct file * vm_file;		/* File we map to (can be NULL). */
+	struct file *vm_prfile;		/* shadow of vm_file */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
 
 #ifndef CONFIG_MMU
diff -ru --new-file linux-3.x-orig/include/linux/syno_user.h linux-3.x/include/linux/syno_user.h
--- linux-3.x-orig/include/linux/syno_user.h	2014-12-11 11:32:26.000000000 +0000
+++ linux-3.x/include/linux/syno_user.h	2014-12-23 17:23:09.067087000 +0000
@@ -4,6 +4,11 @@
 #define __SYNO_USER_H_
 
 /**
+ * XPEnology hack
+ */
+#define XPENOLOGY
+
+/**
  * Dsc: Synology multimedia server feature. For indexing video, photo,
  *      music.
  * Ref: libsynosdk, lnxnetatalk, lnxsdk, rsync, samba, smbftpd
diff -ru --new-file linux-3.x-orig/kernel/fork.c linux-3.x/kernel/fork.c
--- linux-3.x-orig/kernel/fork.c	2014-12-23 18:13:05.823087000 +0000
+++ linux-3.x/kernel/fork.c	2014-12-23 17:23:09.067087000 +0000
@@ -378,7 +378,7 @@
 			struct inode *inode = file->f_path.dentry->d_inode;
 			struct address_space *mapping = file->f_mapping;
 
-			get_file(file);
+			vma_get_file(tmp);
 			if (tmp->vm_flags & VM_DENYWRITE)
 				atomic_dec(&inode->i_writecount);
 			mutex_lock(&mapping->i_mmap_mutex);
diff -ru --new-file linux-3.x-orig/kernel/sysctl.c linux-3.x/kernel/sysctl.c
--- linux-3.x-orig/kernel/sysctl.c	2014-12-23 18:13:13.715087000 +0000
+++ linux-3.x/kernel/sysctl.c	2014-12-23 17:23:09.067087000 +0000
@@ -229,7 +229,7 @@
 int (*funcSYNOGetHwCapability)(CAPABILITY *) = NULL;
 EXPORT_SYMBOL(funcSYNOGetHwCapability);
 
-#ifdef SYNO_EUNIT_POWERCTL_PIN
+#if defined(SYNO_EUNIT_POWERCTL_PIN) || defined(XPENOLOGY)
 EUNIT_PWRON_TYPE (*funcSynoEunitPowerctlType)(void) = NULL;
 EXPORT_SYMBOL(funcSynoEunitPowerctlType);
 #endif
diff -ru --new-file linux-3.x-orig/Makefile linux-3.x/Makefile
--- linux-3.x-orig/Makefile	2014-12-11 11:27:32.000000000 +0000
+++ linux-3.x/Makefile	2014-12-23 17:23:09.015087000 +0000
@@ -192,11 +192,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-#ARCH		?= $(SUBARCH)
-#CROSS_COMPILE	?=
-ARCH		?= arm
-CROSS_COMPILE	?= /usr/local/arm-marvell-linux-gnueabi/bin/arm-marvell-linux-gnueabi-
-#CROSS_COMPILE	?= /usr/local/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-
+ARCH		?= $(SUBARCH)
+CROSS_COMPILE	?=
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -ru --new-file linux-3.x-orig/mm/fremap.c linux-3.x/mm/fremap.c
--- linux-3.x-orig/mm/fremap.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/fremap.c	2014-12-23 17:23:09.067087000 +0000
@@ -198,10 +198,10 @@
 			struct file *file = vma->vm_file;
 
 			flags &= MAP_NONBLOCK;
-			get_file(file);
+			vma_get_file(vma);
 			addr = mmap_region(file, start, size,
 					flags, vma->vm_flags, pgoff);
-			fput(file);
+			vma_fput(vma);
 			if (IS_ERR_VALUE(addr)) {
 				err = addr;
 			} else {
diff -ru --new-file linux-3.x-orig/mm/madvise.c linux-3.x/mm/madvise.c
--- linux-3.x-orig/mm/madvise.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/madvise.c	2014-12-23 17:23:09.067087000 +0000
@@ -227,10 +227,10 @@
 	 * vma's reference to the file) can go away as soon as we drop
 	 * mmap_sem.
 	 */
-	get_file(f);
+	vma_get_file(vma);
 	up_read(&current->mm->mmap_sem);
 	error = vmtruncate_range(mapping->host, offset, endoff);
-	fput(f);
+	vma_fput(vma);
 	down_read(&current->mm->mmap_sem);
 	return error;
 }
diff -ru --new-file linux-3.x-orig/mm/memory.c linux-3.x/mm/memory.c
--- linux-3.x-orig/mm/memory.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/memory.c	2014-12-23 17:23:09.067087000 +0000
@@ -2646,7 +2646,7 @@
 
 		/* file_update_time outside page_lock */
 		if (vma->vm_file)
-			file_update_time(vma->vm_file);
+			vma_file_update_time(vma);
 
 		return ret;
 	}
@@ -3334,7 +3334,7 @@
 
 		/* file_update_time outside page_lock */
 		if (vma->vm_file)
-			file_update_time(vma->vm_file);
+			vma_file_update_time(vma);
 	} else {
 		unlock_page(vmf.page);
 		if (anon)
diff -ru --new-file linux-3.x-orig/mm/mmap.c linux-3.x/mm/mmap.c
--- linux-3.x-orig/mm/mmap.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/mmap.c	2014-12-23 17:23:09.075087000 +0000
@@ -235,7 +235,7 @@
 	if (vma->vm_ops && vma->vm_ops->close)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file) {
-		fput(vma->vm_file);
+		vma_fput(vma);
 		if (vma->vm_flags & VM_EXECUTABLE)
 			removed_exe_file_vma(vma->vm_mm);
 	}
@@ -622,7 +622,7 @@
 
 	if (remove_next) {
 		if (file) {
-			fput(file);
+			vma_fput(vma);
 			if (next->vm_flags & VM_EXECUTABLE)
 				removed_exe_file_vma(mm);
 		}
@@ -1338,8 +1338,8 @@
 unmap_and_free_vma:
 	if (correct_wcount)
 		atomic_inc(&inode->i_writecount);
+	vma_fput(vma);
 	vma->vm_file = NULL;
-	fput(file);
 
 	/* Undo any partial mapping done by a device driver. */
 	unmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);
@@ -1996,7 +1996,7 @@
 		goto out_free_mpol;
 
 	if (new->vm_file) {
-		get_file(new->vm_file);
+		vma_get_file(new);
 		if (vma->vm_flags & VM_EXECUTABLE)
 			added_exe_file_vma(mm);
 	}
@@ -2020,7 +2020,7 @@
 	if (new->vm_file) {
 		if (vma->vm_flags & VM_EXECUTABLE)
 			removed_exe_file_vma(mm);
-		fput(new->vm_file);
+		vma_fput(new);
 	}
 	unlink_anon_vmas(new);
  out_free_mpol:
@@ -2393,7 +2393,7 @@
 			new_vma->vm_end = addr + len;
 			new_vma->vm_pgoff = pgoff;
 			if (new_vma->vm_file) {
-				get_file(new_vma->vm_file);
+				vma_get_file(new_vma);
 				if (vma->vm_flags & VM_EXECUTABLE)
 					added_exe_file_vma(mm);
 			}
diff -ru --new-file linux-3.x-orig/mm/msync.c linux-3.x/mm/msync.c
--- linux-3.x-orig/mm/msync.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/msync.c	2014-12-23 17:23:09.075087000 +0000
@@ -80,10 +80,10 @@
 		start = vma->vm_end;
 		if ((flags & MS_SYNC) && file &&
 				(vma->vm_flags & VM_SHARED)) {
-			get_file(file);
+			vma_get_file(vma);
 			up_read(&mm->mmap_sem);
 			error = vfs_fsync(file, 0);
-			fput(file);
+			vma_fput(vma);
 			if (error || start >= end)
 				goto out;
 			down_read(&mm->mmap_sem);
diff -ru --new-file linux-3.x-orig/mm/nommu.c linux-3.x/mm/nommu.c
--- linux-3.x-orig/mm/nommu.c	2014-12-11 11:32:51.000000000 +0000
+++ linux-3.x/mm/nommu.c	2014-12-23 17:23:09.075087000 +0000
@@ -632,7 +632,7 @@
 		up_write(&nommu_region_sem);
 
 		if (region->vm_file)
-			fput(region->vm_file);
+			vmr_fput(region);
 
 		/* IO memory and memory shared directly out of the pagecache
 		 * from ramfs/tmpfs mustn't be released here */
@@ -790,7 +790,7 @@
 	if (vma->vm_ops && vma->vm_ops->close)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file) {
-		fput(vma->vm_file);
+		vma_fput(vma);
 		if (vma->vm_flags & VM_EXECUTABLE)
 			removed_exe_file_vma(mm);
 	}
@@ -1363,7 +1363,7 @@
 					goto error_just_free;
 				}
 			}
-			fput(region->vm_file);
+			vmr_fput(region);
 			kmem_cache_free(vm_region_jar, region);
 			region = pregion;
 			result = start;
@@ -1439,10 +1439,10 @@
 	up_write(&nommu_region_sem);
 error:
 	if (region->vm_file)
-		fput(region->vm_file);
+		vmr_fput(region);
 	kmem_cache_free(vm_region_jar, region);
 	if (vma->vm_file)
-		fput(vma->vm_file);
+		vma_fput(vma);
 	if (vma->vm_flags & VM_EXECUTABLE)
 		removed_exe_file_vma(vma->vm_mm);
 	kmem_cache_free(vm_area_cachep, vma);
